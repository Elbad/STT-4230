---
title: "Calculs statistiques et mathématiques en R"
author: "Sophie Baillargeon, Université Laval"
date: "2018-03-06"
weight: 2
slug: "calculs_stat_math_r"
categories: ["cours_2018-03-13"]
categories_weight: 1
lastmodifierdisplayname : "Sophie Baillargeon"
lastmodifieremail: "sophie.baillargeon@mat.ulaval.ca"
output:
  pdf_document:
    toc: yes
    toc_depth: 3
  blogdown::html_page:
    toc: true
header-includes:
- \usepackage[french]{babel}
- \frenchbsetup{StandardLayout}
- \hypersetup{colorlinks=true, urlcolor = {blue}, linkcolor = {blue}}
editor_options: 
  chunk_output_type: console
---





<div id="TOC">
<ul>
<li><a href="#calculs-statistiques">Calculs statistiques</a><ul>
<li><a href="#distributions-de-probabilite">Distributions de probabilité</a><ul>
<li><a href="#fonction-de-densite">Fonction de densité</a></li>
<li><a href="#fonction-de-repartition">Fonction de répartition</a></li>
<li><a href="#fonction-quantile">Fonction quantile</a></li>
</ul></li>
<li><a href="#generation-de-nombres-pseudo-aleatoires">Génération de nombres pseudo-aléatoires</a><ul>
<li><a href="#fonction-sample">Fonction <code>sample</code></a></li>
<li><a href="#germe-de-la-generation-pseudo-aleatoire">Germe de la génération pseudo-aléatoire</a></li>
</ul></li>
<li><a href="#calcul-de-statistiques-descriptives">Calcul de statistiques descriptives</a></li>
<li><a href="#tests-statistiques">Tests statistiques</a></li>
<li><a href="#ajustement-de-modeles">Ajustement de modèles</a><ul>
<li><a href="#formules">Formules</a></li>
<li><a href="#arguments-accompagnant-les-formules">Arguments accompagnant les formules</a></li>
<li><a href="#manipulation-de-la-sortie-dune-fonction-dajustement-de-modele">Manipulation de la sortie d’une fonction d’ajustement de modèle</a></li>
<li><a href="#resultats-additionnels-fournis-par-summary">Résultats additionnels fournis par <code>summary</code></a></li>
<li><a href="#mise-en-forme-de-la-sortie-dune-fonction-dajustement-de-modele-avec-le-package-broom">Mise en forme de la sortie d’une fonction d’ajustement de modèle avec le package <code>broom</code></a></li>
</ul></li>
<li><a href="#references-autres-methodes-statistiques">Références autres méthodes statistiques</a></li>
</ul></li>
<li><a href="#calculs-mathematiques">Calculs mathématiques</a><ul>
<li><a href="#operateurs-et-fonctions-de-base">Opérateurs et fonctions de base</a></li>
<li><a href="#calcul-de-distances">Calcul de distances</a></li>
<li><a href="#algebre-lineaire">Algèbre linéaire</a></li>
<li><a href="#calcul-differentiel-et-integral">Calcul différentiel et intégral</a></li>
<li><a href="#optimisation-numerique">Optimisation numérique</a></li>
</ul></li>
</ul>
</div>

<hr />
<div id="calculs-statistiques" class="section level1">
<h1>Calculs statistiques</h1>
<p>L’utilité première du logiciel R est la réalisation de calculs statistiques. Dans cette section, nous présentons les principaux outils pour réaliser de tels calculs.</p>
<p>Les premières fonctions abordées sont celles des familles suivantes.</p>
<table>
<colgroup>
<col width="21%" />
<col width="78%" />
</colgroup>
<thead>
<tr class="header">
<th>Famille de fonction</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>dxxx</code></td>
<td><strong>fonction de densité</strong> de la distribution <code>xxx</code></td>
</tr>
<tr class="even">
<td><code>pxxx</code></td>
<td><strong>fonction de répartition</strong> de la distribution <code>xxx</code></td>
</tr>
<tr class="odd">
<td><code>qxxx</code></td>
<td><strong>fonction quantile</strong> de la distribution <code>xxx</code></td>
</tr>
<tr class="even">
<td><code>rxxx</code></td>
<td>génération pseudo-aléatoirement d’observations selon la distribution <code>xxx</code></td>
</tr>
</tbody>
</table>
<p>Les fonctions de ces familles permettent de manipuler des distributions de probabilité. Cette section traite aussi d’autres fonctions de génération de nombres pseudo-aléatoires, de réalisation de tests statistiques et d’ajustement de modèles.</p>
<div id="distributions-de-probabilite" class="section level2">
<h2>Distributions de probabilité</h2>
<p>Le package <code>stats</code> de l’installation de base de R comprend, pour plusieurs distributions de probabilité, des fonctions R de calcul de :</p>
<ul>
<li>la fonction de densité (forme <code>dxxx</code> où <code>xxx</code> change selon la distribution),</li>
<li>la fonction de répartition (forme <code>pxxx</code>) et</li>
<li>la fonction quantile (forme <code>qxxx</code>).</li>
</ul>
<p>La fiche d’aide ouverte par la commande <a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/Distributions.html"><code>help(Distributions)</code></a> énumère toutes les distributions de probabilité offertes dans le package <code>stats</code>. Il existe aussi des fonctions relatives à d’autres distributions de probabilité dans des packages sur le CRAN (voir <a href="https://CRAN.R-project.org/view=Distributions" class="uri">https://CRAN.R-project.org/view=Distributions</a> pour découvrir ce qui est offert).</p>
<p>Ces fonctions sont utiles notamment pour calculer des valeurs critiques ou des seuils observés de tests d’hypothèses. Un exemple est présenté plus loin.</p>
<div id="fonction-de-densite" class="section level3">
<h3>Fonction de densité</h3>
<p>Les fonctions R implémentant des <a href="https://fr.wikipedia.org/wiki/Densit%C3%A9_de_probabilit%C3%A9">fonctions de densité</a> ont un nom qui débute par le lettre <code>d</code> pour <em>density</em>. Leur premier argument est toujours un vecteur de valeurs en lesquelles calculer la fonction de densité. Les arguments suivants servent à spécifier les valeurs des paramètres de la distribution.</p>
<p>Dans le cas d’une variable aléatoire discrète, la fonction de densité est plus justement appelée <a href="https://fr.wikipedia.org/wiki/Fonction_de_masse_(probabilit%C3%A9s)">fonction de masse</a>. Il s’agit alors d’une probabilité, pour une variable aléatoire suivant une certaine distribution, de prendre une certaine valeur.</p>
<div id="exemple-distribution-binomiale" class="section level4">
<h4>Exemple : Distribution binomiale</h4>
<p>Soit <span class="math inline">\(X\)</span> une variable aléatoire représentant le nombre de 6 obtenus lors de 5 lancés d’un dé. Cette variable aléatoire suit une distribution binomiale de paramètres <span class="math inline">\(n = 5\)</span> et <span class="math inline">\(p = 1/6\)</span>, donc <span class="math inline">\(X \sim Bin(5, 1/6)\)</span>.</p>
<p>Calculons <span class="math inline">\(P(X = 2)\)</span>, soit la probabilité que la variable aléatoire <span class="math inline">\(X\)</span> prenne la valeur 2.</p>
<pre class="r"><code>dbinom(x = 2, size = 5, prob = 1/6)</code></pre>
<pre><code>## [1] 0.160751</code></pre>
<p>La fonction <code>dbinom</code> implémente donc la fonction de densité d’une distribution binomiale. Les arguments <code>size</code> et <code>prob</code> sont les paramètres <span class="math inline">\(n\)</span> et <span class="math inline">\(p\)</span> de la distribution, selon la notation utilisée ci-dessus.</p>
<p>Les fonctions de la famille <code>dxxx</code> peuvent calculer plusieurs valeurs de densité par un seul appel de la fonction, car celles-ci acceptent des valeurs d’arguments de longueur supérieure à 1. Ces fonctions travaillent donc de façon vectorielle, comme presque toutes les fonctions de calcul en R.</p>
<p>Voici un exemple de code R permettant de représenter graphiquement la densité <span class="math inline">\(Bin(5, 1/6)\)</span> complète, en mettant en évidence la valeur calculée ci-dessus, soit <span class="math inline">\(P(X = 2)\)</span>.</p>
<pre class="r"><code>barplot(dbinom(0:5, size = 5, prob = 1/6), 
        names.arg = 0:5, main = &quot;Densité Binomiale(5, 1/6)&quot;,
        xlab = &quot;x&quot;, ylab = &quot;dbinom(x, size = 5, prob = 1/6)&quot;)
barplot(c(0, 0, dbinom(2, size = 5, prob = 1/6), 0, 0),
        col = &quot;blue&quot;, add = TRUE)</code></pre>
<p><img src="/calculs/calculs_stat_math_r_2018_files/figure-html/unnamed-chunk-2-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="exemple-distribution-normale-standard" class="section level4">
<h4>Exemple : Distribution normale standard</h4>
<p>Supposons maintenant que <span class="math inline">\(X\)</span> est une variable aléatoire continue de distribution normale standard, donc <span class="math inline">\(X \sim N(0, 1)\)</span>. La valeur de la fonction de densité pour cette distribution en la valeur <span class="math inline">\(x = 1\)</span>, souvent notée <span class="math inline">\(f_X(1)\)</span>, vaut :</p>
<pre class="r"><code>dnorm(x = 1)</code></pre>
<pre><code>## [1] 0.2419707</code></pre>
<p>Voici une représentation graphique de la densité complète dans laquelle la valeur calculée ci-dessus est mise en évidence.</p>
<pre class="r"><code>curve(dnorm, xlim = c(-3, 3), main = &quot;Densité N(0,1)&quot;)
segments(-4, dnorm(1), 1, dnorm(1), lty = 2, col = &quot;blue&quot;)
segments(1, dnorm(1), 1, -1, lty = 2, col = &quot;blue&quot;)</code></pre>
<p><img src="/calculs/calculs_stat_math_r_2018_files/figure-html/unnamed-chunk-4-1.png" width="60%" style="display: block; margin: auto;" /></p>
<p>Ici, nous n’avons pas eu besoin de fournir des valeurs aux arguments de la fonction <code>dnorm</code> relatifs aux paramètres de la distribution, parce que nous avons utilisés leurs valeurs par défaut. Ces paramètres, pour la densité <span class="math inline">\(N(\mu, \sigma^2)\)</span>, sont représentés par les arguments <code>mean</code> = <span class="math inline">\(\mu\)</span> et <code>sd</code> = <span class="math inline">\(\sigma\)</span> (remarquez que l’argument de la fonction R représente l’écart-type, pas la variance).</p>
<p>Tout comme le premier argument, nommé <span class="math inline">\(x\)</span>, les arguments des fonctions de la famille <code>dxxx</code> représentant des paramètres de la distribution acceptent aussi en entrée plus d’une valeur. Voici un exemple, qui permet de calculer la densité en <span class="math inline">\(x = 1\)</span> pour <span class="math inline">\(X \sim N(\mu = -2, \sigma^2 = 1)\)</span>, <span class="math inline">\(X \sim N(\mu = 0, \sigma^2 = 2.25)\)</span> et <span class="math inline">\(X \sim N(\mu = 1, \sigma^2 = 4)\)</span> en un seul appel à la fonction <code>dnorm</code>.</p>
<pre class="r"><code>dnorm(x = 1, mean = c(-2, 0, 1), sd = c(1, 1.5, 2))</code></pre>
<pre><code>## [1] 0.004431848 0.212965337 0.199471140</code></pre>
</div>
</div>
<div id="fonction-de-repartition" class="section level3">
<h3>Fonction de répartition</h3>
<p>La <a href="https://fr.wikipedia.org/wiki/Fonction_de_r%C3%A9partition">fonction de répartition</a> d’une variable aléatoire <span class="math inline">\(X\)</span> est définie par <span class="math inline">\(F_X(x) = P(X \le x)\)</span>. Il s’agit donc toujours d’une probabilité, d’où le <code>p</code> au début des noms des fonctions R implémentant des fonctions de répartition.</p>
<div id="exemple-distribution-normale-standard-1" class="section level4">
<h4>Exemple : Distribution normale standard</h4>
<p>Prenons encore comme exemple la distribution normale standard. Nous avons donc <span class="math inline">\(X \sim N(0, 1)\)</span>. Calculons la valeur de la fonction de répartition de cette variable aléatoire en <span class="math inline">\(x = 1\)</span>.</p>
<pre class="r"><code>pnorm(q = 1)</code></pre>
<pre><code>## [1] 0.8413447</code></pre>
<p>Il s’agit de la valeur de la probabilité <span class="math inline">\(P(X \le 1)\)</span>.</p>
<p>Le premier argument des fonctions de la famille <code>pxxx</code> ne se nomme pas <code>x</code>, il se nomme plutôt <code>q</code>. Cette lettre réfère au mot quantile et souligne le lien entre les fonctions de répartition et les fonctions quantiles. Les arguments suivants des fonctions de la famille <code>pxxx</code> permettent de spécifier les valeurs des paramètres de la distribution, comme pour les fonctions de la famille <code>pxxx</code>.</p>
<p>Voici une illustration graphique du lien entre la fonction de densité et la fonction de répartition pour la distribution normale standard.</p>
<pre class="r"><code>par(mfrow = c(1,2))

curve(dnorm, xlim = c(-3, 3), main = &quot;Densité N(0,1)&quot;)
x &lt;- seq(-3, 1, length = 100)
polygon(c(x, 1, -3), c(dnorm(x), 0, 0), col = &quot;blue&quot;)

curve(pnorm, xlim = c(-3, 3), main = &quot;Fonction de répartition N(0,1)&quot;, xname = &quot;q&quot;)
segments(-4, pnorm(1), 1, pnorm(1), lty = 2, col = &quot;blue&quot;)
segments(1, pnorm(1), 1, -1, lty = 2, col = &quot;blue&quot;)

par(mfrow = c(1,1))</code></pre>
<p><img src="/calculs/calculs_stat_math_r_2018_files/figure-html/unnamed-chunk-7-1.png" width="100%" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="fonction-quantile" class="section level3">
<h3>Fonction quantile</h3>
<p>La <a href="https://fr.wikipedia.org/wiki/Fonction_quantile">fonction quantile</a> est l’inverse généralisé de la fonction de répartition. Les fonctions R implémentant des fonctions quantile ont un nom qui débute par le lettre <code>q</code> pour <em>quantile</em>.</p>
<div id="exemple-distribution-normale-standard-2" class="section level4">
<h4>Exemple : Distribution normale standard</h4>
<p>Pour clore l’exemple de la distribution normale standard, voyons de quoi à l’air la fonction quantile de cette distribution.</p>
<p>Premièrement, calculons la valeur de la fonction quantile en un point, disons en <span class="math inline">\(p = 0.8413447\)</span>.</p>
<pre class="r"><code>qnorm(p = 0.8413447)</code></pre>
<pre><code>## [1] 0.9999998</code></pre>
<p>Il s’agit de la valeur <span class="math inline">\(x\)</span> pour laquelle <span class="math inline">\(P(X \le x) = 0.8413447\)</span>, où <span class="math inline">\(X \sim N(0, 1)\)</span>.</p>
<p>Le premier argument d’une fonction de la famille <code>qxxx</code> se nomme <code>p</code>. Cette notation peut nous aider à nous rappeler que cet argument représente une probabilité et accepte donc seulement des valeurs entre 0 et 1. Encore une fois, les arguments suivants des fonctions de la famille <code>qxxx</code> permettent de spécifier les valeurs des paramètres de la distribution.</p>
<p>Le graphique suivant illustre le lien entre la fonction de répartition et la fonction quantile.</p>
<pre class="r"><code>par(mfrow = c(1,2))

curve(pnorm, xlim = c(-3, 3), main = &quot;Fonction de répartition N(0,1)&quot;, xname = &quot;q&quot;)
segments(-4, pnorm(1), 1, pnorm(1), lty = 2, col = &quot;blue&quot;)
segments(1, pnorm(1), 1, -1, lty = 2, col = &quot;blue&quot;)

curve(qnorm, xlim = c(0, 1), main = &quot;Fonction quantile  N(0,1)&quot;, xname = &quot;p&quot;)
segments(-0.2, qnorm(pnorm(1)), pnorm(1), qnorm(pnorm(1)), lty = 2, col = &quot;blue&quot;)
segments(pnorm(1), qnorm(pnorm(1)), pnorm(1), -3, lty = 2, col = &quot;blue&quot;)

par(mfrow = c(1,1))</code></pre>
<p><img src="/calculs/calculs_stat_math_r_2018_files/figure-html/unnamed-chunk-9-1.png" width="100%" style="display: block; margin: auto;" /></p>
</div>
</div>
</div>
<div id="generation-de-nombres-pseudo-aleatoires" class="section level2">
<h2>Génération de nombres pseudo-aléatoires</h2>
<p>En R, les fonctions <code>rxxx</code> permettent de générer pseudo-aléatoirement des observations selon une certaine distribution désignée par <code>xxx</code>.</p>
<p>Par exemple, voici la représentation graphique de 3 échantillons générés aléatoirement selon 3 distributions différentes : des distributions normale, uniforme continue et khi-deux. Pour chaque échantillon, nous traçons l’histogramme des observations simulées pour représenter leur densité empirique. Nous superposons à cet histogramme la courbe de densité de la distribution théorique à partir de laquelle les observations ont été générées.</p>
<pre class="r"><code>par(mfrow = c(1, 3))

# Densité normale d&#39;espérance 5 et de variance 4
x1 &lt;- rnorm(1000, mean = 5, sd = 2)
hist(x1, freq = FALSE, ylab = &quot;Proportion&quot;, main = &quot;Densité empirique de x1&quot;)
curve(dnorm(x, mean = 5, sd = 2), add = TRUE, col = &quot;blue&quot;)
title(main = &quot;courbe bleue = densité visée N(5,2)&quot;, line = 0.5)

# Densité uniforme continue entre 2 et 8
x2 &lt;- runif(1000, min = 2, max = 8)
hist(x2, freq = FALSE, ylab = &quot;Proportion&quot;, main = &quot;Densité empirique de x2&quot;)
curve(dunif(x, min = 2, max = 8), add = TRUE, col = &quot;blue&quot;)
title(main = &quot;courbe bleue = densité visée U(2,8)&quot;, line = 0.5)

# Densité chi-carré à 4 degrés de liberté
x3 &lt;- rchisq(1000, df = 4)
hist(x3, freq = FALSE, ylab = &quot;Proportion&quot;, main = &quot;Densité empirique de x3&quot;)
curve(dchisq(x, df = 4), add = TRUE, col = &quot;blue&quot;)
title(main = expression(paste(&quot;courbe bleue = densité visée &quot;, chi[4]^2)), line = 0.5)

par(mfrow = c(1,1))</code></pre>
<p><img src="/calculs/calculs_stat_math_r_2018_files/figure-html/unnamed-chunk-11-1.png" width="960" style="display: block; margin: auto;" /></p>
<p>Comme nous pouvons le constater sur ces graphiques, la distribution empirique des observations générées avec ces fonctions se rapproche vraiment de la distribution théorique demandée. En générant un nombre encore plus grand d’observations (ici nous en avons généré 1000 pour chaque distribution), la densité empirique se rapprocherait encore plus de la densité théorique.</p>
<div id="fonction-sample" class="section level3">
<h3>Fonction <code>sample</code></h3>
<p>La fonction <code>sample</code> permet de tirer un échantillon aléatoire,</p>
<pre class="r"><code>sample(1:6, size = 6)</code></pre>
<pre><code>## [1] 6 3 4 1 2 5</code></pre>
<p>sans (par défaut) ou avec remise,</p>
<pre class="r"><code>sample(1:6, size = 6, replace = TRUE)</code></pre>
<pre><code>## [1] 4 4 4 5 2 1</code></pre>
<p>en utilisant des probabilités de sélection égales (par défaut) entre les éléments de l’ensemble de départ ou non.</p>
<pre class="r"><code>sample(1:6, size = 6, replace = TRUE, prob = c(1/2, rep(1/10, 5)))</code></pre>
<pre><code>## [1] 1 1 1 4 1 1</code></pre>
<p>La fonction <code>sample</code> prend comme premier argument un vecteur représentant l’ensemble des éléments à partir desquels faire le tirage aléatoire. La fonction <code>sample.int</code> est très similaire à la fonction <code>sample</code>, mais elle prend comme premier argument un seul entier, <code>n</code>, et tire aléatoirement <code>size</code> entiers entre 1 et <code>n</code>.</p>
<p>Si nous souhaitons sélectionner aléatoirement des observations (lignes) dans un jeu de données, il est d’usage de sélectionner d’abord des entiers compris entre 1 et le nombre total d’observations, puis d’extraire du jeu de donnée les observations sur les lignes portant les numéros sélectionnés. Voici un exemple, utilisant les données sur les <a href="https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/iris.html">iris de Fisher</a> incluses dans l’installation de base de R.</p>
<pre class="r"><code>str(iris)</code></pre>
<pre><code>## &#39;data.frame&#39;:    150 obs. of  5 variables:
##  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
##  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
##  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
##  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
##  $ Species     : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...</code></pre>
<pre class="r"><code>index_ech &lt;- sample.int(n = nrow(iris), size = 5, replace = FALSE)
index_ech</code></pre>
<pre><code>## [1] 97 28 50 29 33</code></pre>
<pre class="r"><code>iris_ech &lt;- iris[index_ech, ]
iris_ech</code></pre>
<pre><code>##    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species
## 97          5.7         2.9          4.2         1.3 versicolor
## 28          5.2         3.5          1.5         0.2     setosa
## 50          5.0         3.3          1.4         0.2     setosa
## 29          5.2         3.4          1.4         0.2     setosa
## 33          5.2         4.1          1.5         0.1     setosa</code></pre>
</div>
<div id="germe-de-la-generation-pseudo-aleatoire" class="section level3">
<h3>Germe de la génération pseudo-aléatoire</h3>
<p>Les nombres générés avec les fonctions <code>rxxx</code> et les échantillons tirés avec <code>sample</code> sont qualifiés de pseudo-aléatoires, car ils proviennent d’un algorithme déterministe qui tente de reproduire le hasard. Un tel algorithme est nommé en anglais <em>random number generator</em> (RNG) ou <em>pseudo-random number generator</em>. La fiche d’aide ouverte par la commande <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/Random.html"><code>help(Random)</code></a> contient de l’information sur la génération de nombres pseudo-aléatoires en R.</p>
<p>Plusieurs RNG sont implémentés en R. Celui utilisé par défaut, nommé Mersenne Twister, a été choisi parce qu’il est réputé être bon. Sans entrer dans les détails du fonctionnement des RNG implémentés dans le package <code>base</code> de R, il faut savoir qu’ils travaillent tous à partir d’une séquence de nombres appelée <em>germe</em> (en anglais <em>seed</em>). En contrôlant ce germe, il est possible de générer de nouveau, autant de fois que désiré, les mêmes valeurs.</p>
<p>Par défaut, R contrôle le germe des RNG de façon automatique. Chaque fois qu’une commande faisant intervenir un RNG est évaluée, R crée un nouveau germe à partir, notamment, de l’heure à laquelle la commande est soumise. Ainsi, deux générations pseudo-aléatoires consécutives ne produisent en général pas le même résultat.</p>
<pre class="r"><code>sample(letters, size = 5)</code></pre>
<pre><code>## [1] &quot;e&quot; &quot;y&quot; &quot;u&quot; &quot;d&quot; &quot;b&quot;</code></pre>
<pre class="r"><code>sample(letters, size = 5)</code></pre>
<pre><code>## [1] &quot;e&quot; &quot;t&quot; &quot;w&quot; &quot;m&quot; &quot;j&quot;</code></pre>
<p>En tout temps, il est possible de connaître le germe du RNG en R. Il est stocké dans un objet nommé <code>.Random.seed</code>. Cet objet est un vecteur numérique de longueur 626 pour le RNG Mersenne Twister. Voyons de quoi ont l’air les premiers éléments de ce vecteur à différents moments.</p>
<pre class="r"><code>str(.Random.seed)</code></pre>
<pre><code>##  int [1:626] 403 33 1251620403 -210262575 800159616 -228103586 -1008250455 -149338512..</code></pre>
<pre class="r"><code>sample(letters, size = 5)</code></pre>
<pre><code>## [1] &quot;i&quot; &quot;w&quot; &quot;p&quot; &quot;f&quot; &quot;d&quot;</code></pre>
<pre class="r"><code>str(.Random.seed)</code></pre>
<pre><code>##  int [1:626] 403 38 1251620403 -210262575 800159616 -228103586 -1008250455 -149338512..</code></pre>
<pre class="r"><code>sample(letters, size = 5)</code></pre>
<pre><code>## [1] &quot;l&quot; &quot;f&quot; &quot;w&quot; &quot;n&quot; &quot;h&quot;</code></pre>
<pre class="r"><code>str(.Random.seed)</code></pre>
<pre><code>##  int [1:626] 403 43 1251620403 -210262575 800159616 -228103586 -1008250455 -149338512..</code></pre>
<p>Nous constatons qu’au moins un élément de ce vecteur (le deuxième élément) change à chaque fois que nous appelons la fonction <code>sample</code>. La fonction <code>set.seed</code> permet de fixer le germe du RNG à partir d’une seule valeur entière. Par exemple, la commande suivante :</p>
<pre class="r"><code>set.seed(753)</code></pre>
<p>spécifie le germe suivant :</p>
<pre class="r"><code>str(.Random.seed)</code></pre>
<pre><code>##  int [1:626] 403 624 302719261 615841082 -1828406925 -1314498536 214287161 142621094 ..</code></pre>
<p>En soumettant de nouveau le même appel à la fonction <code>sample</code>, nous obtenons l’échantillon suivant.</p>
<pre class="r"><code>sample(letters, size = 5)</code></pre>
<pre><code>## [1] &quot;n&quot; &quot;v&quot; &quot;m&quot; &quot;x&quot; &quot;g&quot;</code></pre>
<p>La soumission de cette commande a eu pour effet de modifier le germe.</p>
<pre class="r"><code>str(.Random.seed)</code></pre>
<pre><code>##  int [1:626] 403 5 47777699 -819670847 -326033232 523235278 1163109177 1104276299 186..</code></pre>
<p>Donc si nous resoumettons la commande <code>sample</code>, nous n’obtiendrons sûrement pas le même résultat.</p>
<pre class="r"><code>sample(letters, size = 5)</code></pre>
<pre><code>## [1] &quot;e&quot; &quot;j&quot; &quot;o&quot; &quot;i&quot; &quot;g&quot;</code></pre>
<p>Par contre, si nous fixons de nouveau le germe à partir de l’entier 753 avec <code>set.seed</code>, nous arriverons à obtenir de nouveau l’avant-dernier échantillon généré.</p>
<pre class="r"><code>set.seed(753)
sample(letters, size = 5)</code></pre>
<pre><code>## [1] &quot;n&quot; &quot;v&quot; &quot;m&quot; &quot;x&quot; &quot;g&quot;</code></pre>
<p>À n’importe quel moment, dans n’importe qu’elle session R, nous obtiendrons l’échantillon {n, v, m, x, g} si nous soumettons la commande <code>set.seed(753)</code> avant la commande <code>sample(letters, size = 5)</code>.</p>
<p> </p>
</div>
</div>
<div id="calcul-de-statistiques-descriptives" class="section level2">
<h2>Calcul de statistiques descriptives</h2>
<p>Les fonctions pour des calculs de statistiques descriptives de base ont été vues dans les notes intitulées <a href="https://stt4230.rbind.io/calculs/calculs_base_r/#fonctions-pour-le-calcul-de-statistiques-descriptives">Calculs de base en R</a>.</p>

</div>
<div id="tests-statistiques" class="section level2">
<h2>Tests statistiques</h2>
<p>Il existe des fonctions R pour faire des tests statistiques de base. En voici quelques-unes :</p>
<ul>
<li>tests sur une ou des moyennes : <code>t.test</code>;</li>
<li>tests sur une ou des proportions : <code>prop.test</code>, <code>binom.test</code>;</li>
<li>tests de comparaison de variances : <code>var.test</code>, <code>bartlett.test</code>;</li>
<li>tests sur une corrélation : <code>cor.test</code>;</li>
<li>tests pour une distribution : <code>shapiro.test</code>, <code>ks.test</code>;</li>
<li>tests non paramétriques : <code>wilcox.test</code>, <code>kruskal.test</code>, <code>friedman.test</code>;</li>
<li>tests sur des fréquences : <code>chisq.test</code>, <code>fisher.test</code>, <code>mantelhaen.test</code>.</li>
</ul>
<p>Utilisons encore une fois les données <code>iris</code> pour construire un exemple de test de comparaison de moyennes. Nous allons comparer les largeurs moyennes des sépales des espèces versicolor et virginica.</p>
<div id="test-t-bilateral-de-comparaison-de-moyennes-avec-variances-inegales" class="section level5">
<h5>Test t bilatéral de comparaison de moyennes, avec variances inégales :</h5>
<pre class="r"><code>t.test(Sepal.Width ~ Species, data = iris, 
       subset = Species %in% c(&quot;versicolor&quot;, &quot;virginica&quot;))</code></pre>
<pre><code>## 
##  Welch Two Sample t-test
## 
## data:  Sepal.Width by Species
## t = -3.2058, df = 97.927, p-value = 0.001819
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -0.33028364 -0.07771636
## sample estimates:
## mean in group versicolor  mean in group virginica 
##                    2.770                    2.974</code></pre>
<p>Lorsque nous connaissons la valeur d’une statistique de test ainsi que sa loi sous l’hypothèse nulle, il est possible de calculer en R le seuil observé du test avec la bonne fonction <code>pxxx</code>. Par exemple, dans le test t ci-dessus, nous pouvons retrouver la valeur du seuil observé ainsi :</p>
<pre class="r"><code># multiplication par 2, car le test est bilatéral et la loi t est symétrique
pt(-3.2058, df = 97.927)*2 </code></pre>
<pre><code>## [1] 0.001819258</code></pre>
</div>
<div id="test-non-parametrique-equivalent" class="section level5">
<h5>Test non paramétrique équivalent :</h5>
<pre class="r"><code>wilcox.test(Sepal.Width ~ Species, data = iris, 
            subset = Species %in% c(&quot;versicolor&quot;, &quot;virginica&quot;), exact = FALSE)</code></pre>
<pre><code>## 
##  Wilcoxon rank sum test with continuity correction
## 
## data:  Sepal.Width by Species
## W = 841, p-value = 0.004572
## alternative hypothesis: true location shift is not equal to 0</code></pre>

</div>
</div>
<div id="ajustement-de-modeles" class="section level2">
<h2>Ajustement de modèles</h2>
<p>Il existe plusieurs fonctions en R pour ajuster des modèles. Les modèles les plus usuels sont :</p>
<ul>
<li>modèles linéaires, dont la régression : <code>lm</code>;</li>
<li>modèle d’analyse de la variance : <code>aov</code>;</li>
<li>modèles linéaires généralisés : <code>glm</code>;</li>
<li>modèles linéaires mixtes (peuvent contenir des effets aléatoires) : <code>lmer</code> du package <code>lme4</code> ou <code>lme</code> du package <code>nlme</code>;</li>
<li>modèles non linéaires : <code>nls</code>.</li>
</ul>
<p>Par exemple, ajustons quelques modèles sur les données des iris de Fisher.</p>
<div id="regression-lineaire-simple-entre-la-largeur-et-la-longueur-des-sepales" class="section level5">
<h5>Régression linéaire simple entre la largeur et la longueur des sépales :</h5>
<pre class="r"><code>reg &lt;- lm(Sepal.Width ~ Sepal.Length, data = iris)
reg</code></pre>
<pre><code>## 
## Call:
## lm(formula = Sepal.Width ~ Sepal.Length, data = iris)
## 
## Coefficients:
##  (Intercept)  Sepal.Length  
##      3.41895      -0.06188</code></pre>
</div>
<div id="anova-pour-comparer-les-largeurs-de-sepales-moyennes-entre-toutes-les-especes" class="section level5">
<h5>ANOVA pour comparer les largeurs de sépales moyennes entre toutes les espèces :</h5>
<pre class="r"><code>ANOVA &lt;- aov(Sepal.Width ~ Species, data = iris)
ANOVA</code></pre>
<pre><code>## Call:
##    aov(formula = Sepal.Width ~ Species, data = iris)
## 
## Terms:
##                  Species Residuals
## Sum of Squares  11.34493  16.96200
## Deg. of Freedom        2       147
## 
## Residual standard error: 0.3396877
## Estimated effects may be unbalanced</code></pre>
</div>
<div id="formules" class="section level3">
<h3>Formules</h3>
<p>Ces fonctions d’ajustement de modèles prennent obligatoirement en entrée une formule R, tout comme la fonction <code>xtabs</code>. D’autres fonctions acceptent aussi en entrée une formule, sans que ce type d’argument soit obligatoire. C’est le cas des fonctions <code>aggregate</code>, <code>ftable</code>, plusieurs des fonctions effectuant un test (ex. <code>t.test</code>, <code>wilcox.test</code>) et certaines fonctions graphiques (ex. <code>plot</code>, <code>boxplot</code>).</p>
<p>Les fonctions prenant une formule en entrée ont toujours un argument <code>data</code> pour spécifier d’où tirer les variables incluses dans la formule.</p>
<p>Une formule s’écrit sous la forme <code>y ~ x1 + x2</code> où <code>y</code> représente la variable réponse (dépendante) et <code>x1</code> et <code>x2</code> des variables explicatives (indépendantes). Dans la partie de droite, les opérateurs suivants peuvent apparaître :</p>
<ul>
<li><code>+</code> pour ajouter des termes;</li>
<li><code>-</code> pour soustraire des termes;</li>
<li><code>0</code> ou <code>1</code> pour représenter l’ordonnée à l’origine (par défaut tout modèle comporte une ordonnée à l’origine, pour la retirer il faut ajouter <code>- 1</code> ou <code>+ 0</code> à la partie de droite de la formule);</li>
<li><code>.</code> pour représenter toutes les variables dans le jeu de données fournit en argument <code>data</code>, autres que la variable mise à la gauche du <code>~</code> (note : le point signifie autre chose dans la fonction <code>update</code>).</li>
</ul>
<p>Opérateurs propres aux facteurs :</p>
<ul>
<li><code>:</code> pour les termes d’interaction entre facteurs;</li>
<li><code>*</code> pour le croisement de facteurs (<code>x1*x2</code> est équivalent à <code>x1 + x2 + x1:x2</code>);</li>
<li><code>^</code> pour le croisement de facteurs jusqu’à un certain niveau d’interaction (par exemple <code>(x1 + x2 + x3)^2</code> va inclure tous les termes de croisement des facteurs jusqu’aux interactions doubles <code>x1 + x2 + x3 + x1:x2 + x1:x3 + x2:x3</code>, mais pas l’interaction triple <code>x1:x2:x3</code>);</li>
<li><code>%in%</code> pour les facteurs emboîtés (dans <code>x2 %in% x1</code>, <code>x2</code> est emboîté dans <code>x1</code>).</li>
</ul>
<p>Autre opérateur :</p>
<ul>
<li><code>|</code> n’a pas toujours exactement la même signification selon la fonction, il représente parfois :
<ul>
<li>un conditionnement par rapport à une variable (ex. <code>y ~ x | a</code>, fonction <code>coplot</code>),</li>
<li>la structure d’effets aléatoires (fonctions <code>lmer</code> du package <code>lme4</code> et <code>lme</code> du package <code>nlme</code>).</li>
</ul></li>
</ul>
<p>Les formules peuvent inclurent des appels à des fonctions pour transformer les variables. Par exemple, pour ajuster un modèle sur la racine carrée de la variable réponse, on pourrait écrire <code>sqrt(y) ~ x1 + x2</code>. Certaines transformations pourraient faire intervenir un ou des opérateurs ayant une signification modifiée dans une formule. Par exemple, imaginons que nous voulons ajuster un modèle avec une seule variable explicative créée en additionnant les valeurs des variables <code>x1</code> et <code>x2</code>. La formule <code>y ~ x1 + x2</code> n’ajuste pas ce modèle puisque, dans une formule, l’opérateur <code>+</code> signifie « ajouter des termes » et non plus « additionner des valeurs ». Alors est-il possible d’ajuster le modèle souhaité (<em>sans ajouter une nouvelle variable dans les données</em>)?</p>
<p>Oui, c’est possible grâce à la fonction <code>I</code>. Il faut encadrer l’opération arithmétique à effectuer dans la formule d’un appel à la fonction <code>I</code>. Par exemple, <code>y ~ I(x1 + x2)</code> ajuste un modèle à une seule variable explicative formée de la somme des valeurs de <code>x1</code> et <code>x2</code>. Ainsi, <code>I()</code> permet d’utiliser la signification usuelle des opérateurs et non celle spécifique aux formules.</p>
<p> </p>
<p>Voici quelques exemples :</p>
<div id="retrait-de-lordonnee-a-lorigine" class="section level5">
<h5>Retrait de l’ordonnée à l’origine :</h5>
<pre class="r"><code>reg &lt;- lm(Sepal.Width ~ Sepal.Length - 1, data = iris)
# ou encore :
reg &lt;- lm(Sepal.Width ~ Sepal.Length + 0, data = iris)</code></pre>
<pre class="r"><code>coef(summary(reg))</code></pre>
<pre><code>##               Estimate  Std. Error  t value      Pr(&gt;|t|)
## Sepal.Length 0.5117739 0.008939966 57.24562 2.422615e-103</code></pre>
</div>
<div id="regression-log-log" class="section level5">
<h5>Régression log-log :</h5>
<pre class="r"><code>reg &lt;- lm(log(Sepal.Width) ~ log(Sepal.Length), data = iris)</code></pre>
<pre class="r"><code>coef(summary(reg))</code></pre>
<pre><code>##                     Estimate Std. Error   t value     Pr(&gt;|t|)
## (Intercept)        1.3057236 0.14573780  8.959402 1.293792e-15
## log(Sepal.Length) -0.1129573 0.08275742 -1.364920 1.743495e-01</code></pre>
</div>
<div id="regression-polynomiale" class="section level5">
<h5>Régression polynomiale :</h5>
<pre class="r"><code>reg &lt;- lm(Sepal.Width ~ Sepal.Length + Sepal.Length^2, data = iris)</code></pre>
<pre class="r"><code>coef(summary(reg))</code></pre>
<pre><code>##                Estimate Std. Error   t value     Pr(&gt;|t|)
## (Intercept)   3.4189468 0.25356227 13.483658 1.552431e-27
## Sepal.Length -0.0618848 0.04296699 -1.440287 1.518983e-01</code></pre>
<p>Non, ça n’a pas fonctionné. Dans une formule, l’opérateur <code>^</code> ne signifie pas exposant. Pour demander à R d’utiliser la signification usuelle de l’opérateur, et non celle spécifique aux formules, il faut encadrer le terme contenant l’opérateur de <code>I()</code> comme suit :</p>
<pre class="r"><code>reg &lt;- lm(Sepal.Width ~ Sepal.Length + I(Sepal.Length^2), data = iris)</code></pre>
<pre class="r"><code>coef(summary(reg))</code></pre>
<pre><code>##                      Estimate Std. Error   t value     Pr(&gt;|t|)
## (Intercept)        6.41583572 1.58499197  4.047866 8.327686e-05
## Sepal.Length      -1.08556027 0.53624556 -2.024372 4.474291e-02
## I(Sepal.Length^2)  0.08570656 0.04475502  1.915016 5.743267e-02</code></pre>
<p> </p>
<p><em>Création de variables catégoriques pour les exemples suivants :</em></p>
<pre class="r"><code>iris$Sepal.Length_catego &lt;- cut(iris$Sepal.Length, right = FALSE,
     breaks = c(-Inf, quantile(iris$Sepal.Length, probs = c(1/3, 2/3)), Inf))
iris$Petal.Width_catego &lt;- cut(iris$Petal.Width, right = FALSE,
     breaks = c(-Inf, quantile(iris$Petal.Width, probs = c(1/3, 2/3)), Inf))</code></pre>
</div>
<div id="anova-a-3-facteurs-modele-complet" class="section level5">
<h5>Anova à 3 facteurs, modèle complet :</h5>
<pre class="r"><code>ANOVA &lt;- aov(Sepal.Width ~ Species*Sepal.Length_catego*Petal.Width_catego, data = iris)
# ou encore
ANOVA &lt;- aov(Sepal.Width ~ (Species + Sepal.Length_catego + Petal.Width_catego)^3, 
             data = iris)</code></pre>
<pre class="r"><code>summary(ANOVA)</code></pre>
<pre><code>##                                                 Df Sum Sq Mean Sq F value   Pr(&gt;F)    
## Species                                          2 11.345   5.672  64.620  &lt; 2e-16 ***
## Sepal.Length_catego                              2  3.843   1.922  21.891 5.53e-09 ***
## Petal.Width_catego                               1  0.872   0.872   9.934  0.00199 ** 
## Species:Sepal.Length_catego                      3  0.077   0.026   0.291  0.83194    
## Species:Petal.Width_catego                       1  0.006   0.006   0.073  0.78754    
## Sepal.Length_catego:Petal.Width_catego           1  0.047   0.047   0.540  0.46357    
## Species:Sepal.Length_catego:Petal.Width_catego   1  0.002   0.002   0.026  0.87212    
## Residuals                                      138 12.114   0.088                     
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>

</div>
<div id="anova-a-3-facteurs-modele-complet-sans-linteraction-triple" class="section level5">
<h5>Anova à 3 facteurs, modèle complet sans l’interaction triple :</h5>
<pre class="r"><code>ANOVA &lt;- aov(Sepal.Width ~ Species*Sepal.Length_catego*Petal.Width_catego - 
               Species:Sepal.Length_catego:Petal.Width_catego, data = iris)
# ou encore
ANOVA &lt;- aov(Sepal.Width ~ (Species + Sepal.Length_catego + Petal.Width_catego)^2, 
             data = iris)</code></pre>
<pre class="r"><code>summary(ANOVA)</code></pre>
<pre><code>##                                         Df Sum Sq Mean Sq F value   Pr(&gt;F)    
## Species                                  2 11.345   5.672  65.076  &lt; 2e-16 ***
## Sepal.Length_catego                      2  3.843   1.922  22.046 4.83e-09 ***
## Petal.Width_catego                       1  0.872   0.872  10.004  0.00192 ** 
## Species:Sepal.Length_catego              3  0.077   0.026   0.293  0.83046    
## Species:Petal.Width_catego               1  0.006   0.006   0.073  0.78681    
## Sepal.Length_catego:Petal.Width_catego   1  0.047   0.047   0.544  0.46199    
## Residuals                              139 12.116   0.087                     
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
</div>
</div>
<div id="arguments-accompagnant-les-formules" class="section level3">
<h3>Arguments accompagnant les formules</h3>
<p>Pour les fonctions prenant une formule comme premier argument, cet argument est souvent le seul argument obligatoire.</p>
<pre class="r"><code>reg &lt;- lm(iris$Sepal.Width ~ iris$Sepal.Length)
coef(summary(reg))</code></pre>
<pre><code>##                     Estimate Std. Error   t value     Pr(&gt;|t|)
## (Intercept)        3.4189468 0.25356227 13.483658 1.552431e-27
## iris$Sepal.Length -0.0618848 0.04296699 -1.440287 1.518983e-01</code></pre>
<p>Cependant, un argument <code>formula</code> est toujours accompagné d’un argument <code>data</code>. Typiquement, l’utilisateur fournit à <code>data</code> un data frame contenant en colonnes les variables à inclure dans la formule. Utiliser l’argument <code>data</code> permet d’alléger la formule. Les noms de variables dans la formule sont d’abord recherchés parmi les noms des éléments de <code>data</code>.</p>
<pre class="r"><code>reg &lt;- lm(Sepal.Width ~ Sepal.Length, data = iris)  # (plus besoin des iris$ dans la formule)
coef(summary(reg))</code></pre>
<pre><code>##                Estimate Std. Error   t value     Pr(&gt;|t|)
## (Intercept)   3.4189468 0.25356227 13.483658 1.552431e-27
## Sepal.Length -0.0618848 0.04296699 -1.440287 1.518983e-01</code></pre>
<p> </p>
<p>En plus de l’argument <code>data</code>, les fonctions prenant une formule en entrée ont la plupart du temps les arguments :</p>
<ul>
<li><code>subset</code> pour spécifier un sous-ensemble de données à utiliser (par défaut toutes les observations de <code>data</code> sont utilisées) et</li>
<li><code>na.action</code> pour spécifier quoi faire avec les valeurs manquantes (voir <a href="http://stat.ethz.ch/R-manual/R-devel/library/stats/html/na.fail.html"><code>help(na.fail)</code></a>).</li>
</ul>

<p>Voici quelques exemples :</p>
<div id="ajustement-dun-modele-sur-un-sous-ensemble-des-donnees" class="section level5">
<h5>Ajustement d’un modèle sur un sous-ensemble des données :</h5>
<pre class="r"><code>reg &lt;- lm(Sepal.Width ~ Sepal.Length, data = iris, subset = Species == &quot;setosa&quot;)
coef(summary(reg))</code></pre>
<pre><code>##                Estimate Std. Error   t value     Pr(&gt;|t|)
## (Intercept)  -0.5694327  0.5217119 -1.091470 2.805148e-01
## Sepal.Length  0.7985283  0.1039651  7.680738 6.709843e-10</code></pre>
</div>
<div id="modification-du-traitement-des-valeurs-manquantes" class="section level5">
<h5>Modification du traitement des valeurs manquantes :</h5>
<pre class="r"><code>iris2 &lt;- iris
iris2$Sepal.Length[6] &lt;- NA # pour insérer une donnée manquante (pas de NA dans iris)</code></pre>
<pre class="r"><code>reg &lt;- lm(Sepal.Width ~ Sepal.Length, data = iris2, na.action = na.fail)</code></pre>
<pre><code>## Error in na.fail.default(list(Sepal.Width = c(3.5, 3, 3.2, 3.1, 3.6, 3.9,  : 
##   missing values in object</code></pre>
<p>Par défaut, les observations avec au moins une valeur de variable manquante sont omises (ligne complète non considérée), mais la fonction ne génère pas d’erreur.</p>
<pre class="r"><code>reg &lt;- lm(Sepal.Width ~ Sepal.Length, data = iris2, na.action = na.omit)
coef(summary(reg))</code></pre>
<pre><code>##                 Estimate Std. Error   t value     Pr(&gt;|t|)
## (Intercept)   3.39261505 0.25173092 13.477148 1.834315e-27
## Sepal.Length -0.05831666 0.04263339 -1.367863 1.734423e-01</code></pre>
</div>
</div>
<div id="manipulation-de-la-sortie-dune-fonction-dajustement-de-modele" class="section level3">
<h3>Manipulation de la sortie d’une fonction d’ajustement de modèle</h3>
<p>Lorsque nous affichons dans la console un objet produit en sortie d’une fonction d’ajustement de modèle, la sortie obtenue est brève.</p>
<pre class="r"><code>reg &lt;- lm(Sepal.Width ~ Sepal.Length, data = iris)
reg</code></pre>
<pre><code>## 
## Call:
## lm(formula = Sepal.Width ~ Sepal.Length, data = iris)
## 
## Coefficients:
##  (Intercept)  Sepal.Length  
##      3.41895      -0.06188</code></pre>
<p>En réalité, cet objet est une liste contenant plusieurs éléments.</p>
<pre class="r"><code>str(reg, list.len = 5)</code></pre>
<pre><code>## List of 12
##  $ coefficients : Named num [1:2] 3.4189 -0.0619
##   ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;(Intercept)&quot; &quot;Sepal.Length&quot;
##  $ residuals    : Named num [1:150] 0.3967 -0.1157 0.0719 -0.0343 0.4905 ...
##   ..- attr(*, &quot;names&quot;)= chr [1:150] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
##  $ effects      : Named num [1:150] -37.4445 -0.6255 0.0564 -0.0485 0.471 ...
##   ..- attr(*, &quot;names&quot;)= chr [1:150] &quot;(Intercept)&quot; &quot;Sepal.Length&quot; &quot;&quot; &quot;&quot; ...
##  $ rank         : int 2
##  $ fitted.values: Named num [1:150] 3.1 3.12 3.13 3.13 3.11 ...
##   ..- attr(*, &quot;names&quot;)= chr [1:150] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
##   [list output truncated]
##  - attr(*, &quot;class&quot;)= chr &quot;lm&quot;</code></pre>
<p>L’objet obtenu de la fonction d’ajustement de modèle ne s’affiche pas comme une liste parce qu’un attribut classe lui est attribué et que la fonction polymorphe <code>print</code> possède une définition spécifique aux objets de cette classe.</p>
<pre class="r"><code>class(reg)</code></pre>
<pre><code>## [1] &quot;lm&quot;</code></pre>
<pre class="r"><code>print(reg)</code></pre>
<pre><code>## 
## Call:
## lm(formula = Sepal.Width ~ Sepal.Length, data = iris)
## 
## Coefficients:
##  (Intercept)  Sepal.Length  
##      3.41895      -0.06188</code></pre>
<p>C’est une caractéristique orientée objet du langage R. Dans la terminologie de R, une fonction polymorphe est appelée <em>fonction générique</em> et les différentes définitions de cette fonction sont appelées <em>méthodes</em>. Les fonctions génériques, telles que les fonctions <code>print</code> et <code>plot</code>, ont un comportement qui varie en fonction de la classe du premier argument qui leur est fourni en entrée.</p>
<p>Rappelons que taper le nom d’un objet dans la console est en fait un raccourci pour soumettre la fonction <code>print</code> avec l’objet à afficher en argument.</p>
<p>Si nous retirons l’attribut classe de l’objet, nous retombons sur un affichage usuel pour un objet de type liste.</p>
<pre class="r"><code>class(reg) &lt;- NULL
reg # résultat non affiché, car trop long</code></pre>
<p>L’attribut classe peut même contenir plus d’une classe.</p>
<pre class="r"><code>ANOVA &lt;- aov(Sepal.Width ~ Species, data = iris)
class(ANOVA)</code></pre>
<pre><code>## [1] &quot;aov&quot; &quot;lm&quot;</code></pre>
<p>Souvent, le nom de la classe d’un objet est le nom de la fonction qui a produit cet objet. Les objets retournés par la fonction <code>aov</code> ont deux classes, car en réalité la fonction <code>aov</code> appelle la fonction <code>lm</code>.</p>
<div id="fonctions-generiques-dextraction-dinformation-de-la-sortie-dune-fonction-dajustement-de-modele" class="section level4">
<h4>Fonctions génériques d’extraction d’information de la sortie d’une fonction d’ajustement de modèle</h4>
<p>Voici la liste des fonctions génériques les plus couramment utilisées pour tirer de l’information d’un objet produit par une fonction d’ajustement de modèle :</p>
<ul>
<li><code>summary</code> : pour afficher un résumé des informations plus long que ce qui est affiché avec <code>print</code>;</li>
<li><code>coef</code> et <code>confint</code> : pour afficher les coefficients et pour produire des intervalles de confiance pour les coefficients d’un modèle;</li>
<li><code>residuals</code> et <code>fitted</code> : pour extraire les résidus et les valeurs prédites;</li>
<li><code>predict</code> : prédiction pour une nouvelle observation;</li>
<li><code>anova</code> : pour calculer la table d’analyse de la variance (ANOVA) du modèle;</li>
<li><code>model.tables</code> et <code>TukeyHSD</code> (pour la classe <code>aov</code>) : pour calculer les moyennes par niveaux de facteurs et pour faire des comparaisons multiples de Tukey sur ces moyennes;</li>
<li><code>deviance</code>, <code>logLik</code>, <code>AIC</code>, <code>BIC</code> : pour extraire la déviance, la log-vraisemblance maximisée, le AIC et le BIC.</li>
</ul>
<p>L’utilisation de ces fonctions est la façon usuelle en R d’extraire des résultats relatifs à un modèle. Par exemple, pour extraire les coefficients d’un modèle, nous pouvons utiliser :</p>
<pre class="r"><code>reg &lt;- lm(Sepal.Width ~ Sepal.Length, data = iris)
coef(reg)</code></pre>
<pre><code>##  (Intercept) Sepal.Length 
##    3.4189468   -0.0618848</code></pre>
<p>Notons cependant qu’il est aussi possible d’extraire cette information en accédant directement aux éléments de <code>reg</code>, qui est une liste.</p>
<pre class="r"><code>reg$coefficients</code></pre>
<pre><code>##  (Intercept) Sepal.Length 
##    3.4189468   -0.0618848</code></pre>
<p> </p>
<p>Voici quelques exemples d’utilisation des fonctions d’extraction d’information :</p>
<pre class="r"><code>reg &lt;- lm(Sepal.Width ~ Sepal.Length + Petal.Width, data = iris)
summary(reg)</code></pre>
<pre><code>## 
## Call:
## lm(formula = Sepal.Width ~ Sepal.Length + Petal.Width, data = iris)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -0.99563 -0.24690 -0.00503  0.23354  1.01131 
## 
## Coefficients:
##              Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)   1.92632    0.32094   6.002 1.45e-08 ***
## Sepal.Length  0.28929    0.06605   4.380 2.24e-05 ***
## Petal.Width  -0.46641    0.07175  -6.501 1.17e-09 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.3841 on 147 degrees of freedom
## Multiple R-squared:  0.234,  Adjusted R-squared:  0.2236 
## F-statistic: 22.46 on 2 and 147 DF,  p-value: 3.091e-09</code></pre>
<pre class="r"><code>confint(reg)</code></pre>
<pre><code>##                   2.5 %     97.5 %
## (Intercept)   1.2920761  2.5605655
## Sepal.Length  0.1587655  0.4198079
## Petal.Width  -0.6082076 -0.3246210</code></pre>
<pre class="r"><code>str(residuals(reg))</code></pre>
<pre><code>##  Named num [1:150] 0.1916 -0.25054 0.00731 -0.06376 0.32053 ...
##  - attr(*, &quot;names&quot;)= chr [1:150] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...</code></pre>
<pre class="r"><code>predict(reg, newdata = data.frame(Sepal.Length = c(5, 6), 
                                  Petal.Width = c(1, 2)))</code></pre>
<pre><code>##        1        2 
## 2.906340 2.729213</code></pre>
<pre class="r"><code>ANOVA &lt;- aov(Sepal.Width ~ Species + Sepal.Length_catego, data = iris)
summary(ANOVA)</code></pre>
<pre><code>##                      Df Sum Sq Mean Sq F value   Pr(&gt;F)    
## Species               2 11.345   5.672   62.70  &lt; 2e-16 ***
## Sepal.Length_catego   2  3.843   1.922   21.24 8.13e-09 ***
## Residuals           145 13.119   0.090                     
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<pre class="r"><code>anova(ANOVA)</code></pre>
<pre><code>## Analysis of Variance Table
## 
## Response: Sepal.Width
##                      Df  Sum Sq Mean Sq F value    Pr(&gt;F)    
## Species               2 11.3449  5.6725  62.697 &lt; 2.2e-16 ***
## Sepal.Length_catego   2  3.8433  1.9216  21.240 8.129e-09 ***
## Residuals           145 13.1187  0.0905                      
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<pre class="r"><code>model.tables(ANOVA, type = &quot;means&quot;)</code></pre>
<pre><code>## Tables of means
## Grand mean
##          
## 3.057333 
## 
##  Species 
##     setosa versicolor virginica
##      3.428       2.77     2.974
## rep 50.000      50.00    50.000
## 
##  Sepal.Length_catego 
##     [-Inf,5.4) [5.4,6.3) [6.3, Inf)
##          2.919     3.081      3.157
## rep     46.000    53.000     51.000</code></pre>
<pre class="r"><code>TukeyHSD(ANOVA)</code></pre>
<pre><code>##   Tukey multiple comparisons of means
##     95% family-wise confidence level
## 
## Fit: aov(formula = Sepal.Width ~ Species + Sepal.Length_catego, data = iris)
## 
## $Species
##                        diff         lwr        upr     p adj
## versicolor-setosa    -0.658 -0.80045516 -0.5155448 0.0000000
## virginica-setosa     -0.454 -0.59645516 -0.3115448 0.0000000
## virginica-versicolor  0.204  0.06154484  0.3464552 0.0025694
## 
## $Sepal.Length_catego
##                             diff         lwr       upr     p adj
## [5.4,6.3)-[-Inf,5.4)  0.16172436  0.01819230 0.3052564 0.0229762
## [6.3, Inf)-[-Inf,5.4) 0.23756010  0.09272626 0.3823939 0.0004549
## [6.3, Inf)-[5.4,6.3)  0.07583574 -0.06387887 0.2155503 0.4057167</code></pre>
</div>
</div>
<div id="resultats-additionnels-fournis-par-summary" class="section level3">
<h3>Résultats additionnels fournis par <code>summary</code></h3>
<p>La fonction générique <code>summary</code> ne fait pas que produire un affichage plus complet du modèle ajusté que la fonction générique <code>print</code>. Elle produit des résultats supplémentaires concernant le modèle. Par exemple, pour un modèle produit avec <code>lm</code>, comparons ce que produit directement la fonction <code>lm</code> et ce que produit la fonction générique <code>summary</code> pour un objet retourné par <code>lm</code>.</p>
<pre class="r"><code>reg &lt;- lm(Sepal.Width ~ Sepal.Length, data = iris)
reg_summary &lt;- summary(reg)
sort(names(reg))</code></pre>
<pre><code>##  [1] &quot;assign&quot;        &quot;call&quot;          &quot;coefficients&quot;  &quot;df.residual&quot;  
##  [5] &quot;effects&quot;       &quot;fitted.values&quot; &quot;model&quot;         &quot;qr&quot;           
##  [9] &quot;rank&quot;          &quot;residuals&quot;     &quot;terms&quot;         &quot;xlevels&quot;</code></pre>
<pre class="r"><code>sort(names(reg_summary))</code></pre>
<pre><code>##  [1] &quot;adj.r.squared&quot; &quot;aliased&quot;       &quot;call&quot;          &quot;coefficients&quot; 
##  [5] &quot;cov.unscaled&quot;  &quot;df&quot;            &quot;fstatistic&quot;    &quot;r.squared&quot;    
##  [9] &quot;residuals&quot;     &quot;sigma&quot;         &quot;terms&quot;</code></pre>
<p>Seulement 4 éléments de la liste <code>reg</code> portent des noms aussi présents dans la liste <code>reg_summary</code>. Et des éléments de même nom dans les deux listes ne contiennent pas toujours la même chose.</p>
<pre class="r"><code>reg$coefficients</code></pre>
<pre><code>##  (Intercept) Sepal.Length 
##    3.4189468   -0.0618848</code></pre>
<pre class="r"><code>reg_summary$coefficients</code></pre>
<pre><code>##                Estimate Std. Error   t value     Pr(&gt;|t|)
## (Intercept)   3.4189468 0.25356227 13.483658 1.552431e-27
## Sepal.Length -0.0618848 0.04296699 -1.440287 1.518983e-01</code></pre>
<p>Les éléments produits par <code>summary</code> tendent à contenir plus de détails que les éléments obtenus directement de <code>lm</code>.</p>
<p>La fonction <code>summary</code> réalise donc des calculs supplémentaires relatifs au modèle. Par exemple, pour un modèle ajusté avec <code>lm</code>, elle réalise les tests sur les termes du modèle et calcule le coefficient de détermination (R<sup>2</sup>), soit une mesure souvent utilisée pour évaluer la qualité de la prédiction du modèle.</p>
<pre class="r"><code>reg_summary$r.squared</code></pre>
<pre><code>## [1] 0.01382265</code></pre>
<p>Pour un modèle d’analyse de la variance ajusté avec <code>aov</code>, la fonction <code>summary</code> produit la table d’ANOVA complète, tout comme la fonction <code>anova</code> le fait.</p>
<pre class="r"><code>ANOVA &lt;- aov(Sepal.Width ~ Species + Sepal.Length_catego, data = iris)
ANOVA_summary &lt;- summary(ANOVA)
str(ANOVA_summary)</code></pre>
<pre><code>## List of 1
##  $ :Classes &#39;anova&#39; and &#39;data.frame&#39;:    3 obs. of  5 variables:
##   ..$ Df     : num [1:3] 2 2 145
##   ..$ Sum Sq : num [1:3] 11.34 3.84 13.12
##   ..$ Mean Sq: num [1:3] 5.6725 1.9216 0.0905
##   ..$ F value: num [1:3] 62.7 21.2 NA
##   ..$ Pr(&gt;F) : num [1:3] 2.40e-20 8.13e-09 NA
##  - attr(*, &quot;class&quot;)= chr [1:2] &quot;summary.aov&quot; &quot;listof&quot;</code></pre>
</div>
<div id="mise-en-forme-de-la-sortie-dune-fonction-dajustement-de-modele-avec-le-package-broom" class="section level3">
<h3>Mise en forme de la sortie d’une fonction d’ajustement de modèle avec le package <code>broom</code></h3>
<p>Le <a href="https://cran.r-project.org/web/packages/broom/index.html">package <code>broom</code></a> offre des fonctions pour faciliter la manipulation de sorties d’une fonction d’ajustement de modèle. Les trois principales fonctions de ce package sont les suivantes :</p>
<ul>
<li><code>tidy</code> : produit un résumé des principaux résultats statistiques d’un modèle, dans le cas d’un modèle linéaire il s’agit d’une table des tests sur les coefficients du modèle;</li>
<li><code>augment</code> : ajoute aux données sur lesquelles le modèle a été ajusté des informations tirées du modèle, comme des résidus et des valeurs prédites;</li>
<li><code>glance</code> : réunit dans un seul data frame à une ligne plusieurs statistiques globales au modèle, comme des statistiques d’ajustement du modèle.</li>
</ul>
<p>Voici quelques exemples :</p>
<pre class="r"><code>reg &lt;- lm(Sepal.Width ~ Sepal.Length, data = iris)</code></pre>
<pre class="r"><code>library(broom)
tidy(reg) # très similaire à coef(summary(reg)) pour une sortie de lm</code></pre>
<pre><code>##           term   estimate  std.error statistic      p.value
## 1  (Intercept)  3.4189468 0.25356227 13.483658 1.552431e-27
## 2 Sepal.Length -0.0618848 0.04296699 -1.440287 1.518983e-01</code></pre>
<pre class="r"><code>head(augment(reg))</code></pre>
<pre><code>##   Sepal.Width Sepal.Length  .fitted    .se.fit      .resid        .hat    .sigma
## 1         3.5          5.1 3.103334 0.04772367  0.39666563 0.012074844 0.4345331
## 2         3.0          4.9 3.115711 0.05385462 -0.11571133 0.015376584 0.4356718
## 3         3.2          4.7 3.128088 0.06058701  0.07191171 0.019461346 0.4357368
## 4         3.1          4.6 3.134277 0.06412022 -0.03427677 0.021797361 0.4357686
## 5         3.6          5.0 3.109523 0.05069983  0.49047715 0.013627836 0.4338701
## 6         3.9          5.4 3.084769 0.04025314  0.81523107 0.008590398 0.4305138
##        .cooksd  .std.resid
## 1 5.160199e-03  0.91890262
## 2 5.629310e-04 -0.26850212
## 3 2.774768e-04  0.16721461
## 4 7.094631e-05 -0.07979806
## 5 8.932371e-03  1.13711743
## 6 1.539758e-02  1.88521593</code></pre>
<pre class="r"><code>glance(reg)</code></pre>
<pre><code>##    r.squared adj.r.squared     sigma statistic   p.value df    logLik      AIC
## 1 0.01382265   0.007159294 0.4343032  2.074427 0.1518983  2 -86.73221 179.4644
##        BIC deviance df.residual
## 1 188.4963 27.91566         148</code></pre>
<p>Plus d’informations peuvent être trouvées dans les vignettes du package : <a href="https://cran.r-project.org/web/packages/broom/vignettes/broom.html" class="uri">https://cran.r-project.org/web/packages/broom/vignettes/broom.html</a>.</p>
</div>
</div>
<div id="references-autres-methodes-statistiques" class="section level2">
<h2>Références autres méthodes statistiques</h2>
<p>Une très grande quantité de méthodes statistiques sont implantées en R. Je ne vais pas les énumérer ici, mais voici quelques bonnes références sur le sujet.</p>
<ul>
<li>Livre présentant comment utiliser les principales techniques statistiques en R :<br />
Hothorn, T. et Everitt, B.S. (2014). <em>A handbook of statistical analyses using R</em>, third edition. CRC Press.</li>
<li>Site web contenant plusieurs exemples d’analyses statistiques en R :<br />
<a href="https://stats.idre.ucla.edu/other/dae/" class="uri">https://stats.idre.ucla.edu/other/dae/</a></li>
<li>Ressources pour dénicher des packages R implémentant des méthodes statistiques particulières :
<ul>
<li>Task views de R : <a href="http://cran.r-project.org/web/views/" class="uri">http://cran.r-project.org/web/views/</a></li>
<li>Dépôt informatique de packages R en bio-informatique : <a href="http://www.bioconductor.org/" class="uri">http://www.bioconductor.org/</a></li>
</ul></li>
</ul>
<hr />
</div>
</div>
<div id="calculs-mathematiques" class="section level1">
<h1>Calculs mathématiques</h1>
<div id="operateurs-et-fonctions-de-base" class="section level2">
<h2>Opérateurs et fonctions de base</h2>
<p>Les opérateurs et fonctions mathématiques de base ont été vus dans les notes intitulées <a href="https://stt4230.rbind.io/calculs/calculs_base_r/#fonctions-et-operateurs-pour-des-calculs-mathematiques">Calculs de base en R</a>.</p>
</div>
<div id="calcul-de-distances" class="section level2">
<h2>Calcul de distances</h2>
<p>Pour calculer des distances entre des observations numériques, la package <code>stats</code> offre la fonction <code>dist</code>. Par exemple, reprenons l’échantillon aléatoire de 5 observations du jeu de données <code>iris</code> que nous avons tiré plus tôt et conservons uniquement les variables numériques.</p>
<pre class="r"><code>iris_ech_num &lt;- iris_ech[, c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;, &quot;Petal.Length&quot;, &quot;Petal.Width&quot;)]
iris_ech_num</code></pre>
<pre><code>##    Sepal.Length Sepal.Width Petal.Length Petal.Width
## 97          5.7         2.9          4.2         1.3
## 28          5.2         3.5          1.5         0.2
## 50          5.0         3.3          1.4         0.2
## 29          5.2         3.4          1.4         0.2
## 33          5.2         4.1          1.5         0.1</code></pre>
<p>Calculons la distance euclidienne entre ces observations, basée sur les 4 variables numériques.</p>
<pre class="r"><code>dist(iris_ech_num, method = &quot;euclidean&quot;, diag = TRUE)</code></pre>
<pre><code>##           97        28        50        29        33
## 97 0.0000000                                        
## 28 3.0182777 0.0000000                              
## 50 3.1144823 0.3000000 0.0000000                    
## 29 3.0903074 0.1414214 0.2236068 0.0000000          
## 33 3.2280025 0.6082763 0.8366600 0.7141428 0.0000000</code></pre>
<p>La distance euclidienne est un cas particulier de la <a href="https://fr.wikipedia.org/wiki/Distance_(math%C3%A9matiques)#Exemples_de_distances_classiques">distance de Minkowski</a>, avec un paramètre <span class="math inline">\(p = 2\)</span>.</p>
<pre class="r"><code>dist(iris_ech_num, method = &quot;minkowski&quot;, p = 2, diag = TRUE)</code></pre>
<pre><code>##           97        28        50        29        33
## 97 0.0000000                                        
## 28 3.0182777 0.0000000                              
## 50 3.1144823 0.3000000 0.0000000                    
## 29 3.0903074 0.1414214 0.2236068 0.0000000          
## 33 3.2280025 0.6082763 0.8366600 0.7141428 0.0000000</code></pre>
<p>La fonction <code>dist</code> propose quelques autres distances pour variables numériques (voir la <a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/dist.html">fiche d’aide de la fonction</a> pour la liste complète). Le package <code>stats</code> offre aussi la fonction <code>mahalanobis</code> pour calculer des <a href="https://fr.wikipedia.org/wiki/Distance_de_Mahalanobis">distance de Mahalanobis</a>. Pour faire le tour des fonctions de mesure de distances incluses dans l’installation R de base, mentionnons aussi la fonction <code>adist</code> du package <code>utils</code> qui calcule la <a href="https://fr.wikipedia.org/wiki/Distance_de_Levenshtein">distance de Levenshtein</a> entre des chaînes de caractères, par exemple :</p>
<pre class="r"><code>adist(&quot;Allo&quot;, &quot;Hello&quot;)</code></pre>
<pre><code>##      [,1]
## [1,]    2</code></pre>
<p>La distance de Levenshtein, aussi appelée distance minimale d’édition, compte le nombre minimal d’insertions, de retraits et de substitutions à effectuer pour transformer la première chaîne de caractères en la deuxième. Il est possible d’associer un coût différent à chacune de ces opérations. Par défaut, elles ont toutes un coût de 1. La distance de Levenshtein entre <code>&quot;Allo&quot;</code> et <code>&quot;Hello&quot;</code> vaut 2 parce que pour transformer <code>&quot;Allo&quot;</code> en <code>&quot;Hello&quot;</code> il faut au minimum faire les deux opérations suivantes :</p>
<ul>
<li>ajouter une lettre (par exemple un <code>H</code> au début);</li>
<li>transformer une lettre (par exemple transformer le <code>&quot;A&quot;</code> en <code>&quot;e&quot;</code>).</li>
</ul>
</div>
<div id="algebre-lineaire" class="section level2">
<h2>Algèbre linéaire</h2>
<p>Il existe plusieurs fonctions en R pour faire de l’algèbre linéaire.</p>
<ul>
<li>multiplication matricielle : <code>%*%</code>;</li>
<li>transposition : <code>t</code>;</li>
<li>inverse : <code>solve</code> (en fait <code>solve</code> résout <code>A %*% x = B</code>, mais par défaut <code>B</code> est la matrice identité);</li>
<li>produit vectoriel (en anglais <em>cross product</em>) de matrices : <code>crossprod</code>;</li>
<li>produit dyadique généralisé (en anglais <em>outer product</em>) : <code>outer</code>, <code>%o%</code>;</li>
<li>produit de Kronecker généralisé : <code>kronecker</code>, <code>%x%</code>;</li>
<li>matrices diagonales : <code>diag</code>;</li>
<li>déterminant : <code>det</code>;</li>
<li>valeurs et vecteur propres : <code>eigen</code>;</li>
<li>décompositions : <code>svd</code>, <code>qr</code>, <code>chol</code>.</li>
</ul>
<p>Faisons quelques exemples pour illustrer certaines de ces fonctions.</p>
<div id="operateur" class="section level5">
<h5>Opérateur <code>%*%</code></h5>
<p>L’opérateur usuel de multiplication effectue une multiplication terme à terme entre deux matrices.</p>
<pre class="r"><code>A &lt;- matrix(1:6, 3, 2)
A</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6</code></pre>
<pre class="r"><code>B &lt;- matrix(6:1, 3, 2)
B</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    6    3
## [2,]    5    2
## [3,]    4    1</code></pre>
<pre class="r"><code>A*B</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    6   12
## [2,]   10   10
## [3,]   12    6</code></pre>
<p>Pour effectuer une multiplication matricielle, il faut utiliser l’opérateur <code>%*%</code>. Les dimensions des matrices doivent évidemment concorder.</p>
<pre class="r"><code>A%*%B</code></pre>
<pre><code>## Error in A %*% B: non-conformable arguments</code></pre>
<pre class="r"><code>C &lt;- matrix(c(5,2,3,7), 2, 2)
C</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    5    3
## [2,]    2    7</code></pre>
<pre class="r"><code>A%*%C</code></pre>
<pre><code>##      [,1] [,2]
## [1,]   13   31
## [2,]   20   41
## [3,]   27   51</code></pre>
</div>
<div id="fonction-solve" class="section level5">
<h5>Fonction <code>solve</code></h5>
<p>L’inverse d’une matrice s’obtient avec la fonction <code>solve</code>.</p>
<pre class="r"><code>solve(C)</code></pre>
<pre><code>##             [,1]       [,2]
## [1,]  0.24137931 -0.1034483
## [2,] -0.06896552  0.1724138</code></pre>
</div>
<div id="fonction-crossprod" class="section level5">
<h5>Fonction <code>crossprod</code></h5>
<p>La fonction <code>crossprod</code> sert à calculer <span class="math inline">\(A^T B\)</span> ou <span class="math inline">\(A^T A\)</span>.</p>
<pre class="r"><code>crossprod(A,B)</code></pre>
<pre><code>##      [,1] [,2]
## [1,]   28   10
## [2,]   73   28</code></pre>
<pre class="r"><code># équivalent à
t(A)%*%B</code></pre>
<pre><code>##      [,1] [,2]
## [1,]   28   10
## [2,]   73   28</code></pre>
</div>
<div id="produits-dyadique-et-de-kronecker" class="section level5">
<h5>Produits dyadique et de Kronecker</h5>
<p>Parfois, nous avons besoin d’effectuer une opération en prenant toutes les paires de termes possibles entre deux vecteurs ou matrices. C’est ce que font les produits dyadique (<em>outer product</em>) (opérateur <code>%o%</code>) et de Kronecker (opérateur <code>%x%</code>). Cependant, ils n’assemblent pas les résultats de la même façon. Voici des exemples avec des vecteurs.</p>
<pre class="r"><code>1:3 %o% 4:5</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    4    5
## [2,]    8   10
## [3,]   12   15</code></pre>
<pre class="r"><code>1:3 %x% 4:5</code></pre>
<pre><code>## [1]  4  5  8 10 12 15</code></pre>
<p>Les deux commandes ont permis le calcul des mêmes 6 produits (<span class="math inline">\(1 \times 4 = 4\)</span>, <span class="math inline">\(2 \times 4 = 8\)</span>, <span class="math inline">\(3 \times 4 = 12\)</span>, <span class="math inline">\(1 \times 5 = 5\)</span>, <span class="math inline">\(2 \times 5 = 10\)</span> et <span class="math inline">\(3 \times 5 = 15\)</span>). Cependant, l’opérateur <code>%o%</code> a rassemblé les produits dans une matrice de dimension 3 par 2, et l’opérateur <code>%x%</code> dans un vecteur de longueur <span class="math inline">\(3 \times 2 = 6\)</span>.</p>
<p>Avec des matrices, le résultat de <code>A %o% B</code> est de dimension <code>c(dim(A), dim(B))</code>, alors que le résultat de <code>A %x% B</code> est de dimension <code>nrow(A)*nrow(B)</code> par <code>ncol(A)*ncol(B)</code>. Voici des exemples.</p>
<pre class="r"><code>A &lt;- matrix(12:1, nrow = 3, ncol = 4)
A</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]   12    9    6    3
## [2,]   11    8    5    2
## [3,]   10    7    4    1</code></pre>
<pre class="r"><code>B &lt;- matrix(c(1,2), 2, 1)
B</code></pre>
<pre><code>##      [,1]
## [1,]    1
## [2,]    2</code></pre>
<pre class="r"><code>A %o% B</code></pre>
<pre><code>## , , 1, 1
## 
##      [,1] [,2] [,3] [,4]
## [1,]   12    9    6    3
## [2,]   11    8    5    2
## [3,]   10    7    4    1
## 
## , , 2, 1
## 
##      [,1] [,2] [,3] [,4]
## [1,]   24   18   12    6
## [2,]   22   16   10    4
## [3,]   20   14    8    2</code></pre>
<pre class="r"><code>A %x% B</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]   12    9    6    3
## [2,]   24   18   12    6
## [3,]   11    8    5    2
## [4,]   22   16   10    4
## [5,]   10    7    4    1
## [6,]   20   14    8    2</code></pre>
<p>Les deux opérations se généralisent à l’emploi d’un autre opérateur que le produit.</p>
<pre class="r"><code>outer(1:3, 4:5, &#39;+&#39;)</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    5    6
## [2,]    6    7
## [3,]    7    8</code></pre>
<pre class="r"><code>kronecker(1:3, 4:5, &#39;+&#39;)</code></pre>
<pre><code>## [1] 5 6 6 7 7 8</code></pre>
</div>
<div id="fonction-diag" class="section level5">
<h5>Fonction <code>diag</code></h5>
<p>Finalement, la fonction <code>diag</code> a plusieurs utilités. Elle permet :</p>
<ul>
<li>d’extraire la diagonale d’une matrice (en lui donnant en entrée une matrice),</li>
</ul>
<pre class="r"><code>C</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    5    3
## [2,]    2    7</code></pre>
<pre class="r"><code>diag(C)</code></pre>
<pre><code>## [1] 5 7</code></pre>
<ul>
<li>de créer une matrice diagonale (en lui donnant en entrée un vecteur),</li>
</ul>
<pre class="r"><code>diag(1:3)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    2    0
## [3,]    0    0    3</code></pre>
<ul>
<li>de créer une matrice identité (en lui donnant en entrée un seul nombre).</li>
</ul>
<pre class="r"><code>diag(3)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    0    0
## [2,]    0    1    0
## [3,]    0    0    1</code></pre>

</div>
</div>
<div id="calcul-differentiel-et-integral" class="section level2">
<h2>Calcul différentiel et intégral</h2>
<p>Ce qui est offert pour calculer des dérivées et des intégrales en R n’est pas très performant ni facile d’utilisation.</p>
<div id="calculs-symboliques-derivation-avec-d-deriv-et-deriv3" class="section level4">
<h4>Calculs symboliques : dérivation avec <code>D</code>, <code>deriv</code> et <code>deriv3</code></h4>
<p>Tout comme les logiciels Maple ou Mathematica, R peut faire du calcul symbolique de dérivées. Cependant, il est loin d’être le meilleur outil pour ces tâches. Pour illustrer les capacités (limitées) de R dans ce domaine, tentons d’abord de calculer la dérivée suivante : <span class="math display">\[\frac{d}{dx}( log(x) + sin(x) ).\]</span></p>
<pre class="r"><code>df &lt;- deriv(~ log(x) + sin(x), &quot;x&quot;)
df</code></pre>
<pre><code>## expression({
##     .value &lt;- log(x) + sin(x)
##     .grad &lt;- array(0, c(length(.value), 1L), list(NULL, c(&quot;x&quot;)))
##     .grad[, &quot;x&quot;] &lt;- 1/x + cos(x)
##     attr(.value, &quot;gradient&quot;) &lt;- .grad
##     .value
## })</code></pre>
<p>L’objet <code>df</code> est particulier. Il s’agit d’une expression. La ligne <code>.grad[, &quot;x&quot;] &lt;- 1/x + cos(x)</code> permet de constater que R a bien trouvé que la dérivée symbolique de <span class="math inline">\(log(x) + sin(x)\)</span> est <span class="math inline">\(1/x + cos(x)\)</span>. Nous pouvons maintenant utiliser <code>df</code> pour calculer cette dérivée en certains points. Étant donné que nous avons nommé <code>x</code> la variable dans la fonction à dériver, il faut d’abord créer un objet nommé <code>x</code> contenant les valeurs en lesquelles nous souhaitons calculer la dérivée.</p>
<pre class="r"><code>x &lt;- 2:5</code></pre>
<p>Ensuite, nous soumettons la commande suivante pour obtenir le résultat recherché.</p>
<pre class="r"><code>eval(df)</code></pre>
<pre><code>## [1] 1.6024446 1.2397323 0.6294919 0.6505136
## attr(,&quot;gradient&quot;)
##                x
## [1,]  0.08385316
## [2,] -0.65665916
## [3,] -0.40364362
## [4,]  0.48366219</code></pre>
<p>Cette sortie contient les valeurs de la fonction d’origine aux points d’intérêt,</p>
<pre class="r"><code>log(x) + sin(x)</code></pre>
<pre><code>## [1] 1.6024446 1.2397323 0.6294919 0.6505136</code></pre>
<p>suivies des valeurs de la dérivée de la fonction en ces points.</p>
<pre class="r"><code>1/x + cos(x)</code></pre>
<pre><code>## [1]  0.08385316 -0.65665916 -0.40364362  0.48366219</code></pre>
<p>Ainsi, R peut faire du calcul symbolique de dérivée, mais il n’offre pas une façon très conviviale de le faire. Plus d’information peut être trouvée dans la fiche d’aide des fonctions <code>D</code>, <code>deriv</code> et <code>deriv3</code>. Le R de base n’offre pas de fonctions pour le calcul symbolique d’intégrales. Cependant, le package <code>Ryacas</code> en offre : <a href="https://CRAN.R-project.org/package=Ryacas" class="uri">https://CRAN.R-project.org/package=Ryacas</a></p>
</div>
<div id="calculs-numeriques-derivation-avec-numericderiv" class="section level4">
<h4>Calculs numériques : dérivation avec <code>numericDeriv</code></h4>
<p>Le calcul de dérivées numériques est un peu plus simple. Par exemple, dérivons la fonction de répartition d’une loi normale standard en quelques points avec la fonction <code>numericDeriv</code></p>
<pre class="r"><code># Points en lesquels nous allons dériver
x &lt;- as.double(-3:3)
# Valeur de la fonction en ces points
pnorm(x)</code></pre>
<pre><code>## [1] 0.001349898 0.022750132 0.158655254 0.500000000 0.841344746 0.977249868 0.998650102</code></pre>
<pre class="r"><code># Calcul de la dérivée en ces points
numericDeriv(quote(pnorm(x)), &quot;x&quot;)</code></pre>
<pre><code>## [1] 0.001349898 0.022750132 0.158655254 0.500000000 0.841344746 0.977249868 0.998650102
## attr(,&quot;gradient&quot;)
##             [,1]       [,2]      [,3]      [,4]      [,5]       [,6]        [,7]
## [1,] 0.004431849 0.00000000 0.0000000 0.0000000 0.0000000 0.00000000 0.000000000
## [2,] 0.000000000 0.05399097 0.0000000 0.0000000 0.0000000 0.00000000 0.000000000
## [3,] 0.000000000 0.00000000 0.2419707 0.0000000 0.0000000 0.00000000 0.000000000
## [4,] 0.000000000 0.00000000 0.0000000 0.3989423 0.0000000 0.00000000 0.000000000
## [5,] 0.000000000 0.00000000 0.0000000 0.0000000 0.2419707 0.00000000 0.000000000
## [6,] 0.000000000 0.00000000 0.0000000 0.0000000 0.0000000 0.05399096 0.000000000
## [7,] 0.000000000 0.00000000 0.0000000 0.0000000 0.0000000 0.00000000 0.004431849</code></pre>
<p>Nous arrivons au bon résultat, soit la fonction de densité de loi normale standard aux mêmes points.</p>
<pre class="r"><code>dnorm(x)</code></pre>
<pre><code>## [1] 0.004431848 0.053990967 0.241970725 0.398942280 0.241970725 0.053990967 0.004431848</code></pre>
<p>L’appel de la fonction <code>numericDeriv</code> n’est pas standard. Il fait intervenir une expression R à créer avec la fonction <code>quote</code>.</p>
<p>Nous pourrions aussi programmer à la main une version simpliste de la <a href="https://en.wikipedia.org/wiki/Numerical_differentiation">dérivation numérique</a> comme suit :</p>
<pre class="r"><code>delta &lt;- .000001
(pnorm(x+delta) - pnorm(x-delta))/(2*delta)</code></pre>
<pre><code>## [1] 0.004431848 0.053990967 0.241970724 0.398942280 0.241970725 0.053990967 0.004431848</code></pre>
</div>
<div id="calculs-numeriques-integration-avec-integrate" class="section level4">
<h4>Calculs numériques : intégration avec <code>integrate</code></h4>
<p>Effectuons maintenant l’opération inverse : intégrons la fonction de densité de la loi normale standard.</p>
<pre class="r"><code>integrate(dnorm, -Inf, 1)</code></pre>
<pre><code>## 0.8413448 with absolute error &lt; 1.5e-05</code></pre>
<p>Nous arrivons au bon résultat, soit la fonction de répartition de loi normale standard au point 1</p>
<pre class="r"><code>pnorm(1)</code></pre>
<pre><code>## [1] 0.8413447</code></pre>
<p>Remarque : La fonction <code>integrate</code> ne travaille pas de façon vectorielle. Elle ne peut pas calculer des intégrales numériques pour plusieurs intervalles en un seul appel de la fonction.</p>
</div>
</div>
<div id="optimisation-numerique" class="section level2">
<h2>Optimisation numérique</h2>
<p>En mathématiques, l’optimisation consiste à trouver en quel(s) point(s) une fonction mathématique atteint sa valeur maximale ou minimale. En statistique, on parle souvent de ce problème en ces termes : trouver les valeurs des paramètres pour lesquels une fonction atteint son maximum ou son minimum.</p>
<p>Parfois, il est possible de trouver une solution algébrique à ce problème à l’aide du calcul différentiel et intégral. Par contre, il arrive qu’il soit trop difficile, voire impossible, de dériver la fonction en question. L’optimisation numérique est une bonne solution dans un tel cas.</p>
<p>Fonctions R utiles en optimisation numérique :</p>
<ul>
<li>pour optimiser une fonction à une variable : <code>optimize</code>,</li>
<li>pour optimiser une fonction avec un nombre de variables quelconque : <code>nlm</code>, <code>optim</code>,</li>
<li>optimisation sous contrainte : <code>constrOptim</code>.</li>
</ul>
<p>Exemple d’optimisation d’une fonction à une variable en R : trouvons en quel point la fonction de densité de la loi normale atteint son maximum. La théorie nous dit que ce maximum est atteint en la valeur de l’espérance de la loi. Voyons si l’optimisation numérique saura retourner le bon résultat.</p>
<pre class="r"><code>curve(dnorm(x, mean = 3), from = -3, to = 10, 
      ylab = &quot;densité N(3,1)&quot;, main = &quot;Maximum de la densité normale&quot;)
abline(v = 3, lty = 2, col = &quot;blue&quot;)
optimize(dnorm, interval = c(-3, 10), mean = 3, maximum = TRUE)</code></pre>
<pre><code>## $maximum
## [1] 3
## 
## $objective
## [1] 0.3989423</code></pre>
<p><img src="/calculs/calculs_stat_math_r_2018_files/figure-html/unnamed-chunk-95-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Oui, pour une loi normale d’espérance 3 et de variance 1, nous arrivons bien numériquement au résultat que le maximum de la densité est atteint en la valeur 3. La fonction <code>optimize</code> nous dit aussi que ce maximum vaut :</p>
<pre class="r"><code>dnorm(x = 3, mean = 3)</code></pre>
<pre><code>## [1] 0.3989423</code></pre>
<p>Les fonctions <code>nlm</code>, <code>optim</code> et <code>constrOptim</code> utilisent des <strong>algorithmes itératifs</strong>. Elles ont besoin de valeurs initiales pour les paramètres (argument <code>par</code> à fournir obligatoirement). À chaque itération de l’algorithme, elles modifient ces valeurs en tentant de se diriger vers l’optimum de la fonction. Elles peuvent :</p>
<ul>
<li>ne pas converger,</li>
<li>converger au mauvais endroit (optimum local plutôt que global).</li>
</ul>
<p>Il faut être prudent lors de leur utilisation. Par exemple, <code>optim</code> est <strong>sensible au choix de plusieurs arguments</strong>, notamment :</p>
<ul>
<li>l’algorithme employé,</li>
<li>les valeurs initiales données aux paramètres.</li>
</ul>
<p>Ces fonctions sont tout de même très utiles pour effectuer une optimisation lorsque celle-ci est difficile ou impossible à réaliser algébriquement.</p>
<p>Voici un exemple d’optimisation d’une fonction à plusieurs variables. La fonction <code>lm</code> minimise le critère des moindres carrés, en implémentant des formules algébriques. Les estimations des paramètres du modèle linéaire que <code>lm</code> retourne sont les points en lesquelles la fonction des moindres carrés est minimisée. Tentons de minimiser cette fonction de façon numérique. Pour ce faire, nous avons d’abord besoin d’une fonction qui calcule le critère des moindres carrés et qui prend comme premier argument les paramètres du modèle. Nous n’avons pas encore vu dans le cours comment créer des fonctions, mais je me permets tout de même ici d’en créer une, pour illustrer l’optimisation numérique. La syntaxe pour créer des fonctions R sera vue au prochain cours.</p>
<p>Le <a href="https://en.wikipedia.org/wiki/Least_squares">critère des moindres carrés</a> est calculé en sommant les différences au carré entre les valeurs observées d’une variable et les valeurs prédites par le modèle. Pour un modèle de régression linéaire, la fonction suivante calcule de façon matricielle la valeur du critère.</p>
<pre class="r"><code>moindresCarres &lt;- function(beta, y, X) {
  as.vector(crossprod(y - X %*% matrix(beta, ncol = 1)))
}</code></pre>
<p>Le vecteur <code>y</code> doit contenir les valeurs observées de la variable réponse et la matrice <code>X</code> est la <a href="https://en.wikipedia.org/wiki/Design_matrix">matrice de design du modèle</a>. Cette dernière contient les observations des variables explicatives pour les termes présents dans le modèle. Le vecteur <code>y</code> et la matrice <code>X</code> sont des composantes du modèle supposées connues ici. C’est le vecteur de paramètre <code>beta</code> que nous cherchons à estimer. Nous allons utiliser les données du jeu de données <code>cars</code> dans cet exemple.</p>
<p>Voyons d’abord le résultat obtenu avec la fonction <code>lm</code> pour un modèle quadratique.</p>
<pre class="r"><code>reg &lt;- lm(dist ~ speed + I(speed^2), data = cars)
coefficients(reg)</code></pre>
<pre><code>## (Intercept)       speed  I(speed^2) 
##   2.4701378   0.9132876   0.0999593</code></pre>
<p>Pour retrouver ce résultat par optimisation numérique, on doit d’abord construire le vecteur <code>y</code> et la matrice <code>X</code> comme suit.</p>
<pre class="r"><code>y &lt;- cars$dist
X &lt;- cbind(intercept = 1, cars$speed, cars$speed^2)</code></pre>
<p>La fonction <code>lm</code> arrive à la valeur minimale des moindres carrés suivante</p>
<pre class="r"><code>moindresCarres(beta = coefficients(reg), y = y, X = X)</code></pre>
<pre><code>## [1] 10824.72</code></pre>
<p>pour les valeurs de paramètres <span class="math inline">\(\beta\)</span> = (2.4701378, 0.9132876, 0.0999593). À quoi arrive-t-on avec <code>optim</code>?</p>
<pre class="r"><code>op1 &lt;- optim(par = c(3,3,3), fn = moindresCarres, y = y, X = X)
op1</code></pre>
<pre><code>## $par
## [1] 7.2212674 0.2859028 0.1191485
## 
## $value
## [1] 10848.71
## 
## $counts
## function gradient 
##      144       NA 
## 
## $convergence
## [1] 0
## 
## $message
## NULL</code></pre>
<p>L’algorithme a convergé (car il retourne une valeur de 0 pour l’élément <code>convergence</code> dans la sortie), mais il n’arrive pas au bon résultat.</p>
<p>Solution potentielle : changer d’algorithme d’optimisation.</p>
<pre class="r"><code>op2 &lt;- optim(par = c(3,3,3), fn = moindresCarres, y = y, X = X, method = &quot;BFGS&quot;)
op2</code></pre>
<pre><code>## $par
## [1] 2.47011519 0.91329056 0.09995889
## 
## $value
## [1] 10824.72
## 
## $counts
## function gradient 
##       43        6 
## 
## $convergence
## [1] 0
## 
## $message
## NULL</code></pre>
<p>Autre solution potentielle : changer les bornes initiales.</p>
<pre class="r"><code>op3 &lt;- optim(par = c(2.5,1,0.1), fn = moindresCarres, y = y, X = X)
op3</code></pre>
<pre><code>## $par
## [1] 2.46514183 0.91414522 0.09993205
## 
## $value
## [1] 10824.72
## 
## $counts
## function gradient 
##      150       NA 
## 
## $convergence
## [1] 0
## 
## $message
## NULL</code></pre>
<p>Ici, même en partant de valeurs initiales très proches des paramètres optimaux, l’algorithme d’optimisation utilisé par défaut avec <code>optim</code> n’arrive pas à trouver l’optimum global de la fonction. Seule la solution de changer l’algorithme d’optimisation nous permet d’arriver approximativement au même résultat que celui trouvé algébriquement par <code>lm</code>.</p>
<pre class="r"><code>coefficients(reg)</code></pre>
<pre><code>## (Intercept)       speed  I(speed^2) 
##   2.4701378   0.9132876   0.0999593</code></pre>
<pre class="r"><code>op2$par</code></pre>
<pre><code>## [1] 2.47011519 0.91329056 0.09995889</code></pre>
<p>Cet exemple a illustré comment la fonction <code>optim</code> s’emploie. Il faut d’abord lui donner en entrée des valeurs initiales pour les paramètres de la fonction à optimiser (argument <code>par</code>). Ensuite, il faut lui fournir la fonction R qui implémente la fonction mathématique à optimiser (argument <code>fn</code>). Cette fonction doit retourner une seule valeur, numérique. De plus, son premier argument doit obligatoirement être le vecteur des paramètres que nous cherchons à estimer par l’optimisation effectuée. Après les arguments <code>par</code> et <code>fn</code>, il faut fournir, au besoin, des arguments à passer à la fonction donnée en entrée via l’argument <code>fn</code> (les arguments <code>y</code> et <code>X</code> dans l’exemple). Finalement, nous pouvons configurer le fonctionnement de la fonction <code>optim</code> en modifiant les valeurs des arguments <code>method</code>, <code>lower</code>, <code>upper</code>, <code>control</code>, ou <code>hessian</code>.</p>
</div>
</div>
