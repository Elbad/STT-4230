---
title: "Tests et exceptions en R"
author: "Sophie Baillargeon, Université Laval"
date: "2019-03-21"
weight: 5
slug: "tests_exceptions_r"
categories: ["cours_2019-03-26"]
categories_weight: 2
lastmodifierdisplayname : "Sophie Baillargeon"
lastmodifieremail: "sophie.baillargeon@mat.ulaval.ca"
output:
  pdf_document:
    toc: yes
    toc_depth: 3
  blogdown::html_page:
    toc: true
header-includes:
- \usepackage[french]{babel}
- \frenchbsetup{StandardLayout}
- \hypersetup{colorlinks=true, urlcolor = {blue}, linkcolor = {blue}}
editor_options: 
  chunk_output_type: console
---





<div id="TOC">
<ul>
<li><a href="#bonnes-pratiques-dans-le-developpement-de-fonctions">Bonnes pratiques dans le développement de fonctions</a><ul>
<li><a href="#demarche-de-travail-recommandee">Démarche de travail recommandée</a></li>
<li><a href="#exemple-de-developpement-de-fonction">Exemple de développement de fonction</a></li>
<li><a href="#organisation-du-code">Organisation du code</a></li>
</ul></li>
<li><a href="#tests">Tests</a><ul>
<li><a href="#objectif-1-obtenir-le-resultat-escompte">Objectif 1 : obtenir le résultat escompté</a></li>
<li><a href="#objectif-2-correctement-gerer-les-exceptions">Objectif 2 : correctement gérer les exceptions</a></li>
<li><a href="#formaliser-des-tests-avec-le-package-testthat">Formaliser des tests avec le package testthat</a></li>
</ul></li>
<li><a href="#debogage">Débogage</a><ul>
<li><a href="#outil-1-la-fonction-traceback">Outil 1 : la fonction <code>traceback</code></a></li>
<li><a href="#outil-2-la-fonction-browser-seule-avec-trace-ou-avec-debug">Outil 2 : la fonction <code>browser</code> (seule, avec <code>trace</code> ou avec <code>debug</code>)</a></li>
<li><a href="#outil-3-loption-error">Outil 3 : l’option <code>error</code></a></li>
<li><a href="#outil-4-print-et-cat">Outil 4 : <code>print</code> et <code>cat</code></a></li>
</ul></li>
<li><a href="#gestion-dexceptions">Gestion d’exceptions</a><ul>
<li><a href="#produire-des-erreurs-et-des-avertissements">Produire des erreurs et des avertissements</a></li>
<li><a href="#manipuler-des-erreurs-et-des-avertissements">Manipuler des erreurs et des avertissements</a></li>
</ul></li>
<li><a href="#synthese">Synthèse</a></li>
<li><a href="#references">Références</a></li>
</ul>
</div>

<hr />
<div id="bonnes-pratiques-dans-le-developpement-de-fonctions" class="section level1">
<h1>Bonnes pratiques dans le développement de fonctions</h1>
<div id="demarche-de-travail-recommandee" class="section level2">
<h2>Démarche de travail recommandée</h2>
<p>Les <a href="https://stt4230.rbind.io/programmation/fonctions_r/#etapes-de-developpement-conseillees">étapes de développement de fonction conseillées dans les notes sur les fonctions R</a> peuvent être complétées comme suit :</p>
<ol style="list-style-type: decimal">
<li><strong>Planifier</strong> le travail (pas de programmation encore) :
<ul>
<li>définir clairement la tâche à accomplir par la fonction et la sortie qu’elle doit produire,</li>
<li>prévoir les étapes à suivre afin d’effectuer cette tâche,</li>
<li>identifier les arguments devant être fournis en entrée à la fonction.</li>
</ul></li>
<li><strong>Développer le corps de la fonction</strong>
<ul>
<li>2.1. Écrire le programme par étapes, d’abord sans former la fonction, en commentant bien le code et en travaillant sur des mini-données test.</li>
<li>2.2 Pour chaque petite étape ou sous-tâche, tester interactivement si le programme produit le résultat escompté (tester souvent en cours de travail, ainsi il y a moins de débogage à faire).</li>
</ul></li>
<li><strong>Créer la fonction</strong> à partir du programme développé.</li>
<li><strong>Documenter</strong> la fonction.</li>
<li><strong>Tester</strong> la fonction : sauvegarder nos tests et bien les structurer, car ils serviront souvent.</li>
<li>Si nous rencontrons des comportements inattendus dans les tests, <strong>déboguer</strong> la fonction.</li>
</ol>
<p>Au fil du temps, il n’est pas rare d’avoir besoin de modifier une fonction que nous avons créée. La modification peut avoir pour but de :</p>
<ul>
<li>ajouter une fonctionnalité,</li>
<li>rendre la fonction plus facile d’utilisation,</li>
<li>rendre la fonction plus rapide,</li>
<li>etc.</li>
</ul>
<p>En cas de modification d’une fonction, il faut mettre à jour la documentation au besoin. Il est également recommandé de <strong>refaire nos tests</strong> pour s’assurer que les modifications apportées n’ont pas altéré les résultats obtenus de la fonction. Il faut donc répéter les étapes 4 à 6 jusqu’à ce que les tests ne révèlent plus aucun problème à régler ou aucune amélioration à apporter.</p>
<p>Nous allons voir dans les présentes notes comment tester et déboguer nos fonctions. Nous allons aussi voir comment contrôler les messages d’erreur et d’avertissement produits par nos fonctions.</p>
</div>
<div id="exemple-de-developpement-de-fonction" class="section level2">
<h2>Exemple de développement de fonction</h2>
<p>Créons ensemble une fonction qui calcule la distance de Manhattan entre deux points.</p>
<p><strong>Planification</strong> (étape 1) :</p>
<ul>
<li>implanter la formule (simple, une seule étape) : <a href="http://fr.wikipedia.org/wiki/Distance_de_Manhattan" class="uri">http://fr.wikipedia.org/wiki/Distance_de_Manhattan</a></li>
<li>sortie = la distance (une seule valeur)</li>
<li>entrée = les coordonnées de deux points (2 arguments)</li>
</ul>
<p><strong>Développement du corps de la fonction</strong> (étape 2) :</p>
<pre class="r"><code># mini-données test
pt1 &lt;- c(0,0)
pt2 &lt;- c(1,1)

# Code le plus simple qui me vient en tête
abs(pt1[1] - pt2[1]) + abs(pt1[2] - pt2[2])</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code># Il faudrait que ça fonctionne peu importe la dimension de l&#39;espace dans lequel mes 
# points sont représentés (donc peu importe la longueur des vecteurs pt1 et pt2)
sum(abs(pt1 - pt2))</code></pre>
<pre><code>## [1] 2</code></pre>
<p><strong>Création de la fonction</strong> à partir du programme développé (étape 3) :</p>
<pre class="r"><code>distman &lt;- function(point1, point2) {
  sum(abs(point1 - point2))
}</code></pre>
<p><strong>Documentation de la fonction</strong> (étape 4) :</p>
<p>Les informations minimales à fournir sont :</p>
<ul>
<li>ce que la fonction fait,</li>
<li>quels arguments la fonction accepte en entrée,</li>
<li>ce que la fonction retourne en sortie.</li>
</ul>
<p>Le plus simple est de fournir des informations en commentaires avant la définition de la fonction ou au début du corps de celle-ci.</p>

<pre class="r"><code># Calcule la distance de Manhattan entre deux points
# Arguments :
# - point1 : Un vecteur numerique des coordonnees du premier point.
# - point2 : Un vecteur numerique des coordonnees du deuxieme point.
# Sortie : La distance de Manhattan entre pt1 et pt2 (une seule valeur).
distman &lt;- function(point1, point2) {
  sum(abs(point1 - point2))
}</code></pre>
<p>Nous allons revenir sur ce point dans le cours sur la création de packages, car toute fonction d’un package doit avoir une fiche d’aide. Nous verrons donc une façon plus formelle de documenter des fonctions.</p>
<p><strong>Test et débogage</strong> (étapes 5 et 6) :</p>
<p>Nous allons faire les tests et le débogage après avoir vu la théorie à ce sujet, soit dans les sections suivantes.</p>
</div>
<div id="organisation-du-code" class="section level2">
<h2>Organisation du code</h2>
<p>Une bonne pratique dans l’organisation de notre code est de placer la définition de nos fonctions dans un fichier distinct. Ainsi, les instructions contenant des appels à nos fonctions ne sont pas dans le même programme R que les définitions des fonctions.</p>
<p>Afin de pouvoir utiliser nos fonctions, elles doivent être présentes dans un des environnements du chemin de recherche de R. Nous pourrions les mettre dans un package que nous créons et charger ce package. Plus simplement, nous pourrions soumettre le code définissant les fonctions dans la console R afin de créer les fonctions dans notre environnement de travail. C’est la façon de faire utilisée dans le cours jusqu’à maintenant.</p>
<p>Si nous avons placé les définitions de fonctions dans un fichier à part, il est facile de soumettre d’un coup tout le code contenu dans le fichier en une seule commande : un appel à la fonction <code>source</code>. Par exemple, si nos fonctions sont définies dans le fichier <code>mesFonctions.R</code> du répertoire <code>C:\coursR</code>, la commande suivante :</p>
<pre class="r"><code>source(&quot;C:/coursR/mesFonctions.R&quot;)</code></pre>
<p>évalue toutes les instructions contenues dans <code>mesFonctions.R</code>. Les objets créés par ces instructions sont stockés par défaut dans l’environnement de travail.</p>
<p>Appeler la fonction <code>source</code> est donc similaire à sélectionner tout le code contenu dans un fichier et le soumettre dans la console. Cependant, les deux façons de faire ne sont pas identiques. Avec <code>source</code>, dès que le code dans le fichier comporte au moins une erreur de syntaxe, aucune ligne de code du fichier n’est soumise. Aussi, seuls les appels spécifiques à la fonction <code>print</code> provoquent des affichages, alors qu’une instruction contenant seulement le nom d’un objet ne génère aucun affichage. Mais la plus grande différence entre les deux approches est que soumettre une commande <code>source</code> est plus efficace en terme de temps de travail que de sélectionner des lignes de code dans un script R, puis de soumettre toutes ces lignes. Avec <code>source</code>, le script R contenant les définitions des fonctions n’a même pas besoin d’être ouvert.</p>
<p>Ainsi, pour compléter la bonne pratique de placer la définition de nos fonctions dans un fichier distinct, il est recommandé d’inclure en entête de tout programme R utilisant les fonctions définies un certain fichier un appel à la fonction <code>source</code> pour soumettre les instructions contenues dans le fichier en question.</p>
<hr />

</div>
</div>
<div id="tests" class="section level1">
<h1>Tests</h1>
<div id="objectif-1-obtenir-le-resultat-escompte" class="section level2">
<h2>Objectif 1 : obtenir le résultat escompté</h2>
<p>Tester ses fonctions consiste à appeler les fonctions en donnant en entrée des valeurs d’arguments pour lesquelles nous savons quel résultat devrait être obtenu.</p>
<ul>
<li>Nous pouvons faire ça avec des mini-exemples pour lesquels nous pouvons faire les calculs à la main pour trouver le résultat escompté. Il est bien que ces cas soient représentatifs (en plus simple) de diverses situations qui peuvent être rencontrées en pratique.</li>
<li>Si des fonctions qui font le même calcul existent déjà, il est bon de comparer les résultats de nos fonctions aux résultats de ces fonctions.</li>
<li>Nous pouvons aussi comparer les résultats de nos fonctions à des résultats publiés dans des articles scientifiques ou des résultats théoriques. Si nos fonctions proposent de nouvelles méthodes de calculs, nous ne nous attendons pas nécessairement à reproduire de façon exacte les résultats publiés, mais nos résultats devraient être cohérents avec ceux publiés.</li>
</ul>
<div id="exemple" class="section level4">
<h4>Exemple :</h4>
<p>Testons la fonction <code>distman</code> avec d’autres points que ceux utilisés pour développer la fonction.</p>
<ul>
<li>Points avec coordonnées négatives :</li>
</ul>
<pre class="r"><code>distman(point1 = c(0, -5), point2 = c(0, -15))</code></pre>
<pre><code>## [1] 10</code></pre>
<p>Résultat attendu selon un calcul à la main : 10 = résultat obtenu.</p>
<ul>
<li>Points de dimension supérieure à 2 :</li>
</ul>
<pre class="r"><code>distman(point1 = c(0,0,0,0,0), point2 = c(1,1,1,1,1))</code></pre>
<pre><code>## [1] 5</code></pre>
<p>Résultat attendu selon un calcul à la main : 5 = résultat obtenu.</p>
<ul>
<li>Comparaisons avec la fonction <code>dist</code> qui implémente le même calcul que notre fonction <code>distman</code> :</li>
</ul>
<pre class="r"><code>distman(point1 = c(0,0), point2 = c(1,1))</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code>dist(rbind(c(0,0), c(1,1)), method = &quot;manhattan&quot;)</code></pre>
<pre><code>##   1
## 2 2</code></pre>
<pre class="r"><code>distman(c(0,0), c(1,1)) == dist(rbind(c(0,0), c(1,1)), method = &quot;manhattan&quot;)[1]</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>distman(point1 = c(0,-5), point2 = c(0,-15))</code></pre>
<pre><code>## [1] 10</code></pre>
<pre class="r"><code>dist(rbind(c(0,-5), c(0,-15)), method = &quot;manhattan&quot;)</code></pre>
<pre><code>##    1
## 2 10</code></pre>
<pre class="r"><code>distman(c(0,-5), c(0,-15)) == dist(rbind(c(0,-5), c(0,-15)), method = &quot;manhattan&quot;)[1]</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>distman(point1 = c(0,0,0,0,0), point2 = c(1,1,1,1,1))</code></pre>
<pre><code>## [1] 5</code></pre>
<pre class="r"><code>dist(rbind(c(0,0,0,0,0), c(1,1,1,1,1)), method = &quot;manhattan&quot;)</code></pre>
<pre><code>##   1
## 2 5</code></pre>
<pre class="r"><code>distman(c(0,0,0,0,0), c(1,1,1,1,1)) == 
  dist(rbind(c(0,0,0,0,0), c(1,1,1,1,1)), method = &quot;manhattan&quot;)[1]</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Nous obtenons les mêmes distances.</p>
<p>Si nous n’avions pas obtenu les résultats escomptés, il aurait fallu apporter des correctifs à notre fonction.</p>
</div>
</div>
<div id="objectif-2-correctement-gerer-les-exceptions" class="section level2">
<h2>Objectif 2 : correctement gérer les exceptions</h2>
<p>Les tests visent aussi à vérifier si une fonction réagit correctement aux exceptions. Qu’est-ce qu’une exception?</p>
<blockquote>
<p>Une <strong>exception</strong> est une situation anormale ou exceptionnelle qui requiert un traitement spécial (souvent l’arrêt de la fonction).</p>
</blockquote>
<p>Des exemples d’exceptions sont :</p>
<ul>
<li>des arguments incorrects fournis en entrée,</li>
<li>des résultats de calcul inattendus.</li>
</ul>
<p>Lors de la rencontre d’exceptions, les fonctions R réagissent en générant des erreurs ou des avertissements.</p>
<blockquote>
<p>Les erreurs et avertissements sont appelés <strong>conditions</strong> en R.</p>
</blockquote>
<p>En plus des erreurs et avertissements, R comporte un troisième type de condition : les messages.</p>
<p>Les différents types de conditions sont définis ainsi :</p>
<ul>
<li><strong>Erreur</strong> : L’exécution de la fonction est interrompue et un message d’erreur est affiché.</li>
<li><strong>Avertissement</strong> : Un message d’avertissement est affiché pour signifier un problème potentiel. L’exécution de la fonction n’est pas interrompue.</li>
<li><strong>Message</strong> : Un message est affiché pour apporter une information supplémentaire (par exemple la valeur par défaut utilisée pour un argument important non fourni en entrée). L’exécution de la fonction n’est pas interrompue. Ce type de condition est moins utilisé que les deux autres.</li>
</ul>
<p>Notons que les messages associés à une condition R, peu importe son type, sont parfois traduits de façon automatique en fonction de la langue de notre système d’exploitation.</p>
<div id="exemple-1" class="section level4">
<h4>Exemple :</h4>
<p>Testons si notre fonction <code>distman</code> gère correctement quelques exceptions.</p>
<ul>
<li>Si nous donnons en entrée à notre fonction <code>distman</code> des points de dimensions différentes, que se passe-t-il?</li>
</ul>
<pre class="r"><code>distman(point1 = c(-1,0), point2 = c(1,2,3))</code></pre>
<pre><code>## Warning in point1 - point2: longer object length is not a multiple of
## shorter object length</code></pre>
<pre><code>## [1] 8</code></pre>
<p>Nous pourrions préférer que la fonction retourne une erreur plutôt qu’un avertissement. Nous y reviendrons plus loin.</p>
<ul>
<li>Si nous donnons en entrée à <code>distman</code> des arguments non numériques, que se passe-t-il?</li>
</ul>
<pre class="r"><code>distman(point1 = c(&quot;a&quot;, &quot;b&quot;), point2 = c(&quot;c&quot;,&quot;d&quot;))</code></pre>
<pre><code>## Error in point1 - point2: non-numeric argument to binary operator</code></pre>
<p>L’exécution de la fonction s’arrête et le message d’erreur affiché est informatif. Un <strong>message informatif</strong> aide l’utilisateur à comprendre ce qu’il a fait incorrectement. Un message non informatif ne guide pas suffisamment l’utilisateur dans la modification de son appel de la fonction afin de ne plus avoir d’erreur.</p>
<ul>
<li>Si nous donnons en entrée des matrices, que se passe-t-il?</li>
</ul>
<pre class="r"><code>distman(point1 = rbind(c(0,0), c(1,0)), point2 = rbind(c(3,2), c(2,3)))</code></pre>
<pre><code>## [1] 9</code></pre>
<p>Ce résultat peut être surprenant pour quelqu’un qui pensait obtenir plus d’une distance, par exemple une entre la ligne i de <code>point1</code> et la ligne i de <code>point2</code> pour tout i = 1, …, <code>nrow(point1)</code>. Nous pourrions envisager de produire un message d’avertissement (nous verrons comment faire plus loin).</p>
</div>
</div>
<div id="formaliser-des-tests-avec-le-package-testthat" class="section level2">
<h2>Formaliser des tests avec le package testthat</h2>
<p>Le <a href="http://testthat.r-lib.org/">package <code>testthat</code></a> offre des fonctions facilitant l’écriture, l’organisation et l’exécution automatique de tests unitaires en R. Voici quelques fonctions du package :</p>
<ul>
<li><p>fonction d’écriture (un appel à une de ces fonctions = un test unitaire) :</p>
<ul>
<li><code>expect_equal</code>,</li>
<li><code>expect_error</code>,</li>
<li><code>expect_warning</code>,</li>
<li><code>expect_true</code>,</li>
<li>etc.</li>
</ul></li>
<li><p>fonction d’organisation : <code>context</code>, <code>test_that</code></p></li>
<li><p>fonction d’exécution : <code>test_file</code>, <code>test_dir</code>, etc.</p></li>
</ul>
<p>L’utilisation de ce package n’est pas décrite en détail ici, mais un court exemple est présenté pour illustrer son utilisation. Écrire ses tests avec <code>testthat</code> demande un certain investissement en temps, mais une fois cette étape terminée, il est facile de lancer ses tests à plusieurs reprises en cours de travail.</p>
<div id="exemple-2" class="section level4">
<h4>Exemple :</h4>
<p>Voici quelques exemples qui reprennent des tests effectués précédemment sur la fonction <code>distman</code>.</p>
<pre class="r"><code>library(testthat)</code></pre>
<ul>
<li>Cas simple pour lequel nous pouvons calculer à la main le résultat escompté :</li>
</ul>
<pre class="r"><code>test_that(&quot;nous reproduisons un calcul à la main&quot;,
          expect_equal(distman(point1 = c(0,-5), point2 = c(0,-15)), 10))</code></pre>
<ul>
<li>Comparaison avec le résultat d’une autre fonction :</li>
</ul>
<pre class="r"><code>test_that(&quot;nous obtenons le même résultat que la fonction dist&quot;,
          expect_equal(distman(point1 = c(0,0), point2 = c(1,1)),
          as.vector(dist(rbind(c(0,0), c(1,1)), method = &quot;manhattan&quot;))))</code></pre>
<ul>
<li>Vérification de la gestion d’exceptions</li>
</ul>
<pre class="r"><code>test_that(&quot;des vecteurs de dimensions différentes génèrent une erreur&quot;,
          expect_error(distman(point1 = c(-1,0), point2 = c(1,2,3))))</code></pre>
<pre><code>## Error: Test failed: &#39;des vecteurs de dimensions différentes génèrent une erreur&#39;
## * `distman(point1 = c(-1, 0), point2 = c(1, 2, 3))` did not throw an error.</code></pre>
<pre class="r"><code>test_that(&quot;des matrices génèrent un avertissement&quot;, {
          mat1 &lt;- rbind(c(0,0), c(1,0))
          mat2 &lt;- rbind(c(3,2), c(2,3))
          expect_warning(distman(point1 = mat1, point2 = mat2))
})</code></pre>
<pre><code>## Error: Test failed: &#39;des matrices génèrent un avertissement&#39;
## * `distman(point1 = mat1, point2 = mat2)` did not produce any warnings.</code></pre>
<p>Nous allons apporter plus loin des changements à <code>distman</code> afin de passer avec succès tous ces tests. Pour l’instant, nous passons avec succès les 2 premiers, mais échouons les deux derniers.</p>
<hr />
</div>
</div>
</div>
<div id="debogage" class="section level1">
<h1>Débogage</h1>
<blockquote>
<p>Le <strong>débogage</strong> est un processus méthodique pour trouver et régler les bogues dans un programme informatique, soit les anomalies de fonctionnement du programme.</p>
</blockquote>
<p>Si nos tests ont révélé des résultats inattendus ou des exceptions mal gérées, il faut procéder à du débogage. La première étape du débogage est de repérer le bout de code responsable du bogue et de comprendre pourquoi le bogue est rencontré. La deuxième étape consiste à modifier le code pour corriger le problème.</p>
<p>Les outils présentés pour accomplir la première étape du débogage peuvent aussi servir à comprendre une condition obtenue lors de l’utilisation d’une fonction programmée par quelqu’un d’autre.</p>
<p>Lorsque nous obtenons une erreur en appelant une fonction, le message d’erreur explique parfois suffisamment clairement pourquoi la fonction ne peut pas retourner de résultats.</p>
<p><strong>Exemple</strong> : argument fourni dans un mauvais format</p>
<pre class="r"><code>aggregate(x = iris$Sepal.Length, by = iris$Species, FUN = min)</code></pre>
<pre><code>## Error in aggregate.data.frame(as.data.frame(x), ...): &#39;by&#39; must be a list</code></pre>
<p>Dans cet exemple, le message d’erreur nous aide à comprendre que nous avons mal utilisé la fonction et nous met sur une piste pour modifier notre appel à la fonction.</p>
<p>Dans d’autres cas, les messages d’erreur ou d’avertissement ne sont pas très informatifs. Dans un tel cas, la documentation de la fonction peut parfois nous aider. Une autre option est d’utiliser des outils de débogage pour comprendre la nature de l’exception rencontrée et comment utiliser correctement la fonction.</p>
<div id="rapporter-un-bogue" class="section level4">
<h4>Rapporter un bogue</h4>
<p>Lorsque nous croyons avoir découvert un bogue dans du code de nous n’avons pas développé nous même, il est bien de contacter le mainteneur du code pour lui en faire part. Il faut par contre d’abord s’assurer d’utiliser la dernière version du code. Le mainteneur des fonctions de base de R est le R core team. La page web <a href="https://www.r-project.org/bugs.html" class="uri">https://www.r-project.org/bugs.html</a> explique comment faire part de bogues potentiels à cette équipe. Pour signaler un bogue dans un package R, il suffit de contacter son mainteneur par courriel. Toute documentation de package contient l’adresse courriel de son mainteneur. Si le package est développé en utilisant un service web public d’hébergement et de gestion de versions, tel que GitHub, la meilleure façon de rapporter un bogue est de créer un nouvel <em>issue</em>.</p>
<p>Faire part d’un bogue potentiel à un mainteneur présente des avantages pour tous. L’utilisateur arrive souvent ainsi à régler le problème qu’il rencontre et le mainteneur a l’opportunité d’améliorer son code en corrigeant des bogues ou en identifiant les aspects moins compris de son code ou de sa documentation.</p>
</div>
<div id="exemple-de-bogue-dans-notre-propre-code" class="section level4">
<h4>Exemple de bogue dans notre propre code :</h4>
<p>Supposons que nous développons une fonction qui calcule des moyennes. Si l’argument donné en entrée est un vecteur, la fonction doit calculer une seule moyenne, celle des observations dans le vecteur. Si l’argument donné en entrée a plus d’une dimension, la fonction <code>colMeans</code> doit être appelée. Pour une matrice en entrée, nous obtiendrions donc la moyenne des observations dans chaque colonne.</p>
<pre class="r"><code>mean2 &lt;- function(x) {
  if (is.null(dim(x))) {
    colMeans(x)
  } else {
    mean(x)
  }
}

mean2(matrix(1:4, 2, 2))</code></pre>
<pre><code>## [1] 2.5</code></pre>
<pre class="r"><code>mean2(1:4)</code></pre>
<pre><code>## Error in colMeans(x): &#39;x&#39; must be an array of at least two dimensions</code></pre>
<p>La fonction ne fait pas ce que nous voulions. Déboguons-la.</p>
</div>
<div id="outil-1-la-fonction-traceback" class="section level2">
<h2>Outil 1 : la fonction <code>traceback</code></h2>
<p>La première chose à faire en cas d’erreur rencontrée est de tenter de comprendre le message d’erreur affiché. La fonction <code>traceback</code> peut apporter plus d’informations concernant la provenance de l’erreur.</p>
<pre class="r"><code>traceback()</code></pre>
<pre><code>## 3: stop(&quot;&#39;x&#39; must be an array of at least two dimensions&quot;)
## 2: colMeans(x) at #3
## 1: mean2(1:4)</code></pre>
<p>Cette fonction retourne la séquence des appels de fonctions qui a mené à l’erreur. Nous apprenons ici que l’erreur a été générée par la fonction <code>stop</code>, dans un appel à la fonction <code>colMeans</code>, à l’intérieur de l’appel à <code>mean2</code>. En fait, ici, le message d’erreur nous avait déjà informés que l’erreur provenait d’un appel à <code>colMeans</code>. Pourquoi la fonction <code>colMeans</code> est-elle appelée alors que la valeur de <code>x</code> fournie en entrée est un vecteur?</p>
</div>
<div id="outil-2-la-fonction-browser-seule-avec-trace-ou-avec-debug" class="section level2">
<h2>Outil 2 : la fonction <code>browser</code> (seule, avec <code>trace</code> ou avec <code>debug</code>)</h2>
<p>La fonction <code>browser</code> permet d’interrompre l’exécution d’une fonction, de donner accès à l’environnement d’exécution de la fonction et d’exécuter le corps de la fonction une instruction à la fois. Pour ce faire, il suffit d’insérer l’instruction</p>
<pre class="r"><code>browser()</code></pre>
<p>dans le corps de la fonction, à l’endroit où nous souhaitons interrompre l’exécution. Ensuite, il faut soumettre de nouveau la définition de la fonction. Le prochain appel à cette fonction sera interrompu lorsque l’instruction <code>browser()</code> sera rencontré.</p>
<p>Lorsque l’outil d’inspection de code ouvert par la fonction <code>browser</code> est actif, le symbole d’invite de commandes (<em>prompt</em>) dans la console devient <code>&gt; Browse[d]</code> au lieu de <code>&gt;</code>. Ici, <code>d</code> représente la profondeur de la séquence d’appels de fonctions. Les <strong>mots-clés</strong> suivants sont alors compris (voir <a href="http://stat.ethz.ch/R-manual/R-devel/library/base/html/browser.html"><code>help(browser)</code></a> pour la liste complète des mots-clés) :</p>
<ul>
<li><code>n</code> : pour exécuter la prochaine commande,</li>
<li><code>c</code> : pour exécuter jusqu’au prochain point d’arrêt (ex. une autre commande <code>browser()</code>),</li>
<li><code>Q</code> : pour sortir de l’outil d’inspection de code et retourner au mode R interactif usuel;</li>
</ul>
<p>Il est aussi possible de soumettre n’importe quelle commande R dans l’outil d’inspection de code. Par contre, si un objet porte le nom d’un des mots-clés, nous ne pouvons plus taper directement son nom dans la console pour l’afficher. Il faut passer par une commande telle que <code>print(n)</code>.</p>
<blockquote>
<p>La commande <code>browser()</code> peut être appelée un point d’arrêt (<em>breakpoint</em>), pour réutiliser un terme usuel en débogage informatique.</p>
</blockquote>
<div id="rstudio" class="section level4">
<h4>RStudio :</h4>
<p>L’environnement intégré de développement RStudio offre des fonctionnalités facilitant grandement l’utilisation de la fonction <code>browser</code>. Lorsque la fonction <code>browser</code> est appelée, RStudio :</p>
<ul>
<li>ouvre une fenêtre contenant le corps de la fonction dans laquelle <code>browser</code> a été appelé et souligne en jaune le prochain bout de code à être soumis dans l’exécution pas à pas,</li>
<li>permet de visualiser le contenu de l’environnement d’exécution de la fonction dans laquelle <code>browser</code> a été appelé à partir de la sous-fenêtre <em>Environment</em>,</li>
<li>ajoute dans l’entête de la console une barre de boutons pouvant remplacer l’utilisation des mots-clés <code>n</code>, <code>c</code> et <code>Q</code>.</li>
</ul>
</div>
<div id="differentes-facons-dinserer-un-appel-a-la-fonction-browser-dans-le-corps-dune-fonction" class="section level4">
<h4>Différentes façons d’insérer un appel à la fonction <code>browser</code> dans le corps d’une fonction</h4>
<ul>
<li>À la main, en éditant le code source.</li>
</ul>
<p>Il ne faut pas oublier d’aller retirer la commande et de soumettre de nouveau le code source de la fonction lorsque le débogage est terminé. Ainsi, l’outil d’inspection de code ne sera plus ouvert à chaque fois que la fonction est appelée.</p>
<ul>
<li>En utilisant la fonction <code>trace</code>, comme suit :</li>
</ul>
<pre class="r"><code>trace(mean2, browser)</code></pre>
<p>L’argument <code>at</code> permet de spécifier à quel endroit dans le code la commande <code>browser()</code> doit être insérée. Par défaut elle est mise dans la première ligne. La commande <code>browser()</code> est ensuite retirée avec la fonction <code>untrace</code>, comme suit :</p>
<pre class="r"><code>untrace(mean2)</code></pre>
<ul>
<li>En utilisant la fonction <code>debug</code>, comme suit :</li>
</ul>
<pre class="r"><code>debug(mean2)</code></pre>
<p>La commande <code>browser()</code> est alors insérée dans la première ligne du corps de la fonction <code>mean2</code>. La commande <code>browser()</code> est ensuite retirée avec la fonction <code>undebug</code>, comme suit :</p>
<pre class="r"><code>undebug(mean2)</code></pre>
<ul>
<li>En utilisant une fonctionnalité de RStudio : insérer un point d’arrêt dans un code source, soit en cliquant dans la marge de droite dans l’éditeur de script R de RStudio, ou par le menu <em>Debug -&gt; Toggle Breakpoint</em>.</li>
</ul>
</div>
</div>
<div id="outil-3-loption-error" class="section level2">
<h2>Outil 3 : l’option <code>error</code></h2>
<p>Il est possible du faire du <strong>débogage post mortem</strong> en R. Ce type de débogage consiste à tenter de trouver la cause d’une erreur après que l’exécution de la fonction ait été interrompue. La fonction <code>traceback</code> est donc en fait un outil de débogage post mortem, mais pas très puissant.</p>
<p>Si nous donnons comme valeur à l’option globale nommée <code>error</code> la fonction <code>recover</code> comme suit</p>
<pre class="r"><code>options(error = recover)</code></pre>
<p>R donne accès à l’environnement d’exécution de toute fonction dans laquelle une erreur est générée. Par exemple, essayons de soumettre la commande</p>
<pre class="r"><code>mean2(1:4)  # fonction non soumise ici, à essayer dans une session R</code></pre>
<p>R nous demande alors d’identifier l’environnement que nous souhaitons inspecter : celui de l’exécution de <code>mean2</code> ou celui de l’exécution de <code>colMeans</code> (car l’erreur a été rencontrée dans un appel à <code>colMeans</code>, qui a eu lieu dans un appel à <code>mean2</code>). Après avoir fait notre choix, nous pouvons visualiser les objets dans l’environnement d’exécution choisi.</p>
<p>Pour remettre l’option <code>error</code> à sa valeur par défaut, il faut soumettre le code suivant :</p>
<pre class="r"><code>options(error = NULL)</code></pre>
<p>Dans l’exemple de la fonction <code>mean2</code>, vous l’avez déjà trouvé, l’erreur est simplement que ce n’est pas la bonne branche du <code>if</code> qui est sélectionné selon la nature de <code>x</code>.</p>
<p>Correction :</p>
<pre class="r"><code>mean2 &lt;- function(x) {
  if (!is.null(dim(x))) { # ajout d&#39;une négation ici
    colMeans(x)
  } else {
    mean(x)
  }
}

mean2(matrix(1:4, 2, 2))</code></pre>
<pre><code>## [1] 1.5 3.5</code></pre>
<pre class="r"><code>mean2(1:4)</code></pre>
<pre><code>## [1] 2.5</code></pre>
</div>
<div id="outil-4-print-et-cat" class="section level2">
<h2>Outil 4 : <code>print</code> et <code>cat</code></h2>
<p>Les fonctions <code>print</code> et <code>cat</code> s’avère aussi être des outils de débogage très simples en R. Ces fonctions permettent d’imprimer une trace des calculs effectués dans la fonction.</p>
<div id="exemple-3" class="section level4">
<h4>Exemple :</h4>
<p>Intéressons-nous au cas particulier d’une boucle qui est arrêtée à cause d’une erreur. Il est alors informatif de savoir quelle itération de la boucle est problématique.</p>
<p>Voici un exemple de fonction qui sert à inverser une série de matrices fournies en entrée.</p>
<pre class="r"><code>inverses &lt;- function(...) {
  matrices &lt;- list(...)
  inverses &lt;- vector(mode = &quot;list&quot;, length = length(matrices))
  for (i in 1:length(matrices)) {
    inverses[[i]] &lt;- solve(matrices[[i]])
  }
  inverses
}

inverses(a = matrix(1:4, 2, 2),
         b = matrix(c(1, 0, -2, 0, 1, 2, -1, -2, -2), 3, 3), 
         c = matrix(c(1, 3, 2, 6, 4, 2, 3, 5, 6) , 3, 3))</code></pre>
<pre><code>## Error in solve.default(matrices[[i]]) : 
##  Lapack routine dgesv: system is exactly singular: U[3,3] = 0 </code></pre>
<p>Il est possible d’obtenir de l’information concernant l’itération problématique avec du débogage post mortem utilisant l’option <code>error</code>. Une autre possibilité serait de faire imprimer une trace temporaire des calculs à chaque itération.</p>
<pre class="r"><code>inverses &lt;- function(...) {
  matrices &lt;- list(...)
  inverses &lt;- vector(mode = &quot;list&quot;, length = length(matrices))
  for (i in 1:length(matrices)) {
    cat(&quot;itération&quot;, i, &quot;\n&quot;)
    # ou  
    # print(i)
    inverses[[i]] &lt;- solve(matrices[[i]])
  }
  inverses
}

inverses(a = matrix(1:4, 2, 2),
         b = matrix(c(1, 0, -2, 0, 1, 2, -1, -2, -2), 3, 3), 
         c = matrix(c(1, 3, 2, 6, 4, 2, 3, 5, 6) , 3, 3))</code></pre>
<pre><code>## itération 1 
## itération 2 

## Error in solve.default(matrices[[i]]) : 
##  Lapack routine dgesv: system is exactly singular: U[3,3] = 0</code></pre>
<p>Nous savons maintenant que l’erreur est causée par la deuxième matrice fournie en entrée, soit la matrice <code>b</code>.</p>
<p>Une fois le problème compris et réglé (ce qui sera fait plus loin pour cet exemple), nous souhaitons la plupart du temps retirer les appels à la fonction <code>print</code> ou <code>cat</code> de la fonction.</p>
<hr />
</div>
</div>
</div>
<div id="gestion-dexceptions" class="section level1">
<h1>Gestion d’exceptions</h1>
<div id="produire-des-erreurs-et-des-avertissements" class="section level2">
<h2>Produire des erreurs et des avertissements</h2>
<p>Nous avons parfois besoin que nos fonctions génèrent des erreurs et des avertissements, notamment :</p>
<ul>
<li>pour communiquer avec l’utilisateur dans le cas de résultats de calcul inattendus,</li>
<li>pour la validation des arguments fournis en entrée.</li>
</ul>
<p>Il vaut mieux arrêter l’exécution de la fonction si les arguments fournis en entrée sont incorrects et que le comportement de la fonction n’est pas approprié (mauvais calcul ou message d’erreur non informatif).</p>
<div id="fonctions-utiles" class="section level4">
<h4>Fonctions utiles :</h4>
<ul>
<li>Pour générer une erreur : <code>stop</code>, <code>stopifnot</code>, <code>match.arg</code> (vue dans les notes sur la <a href="https://stt4230.rbind.io/programmation/fonctions_r/#valeur-par-defaut-pour-un-argument-acceptant-seulement-un-petit-nombre-de-chaines-de-caracteres-specifiques">création de fonctions en R</a>),</li>
<li>Pour générer un avertissement : <code>warning</code>.</li>
</ul>
<p>Remarque : Pour la tâche spécifique de valider les valeurs fournies en argument, le <a href="https://cran.r-project.org/web/packages/checkmate/index.html">package <code>checkmate</code></a> propose plusieurs fonctions rendant la tâche plus facile au développeur, par exemple les fonctions <code>checkCount</code>, <code>checkScalar</code>, <code>checkIntegerish</code>, etc.</p>
</div>
<div id="exemple-4" class="section level4">
<h4>Exemple :</h4>
<p>Faisons générer une erreur à notre fonction <code>distman</code> lorsqu’elle reçoit en entrée deux vecteurs qui ne sont pas de mêmes longueurs.</p>
<pre class="r"><code>distman &lt;- function(point1, point2) {
  if (length(point1) != length(point2))
    stop(&quot;&#39;point1&#39; and &#39;point2&#39; must have the same length&quot;)
  sum(abs(point1 - point2))
}

distman(c(-1,0), c(1,2,3))</code></pre>
<pre><code>## Error in distman(c(-1, 0), c(1, 2, 3)) : 
##   &#39;point1&#39; and &#39;point2&#39; must have the same length</code></pre>
<p>ou encore</p>
<pre class="r"><code>distman &lt;- function(point1, point2) {
  stopifnot(length(point1) == length(point2))
  sum(abs(point1 - point2))
}

distman(c(-1,0), c(1,2,3))</code></pre>
<pre><code>## Error in distman(c(-1, 0), c(1, 2, 3)): length(point1) == length(point2) is not TRUE</code></pre>
<p>Faisons générer un avertissement à notre fonction <code>distman</code> si les arguments <code>point1</code> et <code>point2</code> sont de dimension supérieure à 1.</p>
<pre class="r"><code>distman &lt;- function(point1, point2) {
  if (length(point1) != length(point2)) 
    stop(&quot;&#39;point1&#39; and &#39;point2&#39; must have the same length&quot;)
  if (!is.null(dim(point1)) || !is.null(dim(point2)))
    warning(&quot;&#39;point1&#39; and &#39;point2&#39; are treated as dimension 1 vectors&quot;)
  sum(abs(point1 - point2))
}

distman(rbind(c(0,0), c(1,0)), rbind(c(3,2), c(2,3)))</code></pre>
<pre><code>## Warning in distman(rbind(c(0, 0), c(1, 0)), rbind(c(3, 2), c(2, 3))):
## &#39;point1&#39; and &#39;point2&#39; are treated as dimension 1 vectors</code></pre>
<pre><code>## [1] 9</code></pre>
<p>Nos tests ne devraient maintenant plus échouer.</p>
<pre class="r"><code>test_that(&quot;nous reproduisons un calcul à la main&quot;,
          expect_equal(distman(point1 = c(0,-5), point2 = c(0,-15)), 10))

test_that(&quot;nous obtenons le même résultat que la fonction dist&quot;,
           expect_equal(distman(point1 = c(0,0), point2 = c(1,1)),
            as.vector(dist(rbind(c(0,0), c(1,1)), method = &quot;manhattan&quot;))))

test_that(&quot;des vecteurs de dimensions différentes génèrent une erreur&quot;,
          expect_error(distman(point1 = c(-1,0), point2 = c(1,2,3))))

test_that(&quot;des matrices génèrent un avertissement&quot;, {
          mat1 &lt;- rbind(c(0,0), c(1,0))
          mat2 &lt;- rbind(c(3,2), c(2,3))
          expect_warning(distman(point1 = mat1, point2 = mat2))
})</code></pre>
<p>C’est bien le cas, car ce code de tests roule sans erreur.</p>
</div>
</div>
<div id="manipuler-des-erreurs-et-des-avertissements" class="section level2">
<h2>Manipuler des erreurs et des avertissements</h2>
<p>Il est possible d’attraper des erreurs et de les manipuler avec la fonction <code>try</code>. Cette fonction permet entre autres d’éviter l’arrêt d’une boucle lorsqu’une erreur est rencontrée pour une certaine itération.</p>
<div id="exemple-5" class="section level4">
<h4>Exemple :</h4>
<p>Rappelons que l’exécution de notre fonction <code>inverses</code> est arrêtée dès qu’elle rencontre une matrice non inversible :</p>
<pre class="r"><code>inverses(a = matrix(1:4, 2, 2),
         b = matrix(c(1, 0, -2, 0, 1, 2, -1, -2, -2), 3, 3), 
         c = matrix(c(1, 3, 2, 6, 4, 2, 3, 5, 6) , 3, 3))</code></pre>
<pre><code>## Error in solve.default(matrices[[i]]) : 
##  Lapack routine dgesv: system is exactly singular: U[3,3] = 0 </code></pre>
<p>Il serait plutôt souhaitable que le calcul soit fait pour toutes les matrices, en sautant celles non inversibles.</p>
<pre class="r"><code>inverses &lt;- function(...) {
  matrices &lt;- list(...)
  inverses &lt;- vector(mode = &quot;list&quot;, length = length(matrices))
  for (i in 1:length(matrices)) {
    tentative &lt;- try(solve(matrices[[i]]), silent = TRUE)
    if (inherits(tentative, &quot;try-error&quot;)) {
      # Si la commande a généré une erreur, retourner une matrice de NA
      inverses[[i]] &lt;- matrix(NA, nrow = nrow(matrices[[i]]), ncol = ncol(matrices[[i]]))
    } else {
      # Sinon, retourner la matrice inversée
      inverses[[i]] &lt;- tentative
    }
  }
  inverses
}

inverses(a = matrix(1:4, 2, 2),
         b = matrix(c(1, 0, -2, 0, 1, 2, -1, -2, -2), 3, 3), 
         c = matrix(c(1, 3, 2, 6, 4, 2, 3, 5, 6) , 3, 3))</code></pre>
<pre><code>## [[1]]
##      [,1] [,2]
## [1,]   -2  1.5
## [2,]    1 -0.5
## 
## [[2]]
##      [,1] [,2] [,3]
## [1,]   NA   NA   NA
## [2,]   NA   NA   NA
## [3,]   NA   NA   NA
## 
## [[3]]
##       [,1]  [,2]  [,3]
## [1,] -0.35  0.75 -0.45
## [2,]  0.20  0.00 -0.10
## [3,]  0.05 -0.25  0.35</code></pre>
<p>Il faut donner comme premier argument à la fonction <code>try</code> une expression. Dans l’exemple précédent, il s’agissait d’une seule instruction. Il aurait aussi pu s’agir d’une séquence d’instructions, entre accolades. L’argument <code>silent = TRUE</code> a signifié à <code>try</code> de ne pas afficher de messages.</p>
<p>L’objet retourné par <code>try</code> est l’objet retourné par l’expression fournie en premier argument si aucune erreur n’est rencontrée. Sinon, il s’agit d’un objet de classe <code>&quot;try-error&quot;</code> contenant le message d’erreur. L’instruction <code>inherits(tentative, &quot;try-error&quot;)</code> retourne <code>TRUE</code> si l’objet <code>tentative</code> possède la classe <code>&quot;try-error&quot;</code>, <code>FALSE</code> sinon. L’utilisation de la fonction <code>inherits</code> est l’outil recommandé pour tester l’appartenance d’un objet à un classe.</p>
</div>
<div id="autres-outils-pour-manipuler-des-erreurs-et-des-avertissements-en-r" class="section level4">
<h4>Autres outils pour manipuler des erreurs et des avertissements en R :</h4>
<ul>
<li>l’option globale <code>warn</code>
<ul>
<li>si <code>warn</code> prend une valeur négative : tous les avertissements sont ignorés,</li>
<li>si <code>warn</code> prend la valeur 0 (option par défaut) : les avertissements sont affichés à la fin de l’exécution de la fonction,</li>
<li>si <code>warn</code> prend la valeur 1 : les avertissements sont affichés au fur et à mesure qu’ils surviennent,</li>
<li>si <code>warn</code> prend la valeur 2 : tous les avertissements sont transformés en erreurs;</li>
</ul></li>
<li>la fonction <code>suppressWarnings</code> : permet d’ignorer les avertissements générés par des instructions R spécifiques.</li>
</ul>
<pre class="r"><code># Exemple d&#39;utilisation de la fonction suppressWarnings
suppressWarnings(distman(rbind(c(0,0), c(1,0)), rbind(c(3,2), c(2,3))))</code></pre>
<pre><code>## [1] 9</code></pre>
<hr />
</div>
</div>
</div>
<div id="synthese" class="section level1">
<h1>Synthèse</h1>
<div id="bonnes-pratiques-dans-le-developpement-de-fonctions-1" class="section level4">
<h4>Bonnes pratiques dans le développement de fonctions</h4>
<ol style="list-style-type: decimal">
<li><strong>Planifier</strong> le travail (pas de programmation encore) :
<ul>
<li>définir clairement la tâche à accomplir par la fonction et la sortie qu’elle doit produire,</li>
<li>prévoir les étapes à suivre afin d’effectuer cette tâche,</li>
<li>identifier les arguments devant être fournis en entrée à la fonction.</li>
</ul></li>
<li><strong>Développer le corps de la fonction</strong>
<ul>
<li>2.1. Écrire le programme par étapes, d’abord sans former la fonction, en commentant bien le code et en travaillant sur des mini-données test.</li>
<li>2.2 Pour chaque petite étape ou sous-tâche, tester interactivement si le programme produit le résultat escompté (tester souvent en cours de travail, ainsi il y a moins de débogage à faire).</li>
</ul></li>
<li><strong>Créer la fonction</strong> à partir du programme développé.</li>
<li><strong>Documenter</strong> la fonction.</li>
<li><strong>Tester</strong> la fonction : sauvegarder nos tests et bien les structurer, car ils serviront souvent.</li>
<li>Si nous rencontrons des comportements inattendus dans les tests, <strong>déboguer</strong> la fonction.</li>
</ol>
<p>En cas de <strong>modification</strong> d’une fonction, <strong>répéter les étapes 4 à 6</strong> jusqu’à ce que les tests ne révèlent plus aucun problème à régler ou amélioration à apporter.</p>
</div>
<div id="organisation-du-code-1" class="section level4">
<h4>Organisation du code</h4>
<ul>
<li>placer la définition de nos fonctions dans un fichier distinct, disons <code>mesFonctions.R</code>;</li>
<li>inclure en entête de tout programme R utilisant ces fonctions la commande <code>source(&quot;chemin/mesFonctions.R&quot;)</code>.</li>
</ul>
</div>
<div id="tests---objectif-1-obtenir-le-resultat-escompte" class="section level4">
<h4>Tests - Objectif 1 : obtenir le résultat escompté</h4>
<p>Appeler les fonctions en donnant en entrée des valeurs d’arguments pour lesquelles nous savons quel résultat nous devrions obtenir.</p>
<ul>
<li>Mini-exemples pour lesquels nous pouvons faire les calculs à la main pour trouver le résultat escompté.</li>
<li>Comparer les résultats de nos fonctions aux résultats de fonctions effectuant le même calcul, s’il en existe.</li>
<li>Comparer les résultats de nos fonctions à des résultats théoriques ou des résultats publiés dans des articles scientifiques, si applicable.</li>
</ul>
</div>
<div id="tests---objectif-2-correctement-gerer-les-exceptions" class="section level4">
<h4>Tests - Objectif 2 : correctement gérer les exceptions</h4>
<blockquote>
<p><strong>exception</strong> = situation anormale ou particulière qui requiert un traitement spécial</p>
</blockquote>
<p>Des exemples d’exceptions sont :</p>
<ul>
<li>des arguments incorrects fournis en entrée,</li>
<li>des résultats de calcul inattendus.</li>
</ul>
<p>Réaction à des exceptions : erreurs ou avertissements générés.</p>
<p>Différents types de <strong>conditions en R</strong> :</p>
<ul>
<li><strong>Erreur</strong> : exécution interrompue, message d’erreur affiché.</li>
<li><strong>Avertissement</strong> : exécution non interrompue, message d’avertissement affiché pour signaler un problème potentiel.</li>
<li><strong>Message</strong> (moins fréquent) : exécution non interrompue, message affiché pour apporter une information supplémentaire.</li>
</ul>
</div>
<div id="formaliser-des-tests-avec-le-package-testthat-1" class="section level4">
<h4>Formaliser des tests avec le package testthat</h4>
<p>Fonctions pour l’écriture, l’organisation et l’exécution automatique de tests unitaires en R :</p>
<ul>
<li><p>fonction d’écriture (un appel à une de ces fonctions = un test unitaire) :</p>
<ul>
<li><code>expect_equal</code>,</li>
<li><code>expect_error</code>,</li>
<li><code>expect_warning</code>,</li>
<li><code>expect_true</code>,</li>
<li>etc.</li>
</ul></li>
<li><p>fonction d’organisation : <code>context</code>, <code>test_that</code></p></li>
<li><p>fonction d’exécution : <code>test_file</code>, <code>test_dir</code>, etc.</p></li>
</ul>
</div>
<div id="debogage-1" class="section level4">
<h4>Débogage</h4>
<blockquote>
<p><strong>débogage</strong> = processus méthodique pour trouver et régler des bogues informatiques</p>
</blockquote>
<blockquote>
<p><strong>bogues</strong> = anomalies de fonctionnement d’un programme</p>
</blockquote>

<p>Outils de débogage en R :</p>
<ol style="list-style-type: decimal">
<li><code>traceback()</code> : retourne la séquence des appels de fonctions provoquant une erreur</li>
<li>fonction <code>browser</code> (seule, avec <code>trace</code> ou avec <code>debug</code>) : permet
<ul>
<li>d’interrompre l’exécution d’une fonction,</li>
<li>de donner accès à l’environnement d’exécution de la fonction et</li>
<li>d’exécuter le corps de la fonction une commande à la fois;</li>
</ul></li>
<li>option <code>error</code> : débogage post mortem<br />
donne accès à l’environnement d’exécution de la fonction au moment de la génération d’une erreur.</li>
<li><code>print</code> et <code>cat</code> : imprime une trace des calculs</li>
</ol>
</div>
<div id="gestion-dexceptions-1" class="section level4">
<h4>Gestion d’exceptions</h4>
<p><em>Produire des erreurs et des avertissements</em></p>
<ul>
<li>générer une erreur : <code>stop</code>, <code>stopifnot</code>, <code>match.arg</code>;</li>
<li>générer un avertissement : <code>warning</code>.</li>
</ul>
<p><em>Manipuler des erreurs et des avertissements</em></p>
<ul>
<li>attraper des erreurs et les manipuler : <code>try</code>;</li>
<li>modifier la gestion des avertissements dans la session R :<br />
option globale <code>warn</code>;</li>
<li>ignorer des avertissements : <code>suppressWarnings</code>.</li>
</ul>
<hr />
</div>
</div>
<div id="references" class="section level1">
<h1>Références</h1>
<p>Tests :</p>
<ul>
<li>Wickham, H., RStudio et R Core team (2018). testthat: Unit Testing for R. R package version 2.0.1. <a href="https://CRAN.R-project.org/package=testthat" class="uri">https://CRAN.R-project.org/package=testthat</a>
<ul>
<li>documentation du package : fiches d’aide du package, <a href="http://testthat.r-lib.org/" class="uri">http://testthat.r-lib.org/</a></li>
<li>Wickham, H. (2015). <em>R packages</em>. O’Reilly. Chapitre 7. <a href="http://r-pkgs.had.co.nz/tests.html" class="uri">http://r-pkgs.had.co.nz/tests.html</a></li>
</ul></li>
</ul>
<p>Débogage :</p>
<ul>
<li>Matloff, N. (2011). <em>The Art of R Programming : A Tour of Statistical Software Design</em>. No Starch Press. Chapitre 13.</li>
<li>Wickham, H. (2014). <em>Advanced R</em>. CRC Press. Chapitre 9. <a href="http://adv-r.had.co.nz/Exceptions-Debugging.html" class="uri">http://adv-r.had.co.nz/Exceptions-Debugging.html</a> (ou chapitre 8 de la deuxième édition en développement <a href="https://adv-r.hadley.nz/debugging.html" class="uri">https://adv-r.hadley.nz/debugging.html</a>).</li>
<li>R Core Team (2018). <em>Writing R Extensions</em>. R Foundation for Statistical Computing. Chapitre 4. <a href="http://cran.r-project.org/doc/manuals/r-release/R-exts.pdf" class="uri">http://cran.r-project.org/doc/manuals/r-release/R-exts.pdf</a></li>
</ul>
</div>
