---
title: "Structures de données en R"
author: "Sophie Baillargeon, Université Laval"
date: "2019-01-14"
weight: 1
slug: "structures_r"
categories: ["cours_2019-01-22"]
categories_weight: 1
lastmodifierdisplayname : "Sophie Baillargeon"
lastmodifieremail: "sophie.baillargeon@mat.ulaval.ca"
output:
  pdf_document:
    toc: yes
    toc_depth: 3
  blogdown::html_page:
    toc: true
header-includes:
- \usepackage[french]{babel}
- \frenchbsetup{StandardLayout}
- \hypersetup{colorlinks=true, urlcolor = {blue}, linkcolor = {blue}}
---





<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#differents-types-dobjets-r-servant-de-structure-de-donnees">Différents types d’objets R servant de structure de données</a><ul>
<li><a href="#exemple-de-vecteur">Exemple de vecteur</a></li>
<li><a href="#exemple-de-matrice">Exemple de matrice</a></li>
<li><a href="#exemple-darray">Exemple d’array</a></li>
<li><a href="#exemple-de-liste">Exemple de liste</a></li>
<li><a href="#exemple-de-data-frame">Exemple de data frame</a></li>
<li><a href="#exemple-de-facteur">Exemple de facteur</a></li>
</ul></li>
<li><a href="#obtention-dinformations-sur-les-objets">Obtention d’informations sur les objets</a><ul>
<li><a href="#attributs-des-objets">Attributs des objets</a></li>
</ul></li>
<li><a href="#differents-types-de-donnees">Différents types de données</a><ul>
<li><a href="#exemple-de-donnee-reelle">Exemple de donnée réelle</a></li>
<li><a href="#exemple-de-donnee-entiere">Exemple de donnée entière</a></li>
<li><a href="#exemple-de-donnee-caractere">Exemple de donnée caractère</a></li>
<li><a href="#exemple-de-donnee-logique">Exemple de donnée logique</a></li>
<li><a href="#donnees-manquantes">Données manquantes</a></li>
</ul></li>
<li><a href="#extraction-delements">Extraction d’éléments</a><ul>
<li><a href="#operateurs-dindicage">Opérateurs d’indiçage</a></li>
<li><a href="#fonctions-dextraction">Fonctions d’extraction</a></li>
</ul></li>
<li><a href="#remplacement-delements">Remplacement d’éléments</a></li>
</ul></li>
<li><a href="#le-vecteur">Le vecteur</a><ul>
<li><a href="#obtention-dinformations-sur-un-vecteur">Obtention d’informations sur un vecteur</a></li>
<li><a href="#fonctions-de-creation-dun-vecteur">Fonctions de création d’un vecteur</a><ul>
<li><a href="#fonction-c">Fonction <code>c</code></a></li>
<li><a href="#fonction-vector">Fonction <code>vector</code></a></li>
<li><a href="#fonction-as.vector">Fonction <code>as.vector</code></a></li>
<li><a href="#fonction-rep">Fonction <code>rep</code></a></li>
<li><a href="#la-creation-de-sequences-avec-loperateur-ou-la-fonction-seq">La création de séquences avec l’opérateur <code>':'</code> ou la fonction <code>seq</code></a></li>
</ul></li>
<li><a href="#fonctions-de-concatenation-de-vecteurs">Fonctions de concaténation de vecteurs</a><ul>
<li><a href="#fonction-c-1">Fonction <code>c</code></a></li>
<li><a href="#fonction-append">Fonction <code>append</code></a></li>
</ul></li>
<li><a href="#ajout-de-metadonnees-dans-un-vecteur">Ajout de métadonnées dans un vecteur</a></li>
<li><a href="#extraction-de-donnees-dans-un-vecteur">Extraction de données dans un vecteur</a></li>
<li><a href="#les-vecteurs-de-chaines-de-caracteres">Les vecteurs de chaînes de caractères</a><ul>
<li><a href="#les-fonctions-paste-et-paste0">Les fonctions <code>paste</code> et <code>paste0</code></a></li>
</ul></li>
</ul></li>
<li><a href="#la-matrice">La matrice</a><ul>
<li><a href="#obtention-dinformations-sur-une-matrice">Obtention d’informations sur une matrice</a></li>
<li><a href="#fonctions-de-creation-dune-matrice">Fonctions de création d’une matrice</a><ul>
<li><a href="#fonction-matrix">Fonction <code>matrix</code></a></li>
<li><a href="#fonction-as.matrix">Fonction <code>as.matrix</code></a></li>
<li><a href="#fonctions-rbind-et-cbind">Fonctions <code>rbind</code> et <code>cbind</code></a></li>
</ul></li>
<li><a href="#fonctions-de-concatenation-de-matrices">Fonctions de concaténation de matrices</a><ul>
<li><a href="#fonctions-rbind-et-cbind-1">Fonctions <code>rbind</code> et <code>cbind</code></a></li>
</ul></li>
<li><a href="#ajout-de-metadonnees-dans-une-matrice">Ajout de métadonnées dans une matrice</a></li>
<li><a href="#extraction-de-donnees-dans-une-matrice">Extraction de données dans une matrice</a></li>
</ul></li>
<li><a href="#larray">L’array</a><ul>
<li><a href="#obtention-dinformations-sur-un-array">Obtention d’informations sur un array</a></li>
<li><a href="#fonction-de-creation-dun-array">Fonction de création d’un array</a><ul>
<li><a href="#fonction-array">Fonction <code>array</code></a></li>
<li><a href="#fonction-as.array">Fonction <code>as.array</code></a></li>
</ul></li>
<li><a href="#ajout-de-metadonnees-dans-un-array">Ajout de métadonnées dans un array</a></li>
<li><a href="#extraction-de-donnees-dans-un-array">Extraction de données dans un array</a></li>
</ul></li>
<li><a href="#la-liste">La liste</a><ul>
<li><a href="#obtention-dinformations-sur-une-liste">Obtention d’informations sur une liste</a></li>
<li><a href="#fonctions-de-creation-dune-liste">Fonctions de création d’une liste</a><ul>
<li><a href="#fonction-list">Fonction <code>list</code></a></li>
<li><a href="#fonction-as.list">Fonction <code>as.list</code></a></li>
<li><a href="#fonction-vector-1">Fonction <code>vector</code></a></li>
</ul></li>
<li><a href="#fonction-de-concatenation-de-listes">Fonction de concaténation de listes</a><ul>
<li><a href="#fonction-c-2">Fonction <code>c</code></a></li>
</ul></li>
<li><a href="#ajout-de-metadonnees-dans-une-liste">Ajout de métadonnées dans une liste</a></li>
<li><a href="#extraction-delements-dans-une-liste">Extraction d’éléments dans une liste</a></li>
</ul></li>
<li><a href="#le-data-frame">Le data frame</a><ul>
<li><a href="#jeux-de-donnees">Jeux de données</a><ul>
<li><a href="#definitions-relatives-a-un-jeu-de-donnees">Définitions relatives à un jeu de données</a></li>
<li><a href="#representation-dun-jeu-de-donnees-en-r">Représentation d’un jeu de données en R</a></li>
</ul></li>
<li><a href="#obtention-dinformations-sur-un-data-frame">Obtention d’informations sur un data frame</a></li>
<li><a href="#fonction-de-creation-dun-data-frame">Fonction de création d’un data frame</a><ul>
<li><a href="#fonction-data.frame">Fonction <code>data.frame</code></a></li>
<li><a href="#fonction-as.data.frame">Fonction <code>as.data.frame</code></a></li>
</ul></li>
<li><a href="#fonctions-de-concatenation-de-data-frame">Fonctions de concaténation de data frame</a><ul>
<li><a href="#fonction-data.frame-1">Fonction <code>data.frame</code></a></li>
<li><a href="#fonctions-rbind-et-cbind-2">Fonctions <code>rbind</code> et <code>cbind</code></a></li>
</ul></li>
<li><a href="#ajout-de-metadonnees-dans-un-data-frame">Ajout de métadonnées dans un data frame</a></li>
<li><a href="#extraction-delements-dun-data-frame">Extraction d’éléments d’un data frame</a></li>
<li><a href="#extensions-du-data-frame">Extensions du data frame</a><ul>
<li><a href="#le-tibble">Le tibble</a></li>
<li><a href="#le-data-table">Le data table</a></li>
</ul></li>
</ul></li>
<li><a href="#le-facteur">Le facteur</a><ul>
<li><a href="#obtention-dinformations-sur-un-facteur.">Obtention d’informations sur un facteur.</a></li>
<li><a href="#fonction-de-creation-dun-facteur">Fonction de création d’un facteur</a><ul>
<li><a href="#fonctions-factor-et-as.factor">Fonctions <code>factor</code> et <code>as.factor</code></a></li>
</ul></li>
<li><a href="#fonction-de-modification-dun-facteur">Fonction de modification d’un facteur</a><ul>
<li><a href="#fonction-levels">Fonction <code>levels</code></a></li>
</ul></li>
<li><a href="#ajout-de-metadonnees-dans-un-facteur">Ajout de métadonnées dans un facteur</a></li>
<li><a href="#extraction-delements-dun-facteur">Extraction d’éléments d’un facteur</a></li>
<li><a href="#les-facteurs-ordonnes">Les facteurs ordonnés</a></li>
</ul></li>
<li><a href="#conversions">Conversions de type de données</a></li>
<li><a href="#synthese">Synthèse</a></li>
<li><a href="#references">Références</a></li>
</ul>
</div>

<hr />

<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>Le point de départ d’une analyse de données en R est d’avoir accès aux données. Ces données doivent être stockées dans un ou des objets R. Pour utiliser R, il faut donc d’abord connaître les différents types d’objets pouvant servir de « contenant à données » et savoir travailler avec ces objets.</p>
<div id="differents-types-dobjets-r-servant-de-structure-de-donnees" class="section level2">
<h2>Différents types d’objets R servant de structure de données</h2>
<p>Le tableau suivant présente les différents types d’objets R servant de structure de données offerts dans le R de base, selon leur nombre de dimensions.</p>
<table>
<thead>
<tr class="header">
<th>Nombre de dimensions</th>
<th>Objets atomiques</th>
<th>Objets récursifs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><strong>vecteur</strong></td>
<td><strong>liste</strong></td>
</tr>
<tr class="even">
<td>2</td>
<td><strong>matrice</strong></td>
<td><strong>data frame</strong></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\vdots\)</span></td>
<td><span class="math inline">\(\vdots\)</span></td>
<td></td>
</tr>
<tr class="even">
<td>n</td>
<td><strong>array</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p>Aux 5 types d’objets de ce tableau, il faut ajouter les <strong>facteurs</strong>. Ils sont une généralisation des vecteurs, utiles pour stocker des données catégoriques.</p>
<p>D’autres types d’objets existent dans le R de base, mais ne servent pas de structure de données, par exemple les fonctions, les expressions (comme les formules), etc.</p>
<p>Les objets dont les éléments sont contraints d’être des données toutes du même type sont qualifiés de « <strong>atomiques</strong> », alors que les autres sont qualifiés de « <strong>récursifs</strong> ». En fait, les listes sont parfois appelées « vecteurs récursifs » dans la documentation de R. Ici, le mot vecteur, non accompagné de l’adjectif récursif, fera toujours référence à un vecteur atomique.</p>
<p>Les éléments des objets récursifs sont d’autres objets. Pour une liste, ils peuvent être n’importe quoi : des vecteurs, des facteurs, des matrices, des arrays, des listes, des data frames, des fonctions, des expressions, etc. Pour un data frame, ils sont typiquement des vecteurs ou des facteurs, tous de même longueur.</p>
<p>Illustrons maintenant ces différents types d’objets servant de structure de données. De l’information détaillée sur chaque type d’objet est présentée plus loin.</p>
<div id="exemple-de-vecteur" class="section level3">
<h3>Exemple de vecteur</h3>
<p>Le vecteur est l’objet le plus simple. Voici un exemple de vecteur :</p>
<pre class="r"><code>vec</code></pre>
<pre><code>## [1] 3.5 7.8 9.9 5.7</code></pre>
<pre class="r"><code>str(vec)</code></pre>
<pre><code>##  num [1:4] 3.5 7.8 9.9 5.7</code></pre>
<p>Il pourrait être représenté comme suit : <img src="fig/VecteurHoriz.png" />, ou encore à la verticale : <img src="fig/VecteurVerti.png" />.</p>
<p>Il n’a qu’une dimension et ses éléments (représentés par les cercles bleus) sont des données toutes du même type.</p>
</div>
<div id="exemple-de-matrice" class="section level3">
<h3>Exemple de matrice</h3>
<p>La matrice est une généralisation à 2 dimensions du vecteur. Voici un exemple de matrice :</p>
<pre class="r"><code>mat</code></pre>
<pre><code>##       [,1]  [,2]  [,3]
## [1,]  TRUE FALSE FALSE
## [2,]  TRUE  TRUE FALSE
## [3,] FALSE  TRUE  TRUE
## [4,]  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>str(mat)</code></pre>
<pre><code>##  logi [1:4, 1:3] TRUE TRUE FALSE TRUE FALSE TRUE ...</code></pre>
<p>Elle pourrait être représentée comme suit : <img src="fig/Matrice.png" />.</p>
<p>Comme pour un vecteur, tous ses éléments doivent être du même type.</p>
</div>
<div id="exemple-darray" class="section level3">
<h3>Exemple d’array</h3>
<p>Le dernier objet atomique est l’array, qui généralise le vecteur et la matrice à un nombre quelconque de dimensions. Voici un exemple d’array à 3 dimensions :</p>
<pre class="r"><code>arr</code></pre>
<pre><code>## , , 1
## 
##      [,1] [,2] [,3]
## [1,]    2    3    6
## [2,]    4    1    3
## 
## , , 2
## 
##      [,1] [,2] [,3]
## [1,]    9    6    8
## [2,]    2    3    0
## 
## , , 3
## 
##      [,1] [,2] [,3]
## [1,]    5    2    7
## [2,]    3    8    1
## 
## , , 4
## 
##      [,1] [,2] [,3]
## [1,]    2    5    8
## [2,]    6    3    5</code></pre>
<pre class="r"><code>str(arr)</code></pre>
<pre><code>##  num [1:2, 1:3, 1:4] 2 4 3 1 6 3 9 2 6 3 ...</code></pre>
<p>Il pourrait être représenté comme suit : <img src="fig/Array.png" />.</p>
</div>
<div id="exemple-de-liste" class="section level3">
<h3>Exemple de liste</h3>
<p>Une liste est pour sa part un objet récursif : elle contient d’autres objets, de types quelconques. Voici un exemple de liste :</p>
<pre class="r"><code>liste</code></pre>
<pre><code>## [[1]]
##      [,1] [,2]
## [1,]    2    3
## [2,]    4    1
## 
## [[2]]
## [[2]][[1]]
## [1] 2 3
## 
## [[2]][[2]]
## [1] 8
## 
## 
## [[3]]
##   V1 V2
## 1  2  1
## 2  4  5
## 3  3  3</code></pre>
<pre class="r"><code>str(liste)</code></pre>
<pre><code>## List of 3
##  $ : num [1:2, 1:2] 2 4 3 1
##  $ :List of 2
##   ..$ : num [1:2] 2 3
##   ..$ : num 8
##  $ :&#39;data.frame&#39;:    3 obs. of  2 variables:
##   ..$ V1: num [1:3] 2 4 3
##   ..$ V2: num [1:3] 1 5 3</code></pre>
<p>Elle pourrait être représentée comme suit : <img src="fig/Liste.png" />.</p>
<p>Les éléments d’une liste (séparés par une ligne pointillée dans la figure) ne sont pas de simples données comme dans un vecteur. Il s’agit d’autres objets. Dans cet exemple, la liste contient même une autre liste (deuxième élément).</p>
</div>
<div id="exemple-de-data-frame" class="section level3">
<h3>Exemple de data frame</h3>
<p>Le data frame est en quelque sorte un type particulier de liste, mais il partage aussi des caractéristiques avec les matrices, étant réputé posséder 2 dimensions (des lignes et des colonnes). Ses éléments sont des objets contraints d’être de dimensions concordantes. Dans la grande majorité des cas, les éléments sont des vecteurs ou des facteurs de même longueur, formant les colonnes du data frame. Voici un exemple de data frame.</p>
<pre class="r"><code>dat</code></pre>
<pre><code>##    V1         V2    V3
## 1 3.5      matin  TRUE
## 2 7.8 après-midi  TRUE
## 3 9.9       soir FALSE
## 4 5.7       nuit  TRUE</code></pre>
<pre class="r"><code>str(dat)</code></pre>
<pre><code>## &#39;data.frame&#39;:    4 obs. of  3 variables:
##  $ V1: num  3.5 7.8 9.9 5.7
##  $ V2: chr  &quot;matin&quot; &quot;après-midi&quot; &quot;soir&quot; &quot;nuit&quot;
##  $ V3: logi  TRUE TRUE FALSE TRUE</code></pre>
<p>Il pourrait être illustré comme suit : <img src="fig/DataFrame.png" />.</p>
<p>La première dimension d’un data frame typique est la longueur commune des objets qu’il contient (4 dans l’exemple) et sa deuxième dimension est le nombre d’objets qu’il contient (dans l’exemple, le data frame contient 3 vecteurs).</p>
<p>Les data frames ont été créés spécialement pour l’analyse statistique de données. Ils représentent des tableaux de données dans lesquels les lignes sont des observations et les colonnes des variables (des variables au sens statistique et non au sens informatique). Le data frame fait donc penser à une matrice. Ses dimensions sont vues comme un nombre de lignes ou d’observations et un nombre de colonnes ou de variables. Cependant, contrairement à une matrice, les données dans les différentes colonnes d’un data frame n’ont pas à être du même type.</p>
</div>
<div id="exemple-de-facteur" class="section level3">
<h3>Exemple de facteur</h3>
<p>Un autre type d’objet propre à la statistique a été créé en R : le facteur. Ce type d’objet est utilisé pour stocker les valeurs observées d’une variable catégorique.</p>
<pre class="r"><code>fac</code></pre>
<pre><code>## [1] 5 2 5 5
## Levels: 2 5</code></pre>
<pre class="r"><code>str(fac)</code></pre>
<pre><code>##  Factor w/ 2 levels &quot;2&quot;,&quot;5&quot;: 2 1 2 2</code></pre>
<p>Il s’agit d’une généralisation du vecteur.</p>
</div>
</div>
<div id="obtention-dinformations-sur-les-objets" class="section level2">
<h2>Obtention d’informations sur les objets</h2>
<p>Pour avoir accès aux informations relatives à un objet, il existe une série de fonctions utiles, par exemple :</p>
<ul>
<li>type de l’objet : <code>is.</code>(<code>vector</code>/<code>matrix</code>/<code>array</code>/<code>list</code>/<code>data.frame</code>/<code>factor</code>/…);</li>
<li>attributs de l’objet : <code>attributes</code>, <code>attr</code> et les fonctions raccourcies <code>dim</code>, <code>nrow</code>, <code>ncol</code>, <code>names</code>, <code>dimnames</code>, <code>rownames</code>, <code>colnames</code>.</li>
<li>type des éléments : <code>typeof</code>, <code>mode</code>, <code>is.</code>(<code>numeric</code>/<code>character</code>/<code>logical</code>/…);</li>
<li>nombre d’éléments : <code>length</code>;</li>
</ul>
<p>Ces fonctions seront illustrées plus loin. Notons que les fonction <code>typeof</code> et <code>mode</code> retournent, pour un objet atomique, le type des données en éléments, et retournent <code>&quot;list&quot;</code> pour un objet récursif.</p>
<div id="attributs-des-objets" class="section level3">
<h3>Attributs des objets</h3>
<p>Les structures de données R peuvent posséder des attributs, qui servent à contenir des informations supplémentaires concernant les données stockées dans l’objet. Ces informations supplémentaires sont parfois appelées métadonnées.</p>
<p>Par exemple, une matrice ou un array possède toujours un attribut portant le nom <code>dim</code> contenant la dimension de l’objet.</p>
<pre class="r"><code>attributes(mat)</code></pre>
<pre><code>## $dim
## [1] 4 3</code></pre>
<p>Le fonction <code>attributes</code> retourne une liste contenant tous les attributs d’un objet, nommés. La fonction <code>attr</code> permet d’accéder à la valeur d’un attribut particulier, identifié par son nom.</p>
<pre class="r"><code>attr(mat, &quot;dim&quot;)</code></pre>
<pre><code>## [1] 4 3</code></pre>
<p>Pour certains attributs communs, tels que <code>dim</code>, il existe même des fonctions spécifiques pour obtenir leur valeur. Par exemple :</p>
<ul>
<li><code>dim</code> retourne l’attribut <code>dim</code> d’un objet,</li>
</ul>
<pre class="r"><code>dim(mat)</code></pre>
<pre><code>## [1] 4 3</code></pre>
<ul>
<li><code>nrow</code> retourne la taille de la première dimension d’un objet,</li>
</ul>
<pre class="r"><code>nrow(mat)</code></pre>
<pre><code>## [1] 4</code></pre>
<ul>
<li><code>ncol</code> retourne la taille de la deuxième dimension d’un objet,</li>
</ul>
<pre class="r"><code>ncol(mat)</code></pre>
<pre><code>## [1] 3</code></pre>
<p>Certains types d’objets, tels que le vecteur, ne possèdent pas d’attributs par défaut.</p>
<pre class="r"><code>attributes(vec)</code></pre>
<pre><code>## NULL</code></pre>
<p>Il est cependant toujours possible d’ajouter des attributs à un objet, portant le nom de notre choix. Les fonctions qui retournent les valeurs d’attributs peuvent aussi servir à initialiser ou remplacer les valeurs des attributs. Pour ce faire, il suffit d’accompagner la commande d’extraction de l’attribut d’un opérateur d’assignation (<code>&lt;-</code>) suivi de la valeur souhaitée, comme dans l’exemple ci-dessus.</p>
<pre class="r"><code>attr(vec, &quot;description&quot;) &lt;- &quot;exemple de vecteur&quot;
str(vec)</code></pre>
<pre><code>##  num [1:4] 3.5 7.8 9.9 5.7
##  - attr(*, &quot;description&quot;)= chr &quot;exemple de vecteur&quot;</code></pre>
<p>Pour retirer un attribut, il faut lui assigner la valeur spécial <code>NULL</code>.</p>
<pre class="r"><code>attr(vec, &quot;description&quot;) &lt;- NULL
str(vec)</code></pre>
<pre><code>##  num [1:4] 3.5 7.8 9.9 5.7</code></pre>
</div>
</div>
<div id="differents-types-de-donnees" class="section level2">
<h2>Différents types de données</h2>
<p>Les éléments contenus dans les objets atomiques sont des données d’un des types suivants :</p>
<ul>
<li>réel,</li>
<li>entier,</li>
<li>caractère,</li>
<li>logique,</li>
<li>ainsi que quelques autres types qui ne seront pas utilisés dans le cours, tels que « complexe » et « brut ».</li>
</ul>
<p>Voici un exemple de chacun des types.</p>
<div id="exemple-de-donnee-reelle" class="section level3">
<h3>Exemple de donnée réelle</h3>
<p>Une donnée réelle est un nombre réel, par exemple</p>
<pre class="r"><code>re &lt;- 5.8
re</code></pre>
<pre><code>## [1] 5.8</code></pre>
<p>Le terme informatique en anglais pour une donnée réelle est « double ».</p>
<pre class="r"><code>typeof(re)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<p>Par contre, en R, la distinction entre les réels et les entiers est peu utilisée. R simplifie les choses et dit parfois d’une donnée réelle qu’il s’agit d’une donnée numérique.</p>
<pre class="r"><code>str(re)</code></pre>
<pre><code>##  num 5.8</code></pre>
</div>
<div id="exemple-de-donnee-entiere" class="section level3">
<h3>Exemple de donnée entière</h3>
<p>Une donnée entière est un nombre entier (en anglais <em>integer</em>), donc sans partie décimale.</p>
<pre class="r"><code>en &lt;- 1L
en</code></pre>
<pre><code>## [1] 1</code></pre>
<p>Dans cet exemple, le caractère <code>L</code> après le nombre indique à R que nous désirons qu’il le considère comme un entier.</p>
<pre class="r"><code>str(en)</code></pre>
<pre><code>##  int 1</code></pre>
<pre class="r"><code>typeof(en)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>is.numeric(en)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>is.integer(en)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>is.double(en)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>Sans ce caractère <code>L</code>, la majorité des fonctions en R traite par défaut les nombres comme des réels.</p>
<pre class="r"><code>un &lt;- 1
un</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>str(un)</code></pre>
<pre><code>##  num 1</code></pre>
<pre class="r"><code>typeof(un)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<pre class="r"><code>is.numeric(un)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>is.integer(un)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>is.double(un)</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="exemple-de-donnee-caractere" class="section level3">
<h3>Exemple de donnée caractère</h3>
<p>Une donnée caractère est une chaîne de caractères.</p>
<pre class="r"><code>ca &lt;- &quot;Hello world!&quot;
ca</code></pre>
<pre><code>## [1] &quot;Hello world!&quot;</code></pre>
<pre class="r"><code>str(ca)</code></pre>
<pre><code>##  chr &quot;Hello world!&quot;</code></pre>
<pre class="r"><code>typeof(ca)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<p>Ce sont les guillemets qui indiquent à R qu’il s’agit d’une donnée de type caractère.</p>
<pre class="r"><code>str(&quot;1&quot;)</code></pre>
<pre><code>##  chr &quot;1&quot;</code></pre>
</div>
<div id="exemple-de-donnee-logique" class="section level3">
<h3>Exemple de donnée logique</h3>
<p>Une donnée logique est simplement <code>TRUE</code> ou <code>FALSE</code>.</p>
<pre class="r"><code>lo &lt;- TRUE
lo</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>str(lo)</code></pre>
<pre><code>##  logi TRUE</code></pre>
<pre class="r"><code>typeof(lo)</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<p>Attention : <code>&quot;TRUE&quot;</code> est une chaîne de caractères et non une donnée logique, à cause des guillemets bien sûr.</p>
<pre class="r"><code>str(&quot;TRUE&quot;)</code></pre>
<pre><code>##  chr &quot;TRUE&quot;</code></pre>
</div>
<div id="donnees-manquantes" class="section level3">
<h3>Données manquantes</h3>
<p>Peu importe le type de données, une donnée manquante est représentée en R par la constante <code>NA</code> (pour « Not Available »).</p>
<pre class="r"><code>NA</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Ce n’est pas la même chose que <code>NaN</code> qui signifie plutôt « Not a Number ».</p>
<pre class="r"><code>0/0</code></pre>
<pre><code>## [1] NaN</code></pre>
<p>L’existence d’une constante pour représenter les données manquantes est une autre particularité du langage R spécifique à l’analyse de données.</p>
</div>
</div>
<div id="extraction-delements" class="section level2">
<h2>Extraction d’éléments</h2>
<p>L’extraction d’éléments dans un jeu de données est une opération très usuelle au cours d’une analyse de données. Par exemple, il arrive souvent de vouloir faire un certain calcul seulement sur une partie des données plutôt que sur le jeu de données entier. Il faut alors prélever les données concernées.</p>
<div id="operateurs-dindicage" class="section level3">
<h3>Opérateurs d’indiçage</h3>
<p>Il y a trois opérateurs d’indiçage d’éléments d’un objet R : <code>[</code>, <code>[[</code> et <code>$</code>. Ces opérateurs permettent d’extraire des éléments s’ils sont utilisés seuls, et ils permettent de remplacer des éléments s’ils sont utilisés en combinaison avec une assignation.</p>
<div id="versus-et" class="section level4">
<h4><code>[</code> versus <code>[[</code> et <code>$</code></h4>
<p>L’opérateur <code>[</code> effectue de l’extraction <strong>d’éléments</strong> (potentiellement plus d’un) en <strong>préservant presque toujours la structure</strong> de l’objet (l’objet produit en résultat de l’extraction est, sauf exception, du même type que l’objet d’origine et conserve la majorité de ses attributs).</p>
<p>Les opérateurs <code>[[</code> et <code>$</code> permettent de référer à <strong>un seul élément</strong> et ils <strong>simplifient l’objet</strong> lors d’une extraction (retirent des attributs pour les objets atomiques et sortent de l’objet principal pour un objet récursif).</p>
<p>Voici des exemples.</p>
<ul>
<li>extraction de deux éléments d’un objet atomique avec <code>[</code></li>
</ul>
<pre class="r"><code>vec</code></pre>
<pre><code>## [1] 3.5 7.8 9.9 5.7</code></pre>
<pre class="r"><code>vec[c(2, 4)]</code></pre>
<pre><code>## [1] 7.8 5.7</code></pre>
<p>Dans cet exemple, la fonction <code>c</code> sert à créer un vecteur contenant les positions des éléments à extraire.</p>
<p> </p>
<ul>
<li>extraction d’un élément d’un objet récursif avec <code>[</code>, en préservant la structure de l’objet d’origine</li>
</ul>
<pre class="r"><code>str(liste)</code></pre>
<pre><code>## List of 3
##  $ : num [1:2, 1:2] 2 4 3 1
##  $ :List of 2
##   ..$ : num [1:2] 2 3
##   ..$ : num 8
##  $ :&#39;data.frame&#39;:    3 obs. of  2 variables:
##   ..$ V1: num [1:3] 2 4 3
##   ..$ V2: num [1:3] 1 5 3</code></pre>
<pre class="r"><code>extrait1_liste &lt;- liste[1]
str(extrait1_liste)</code></pre>
<pre><code>## List of 1
##  $ : num [1:2, 1:2] 2 4 3 1</code></pre>
<p>Ici, le résultat est encore une liste, mais contenant un seul élément.</p>
<p> </p>
<ul>
<li>extraction d’un élément d’un objet récursif avec <code>[[</code>, avec perte de la structure de l’objet d’origine</li>
</ul>
<pre class="r"><code>extrait2_liste &lt;- liste[[1]]
str(extrait2_liste)</code></pre>
<pre><code>##  num [1:2, 1:2] 2 4 3 1</code></pre>
<p>Ici, le résultat est un vecteur, celui qui était stocké en position 1 dans l’objet <code>liste</code>.</p>
<p> </p>
<ul>
<li>extraction d’un élément d’un objet atomique avec perte d’un attribut</li>
</ul>
<pre class="r"><code>mat</code></pre>
<pre><code>##       [,1]  [,2]  [,3]
## [1,]  TRUE FALSE FALSE
## [2,]  TRUE  TRUE FALSE
## [3,] FALSE  TRUE  TRUE
## [4,]  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>attributes(mat)</code></pre>
<pre><code>## $dim
## [1] 4 3</code></pre>
<pre class="r"><code>extrait_mat &lt;- mat[[1, 3]]
extrait_mat</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>attributes(extrait_mat)</code></pre>
<pre><code>## NULL</code></pre>
<p> </p>
</div>
<div id="extractions-delements-dans-un-objet-a-plusieurs-dimensions" class="section level4">
<h4>Extractions d’éléments dans un objet à plusieurs dimensions</h4>
<p>Les opérateurs <code>[</code> et <code>[[</code> prennent en entrée un argument pour chacune des dimensions d’un objet. Par exemple, pour l’array à 3 dimensions <code>arr</code>, la commande suivante extrait un seul élément, dont la position est identifiée par les valeurs fournies en entrée aux arguments de <code>[</code>.</p>
<pre class="r"><code>arr[2, 1, 3]</code></pre>
<pre><code>## [1] 3</code></pre>
</div>
<div id="specificite-de-loperateur" class="section level4">
<h4>Spécificité de l’opérateur <code>$</code></h4>
<p>L’opérateur <code>$</code> fonctionne seulement avec les objets récursifs (une liste ou un data frame) dont les éléments sont nommés. Il doit être suivi du nom de l’élément à extraire. Ce nom n’a pas besoin d’être encadré de guillemets s’il ne contient pas d’espaces.</p>
<p>Prenons par exemple le data frame <code>dat</code> observé précédemment. Nous ne l’avions peut-être pas remarqué, mais les éléments de <code>dat</code> sont nommés.</p>
<pre class="r"><code>str(dat)</code></pre>
<pre><code>## &#39;data.frame&#39;:    4 obs. of  3 variables:
##  $ V1: num  3.5 7.8 9.9 5.7
##  $ V2: chr  &quot;matin&quot; &quot;après-midi&quot; &quot;soir&quot; &quot;nuit&quot;
##  $ V3: logi  TRUE TRUE FALSE TRUE</code></pre>
<pre class="r"><code>attr(dat, &quot;names&quot;)</code></pre>
<pre><code>## [1] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot;</code></pre>
<p>Alors il est possible d’extraire disons la deuxième colonne du data frame par la commande suivante.</p>
<pre class="r"><code>dat$V2</code></pre>
<pre><code>## [1] &quot;matin&quot;      &quot;après-midi&quot; &quot;soir&quot;       &quot;nuit&quot;</code></pre>
</div>
<div id="identification-de-lelement-a-extraire-avec-loperateur" class="section level4">
<h4>Identification de l’élément à extraire avec l’opérateur <code>[[</code></h4>
<p>Les arguments fournis à <code>[[</code> pour identifier l’unique élément à extraire peuvent recevoir des valeurs de type :</p>
<ul>
<li>numérique : un nombre spécifiant la position de l’élément selon la dimension, ou</li>
<li>caractère (dans le cas d’éléments nommés) : le nom de l’élément selon la dimension.</li>
</ul>
<p>Par exemple, le 2<sup>ième</sup> élément de la colonne nommée <code>&quot;V2&quot;</code> du data frame <code>dat</code> peut être extrait ainsi.</p>
<pre class="r"><code>dat[[2, &quot;V2&quot;]]</code></pre>
<pre><code>## [1] &quot;après-midi&quot;</code></pre>
<p>Si une valeur numérique non entière est fournie en argument, elle est tronquée vers 0, comme dans cet exemple.</p>
<pre class="r"><code>vec</code></pre>
<pre><code>## [1] 3.5 7.8 9.9 5.7</code></pre>
<pre class="r"><code>vec[[2.6]]</code></pre>
<pre><code>## [1] 7.8</code></pre>
</div>
<div id="identification-du-ou-des-elements-a-extraire-avec-loperateur" class="section level4">
<h4>Identification du ou des éléments à extraire avec l’opérateur <code>[</code></h4>
<p>Étant donné que l’opérateur <code>[</code> permet l’extraction de plusieurs éléments, il accepte une plus grande variété de types de valeurs. Voici les valeurs qu’il accepte en argument pour identifier les éléments à extraire :</p>
<ul>
<li>un ou des nombres positifs, dont les valeurs sont entre 1 et la taille de la dimension concernée :<br />
<em>positions des éléments à conserver</em>;</li>
<li>un ou des nombres négatifs, dont les valeurs sont entre 1 et la taille de la dimension concernée :<br />
<em><strong>-</strong> positions des éléments à exclure</em>;</li>
<li>un ou des chaînes de caractères (possible seulement si les éléments sont nommés) :<br />
<em>noms des éléments à conserver</em>;</li>
<li>vecteur de logiques (doit être de la même longueur que la dimension concernée) :<br />
<code>TRUE</code> <em>pour les éléments à conserver,</em> <code>FALSE</code> <em>pour ceux à exclure</em>;</li>
<li>rien : utile par exemple pour extraire une ligne d’une matrice ou d’un data frame en conservant toutes les colonnes.</li>
</ul>
<p>Voici quelques exemples :</p>
<ul>
<li>extraction d’éléments identifiés par leur position,</li>
</ul>
<pre class="r"><code>vec[c(1, 3)]</code></pre>
<pre><code>## [1] 3.5 9.9</code></pre>
<ul>
<li>extraction d’éléments par identification d’éléments à exclure,</li>
</ul>
<pre class="r"><code>vec[-c(2, 4)]</code></pre>
<pre><code>## [1] 3.5 9.9</code></pre>
<ul>
<li>extraction d’éléments identifiés par leurs noms,</li>
</ul>
<pre class="r"><code>dat[c(&quot;V1&quot;, &quot;V2&quot;)]</code></pre>
<pre><code>##    V1         V2
## 1 3.5      matin
## 2 7.8 après-midi
## 3 9.9       soir
## 4 5.7       nuit</code></pre>
<ul>
<li>extraction d’éléments identifiés par un vecteur logique,</li>
</ul>
<pre class="r"><code>vec[c(TRUE, FALSE, TRUE, FALSE)]</code></pre>
<pre><code>## [1] 3.5 9.9</code></pre>
<ul>
<li>extraction de tous les éléments selon une des dimensions.</li>
</ul>
<pre class="r"><code>dat[2, ]</code></pre>
<pre><code>##    V1         V2   V3
## 2 7.8 après-midi TRUE</code></pre>
<p> </p>
<p>Lors de l’indiçage à l’aide de valeurs numériques positives ou de chaînes de caractères, les valeurs peuvent se répéter. Dans ce cas, les éléments sont extraits autant de fois que la fréquence de leur identifiant, comme dans ces exemples.</p>
<pre class="r"><code>vec[c(1, 1, 1, 2, 2, 3, 3, 3, 3)]</code></pre>
<pre><code>## [1] 3.5 3.5 3.5 7.8 7.8 9.9 9.9 9.9 9.9</code></pre>
<pre class="r"><code>dat[, c(&quot;V2&quot;, &quot;V2&quot;)]</code></pre>
<pre><code>##           V2       V2.1
## 1      matin      matin
## 2 après-midi après-midi
## 3       soir       soir
## 4       nuit       nuit</code></pre>
<p>Les sections suivantes proposent plusieurs autres exemples d’extraction de données.</p>
</div>
<div id="argument-drop-de-loperateur" class="section level4">
<h4>Argument <code>drop</code> de l’opérateur <code>[</code></h4>
<p>L’opérateur <code>[</code> préserve la structure des objets, sauf dans quelques cas particuliers. Un de ces cas est l’extraction d’une colonne, complète ou partielle, d’un data frame. Le résultat de l’extraction est alors un vecteur ou un facteur, et non un autre data frame, comme dans cet exemple.</p>
<pre class="r"><code>str(dat)</code></pre>
<pre><code>## &#39;data.frame&#39;:    4 obs. of  3 variables:
##  $ V1: num  3.5 7.8 9.9 5.7
##  $ V2: chr  &quot;matin&quot; &quot;après-midi&quot; &quot;soir&quot; &quot;nuit&quot;
##  $ V3: logi  TRUE TRUE FALSE TRUE</code></pre>
<pre class="r"><code>str(dat[c(1, 3), 2])</code></pre>
<pre><code>##  chr [1:2] &quot;matin&quot; &quot;soir&quot;</code></pre>
<p>Il n’a pas ce comportement lors de l’extraction d’une ligne d’un data frame, car les éléments sur une même ligne ne sont pas nécessairement du même type.</p>
<pre class="r"><code>str(dat[2, ])</code></pre>
<pre><code>## &#39;data.frame&#39;:    1 obs. of  3 variables:
##  $ V1: num 7.8
##  $ V2: chr &quot;après-midi&quot;
##  $ V3: logi TRUE</code></pre>
<p>Cependant, avec les objets atomiques, l’opérateur <code>[</code> cherche toujours par défaut à réduire le plus possible la dimension de l’objet retourné. Ainsi, l’extraction suivante retourne un vecteur, alors que l’objet d’origine est un array à 3 dimensions.</p>
<pre class="r"><code>str(arr[, 2, 4])</code></pre>
<pre><code>##  num [1:2] 5 3</code></pre>
<p>Il est possible de contrôler ce comportement grâce à l’argument <code>drop</code>. Donner la valeur <code>FALSE</code> à cet argument empêche <code>[</code> de réduire la dimension du résultat retourné. Ainsi, la commande suivante retourne un array,</p>
<pre class="r"><code>str(arr[, 2, 4, drop = FALSE])</code></pre>
<pre><code>##  num [1:2, 1, 1] 5 3</code></pre>
<p>et la suivante un data frame.</p>
<pre class="r"><code>str(dat[c(1, 3), 2, drop = FALSE])</code></pre>
<pre><code>## &#39;data.frame&#39;:    2 obs. of  1 variable:
##  $ V2: chr  &quot;matin&quot; &quot;soir&quot;</code></pre>
</div>
</div>
<div id="fonctions-dextraction" class="section level3">
<h3>Fonctions d’extraction</h3>
<p>En plus des opérateurs d’indiçage, certaines fonctions permettent aussi d’extraire des éléments, notamment les fonctions <code>head</code>, <code>tail</code> et <code>subset</code>.</p>
<div id="fonction-head" class="section level4">
<h4>Fonction <code>head</code></h4>
<p>La fonction <code>head</code> extrait les premiers éléments d’un vecteur, d’une liste ou d’un facteur et les premières lignes d’une matrice ou d’un data frame. L’argument <code>n</code> permet de spécifier combien d’éléments ou de lignes extraire. Voici un exemple.</p>
<pre class="r"><code>head(vec, n = 2)</code></pre>
<pre><code>## [1] 3.5 7.8</code></pre>
<pre class="r"><code>head(dat, n = 3)</code></pre>
<pre><code>##    V1         V2    V3
## 1 3.5      matin  TRUE
## 2 7.8 après-midi  TRUE
## 3 9.9       soir FALSE</code></pre>
</div>
<div id="fonction-tail" class="section level4">
<h4>Fonction <code>tail</code></h4>
<p>À l’inverse, la fonction <code>tail</code> extrait les derniers éléments ou les dernières lignes.</p>
<pre class="r"><code>tail(vec, n = 3)</code></pre>
<pre><code>## [1] 7.8 9.9 5.7</code></pre>
<pre class="r"><code>tail(dat, n = 1)</code></pre>
<pre><code>##    V1   V2   V3
## 4 5.7 nuit TRUE</code></pre>
</div>
<div id="fonction-subset" class="section level4">
<h4>Fonction <code>subset</code></h4>
<p>La fonction <code>subset</code> est quant à elle une option de rechange à l’opérateur <code>[</code> utilisé avec des identifiants logiques. Elle fonctionne avec les vecteurs.</p>
<pre class="r"><code>subset(vec, subset = c(FALSE, TRUE, TRUE, TRUE))</code></pre>
<pre><code>## [1] 7.8 9.9 5.7</code></pre>
<p>Cependant, elle est surtout utile avec des matrices et des data frames. Avec un objet à deux dimensions, l’argument <code>subset</code> de la fonction du même nom sert à identifier les lignes à extraire et l’argument <code>select</code> à identifier les colonnes.</p>
<pre class="r"><code>subset(mat, subset = c(FALSE, TRUE, FALSE, TRUE), select = 1)</code></pre>
<pre><code>##      [,1]
## [1,] TRUE
## [2,] TRUE</code></pre>
<p>Lorsque le premier argument fourni en entrée à la fonction <code>subset</code> est un data frame, il est possible de référer aux colonnes de celui-ci directement par leurs noms dans les arguments <code>subset</code> et <code>select</code>. Il est aussi possible de retirer une colonne en utilisant l’opérateur <code>-</code> avant le nom de la colonne à retirer dans la valeur fournie à l’argument <code>select</code>.</p>
<pre class="r"><code>subset(dat, subset = c(TRUE, FALSE, TRUE, TRUE), select = - V3)</code></pre>
<pre><code>##    V1    V2
## 1 3.5 matin
## 3 9.9  soir
## 4 5.7  nuit</code></pre>
</div>
</div>
</div>
<div id="remplacement-delements" class="section level2">
<h2>Remplacement d’éléments</h2>
<p>En combinant une extraction à un opérateur d’assignation (<code>&lt;-</code>) suivi de nouvelles valeurs, des éléments d’un objet peuvent être remplacés. Voici un exemple.</p>
<pre class="r"><code>vec</code></pre>
<pre><code>## [1] 3.5 7.8 9.9 5.7</code></pre>
<pre class="r"><code>vec[3] &lt;- 6.1
vec</code></pre>
<pre><code>## [1] 3.5 7.8 6.1 5.7</code></pre>
<p>Il est tout à fait possible de remplacer plus d’un élément à la fois, comme dans l’exemple suivant.</p>
<pre class="r"><code>dat</code></pre>
<pre><code>##    V1         V2    V3
## 1 3.5      matin  TRUE
## 2 7.8 après-midi  TRUE
## 3 9.9       soir FALSE
## 4 5.7       nuit  TRUE</code></pre>
<pre class="r"><code>dat[c(1, 2), 3] &lt;- c(NA, FALSE)
dat</code></pre>
<pre><code>##    V1         V2    V3
## 1 3.5      matin    NA
## 2 7.8 après-midi FALSE
## 3 9.9       soir FALSE
## 4 5.7       nuit  TRUE</code></pre>
<p>Il est parfois utile d’exploiter la <strong>règle de recyclage</strong> lors du remplacement d’éléments dans un objet R. Cette règle permet des opérations sur des vecteurs qui ne sont pas de même longueur. Les éléments du vecteur le plus court sont répétés de façon à ce que ce vecteur devienne de la même longueur que le vecteur le plus long.</p>
<p>Par exemple, si une seule valeur de remplacement est fournie, mais que plusieurs éléments sont identifiés, alors ceux-ci seront tous remplacés par l’unique valeur fournie.</p>
<pre class="r"><code>vec[1:3] &lt;- 0.5
vec</code></pre>
<pre><code>## [1] 0.5 0.5 0.5 5.7</code></pre>
<p>Ça fonctionne aussi lorsque le vecteur le plus court est de longueur supérieure à 1. Dans l’exemple suivant, 4 valeurs sont identifiées à remplacer, mais 2 valeurs de remplacement sont fournies. Le vecteur de valeurs de remplacement est donc dupliqué.</p>
<pre class="r"><code>vec[1:4] &lt;- c(0.1, 0.2)
vec</code></pre>
<pre><code>## [1] 0.1 0.2 0.1 0.2</code></pre>
<p>Si la longueur du vecteur le plus long n’est pas un multiple de la longueur du vecteur le plus court, ça fonctionne encore, mais un avertissement est émis, comme dans cet exemple.</p>
<pre class="r"><code>vec[1:3] &lt;- c(2.0, 4.9)</code></pre>
<pre><code>## Warning in vec[1:3] &lt;- c(2, 4.9): number of items to replace is not a
## multiple of replacement length</code></pre>
<pre class="r"><code>vec</code></pre>
<pre><code>## [1] 2.0 4.9 2.0 0.2</code></pre>
<p>Mentionnons que la fonction <code>edit</code> permet également de modifier des éléments dans une matrice ou un data frame à l’intérieur d’un chiffrier ouvert dans une fenêtre externe. Aussi, la fonction <code>replace</code> permet de remplacer des éléments dans un vecteur. Ces fonctions ne sont pas illustrées ici.</p>
<hr />
</div>
</div>
<div id="le-vecteur" class="section level1">
<h1>Le vecteur</h1>
<p>Un vecteur est un simple objet atomique à une dimension. Toutes les données qu’il contient doivent être du même type.</p>
<div id="obtention-dinformations-sur-un-vecteur" class="section level2">
<h2>Obtention d’informations sur un vecteur</h2>
<p>Observons le vecteur <code>vec</code> illustré précédemment en utilisant des fonctions déjà vues jusqu’à maintenant.</p>
<p>Il est possible d’afficher les données que <code>vec</code> contient,</p>
<pre class="r"><code>vec</code></pre>
<pre><code>## [1] 2.0 4.9 2.0 0.2</code></pre>
<p>ou encore un résumé de ces données avec la fonction <code>summary</code>.</p>
<pre class="r"><code>summary(vec)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   0.200   1.550   2.000   2.275   2.725   4.900</code></pre>
<p>Des informations sur la structure de l’objet sont affichées avec la fonction <code>str</code>.</p>
<pre class="r"><code>str(vec)</code></pre>
<pre><code>##  num [1:4] 2 4.9 2 0.2</code></pre>
<p>L’objet possède une certaine longueur, retournée par la fonction <code>length</code>.</p>
<pre class="r"><code>length(vec)</code></pre>
<pre><code>## [1] 4</code></pre>
<p>Son contenu est d’un certain type, retourné par la fonction <code>typeof</code>.</p>
<pre class="r"><code>typeof(vec)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
</div>
<div id="fonctions-de-creation-dun-vecteur" class="section level2">
<h2>Fonctions de création d’un vecteur</h2>
<div id="fonction-c" class="section level3">
<h3>Fonction <code>c</code></h3>
<p>La fonction <code>c</code> permet de créer un objet de type vecteur comme suit.</p>
<pre class="r"><code>de &lt;- c(2, 3, 4, 1, 2, 3, 5, 6, 5, 4)
de</code></pre>
<pre><code>##  [1] 2 3 4 1 2 3 5 6 5 4</code></pre>
<p>La lettre <code>c</code> a été choisie comme nom pour cette fonction, car celle-ci sert à <em>combiner</em> (an anglais <em>combine</em>) ou concaténer des éléments dans un vecteur.</p>
<p>Bien que les nombres dans ce vecteur soient des entiers, ils ont été stockés sous le format réel. C’est ce que fait par défaut la fonction <code>c</code>.</p>
<pre class="r"><code>typeof(de)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
</div>
<div id="fonction-vector" class="section level3">
<h3>Fonction <code>vector</code></h3>
<p>Une autre fonction permet de créer des vecteurs : la fonction <code>vector</code>. Elle initialise des vecteurs, qui sont remplis par la suite. Avec <code>vector</code>, il faut identifier la longueur du vecteur créé et le type des données qu’il doit contenir, comme dans cet exemple.</p>
<pre class="r"><code>ve &lt;- vector(mode = &quot;numeric&quot;, length = 3)
ve</code></pre>
<pre><code>## [1] 0 0 0</code></pre>
<p>L’utilisateur ne contrôle pas les données initiales placées dans un vecteur créé avec <code>vector</code>. Il doit plutôt les modifier a posteriori.</p>
<pre class="r"><code>ve[1] &lt;- 5
ve</code></pre>
<pre><code>## [1] 5 0 0</code></pre>
<p>Cette fonction sera utile pour initialiser des vecteurs servant à contenir des valeurs créées itérativement dans une boucle.</p>
</div>
<div id="fonction-as.vector" class="section level3">
<h3>Fonction <code>as.vector</code></h3>
<p>La fonction <code>as.vector</code> sert quant à elle à transformer un objet en vecteur. Tous les attributs de l’objets sont retirés lors de l’opération. Voici un exemple.</p>
<pre class="r"><code>as.vector(mat)</code></pre>
<pre><code>##  [1]  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE
## [12]  TRUE</code></pre>
</div>
<div id="fonction-rep" class="section level3">
<h3>Fonction <code>rep</code></h3>
<p>Si un vecteur doit contenir des données qui se répètent, la fonction <code>rep</code> est utile. Ainsi, plutôt que de créer, par exemple, un vecteur contenant cinq 1 suivis de cinq 2 avec la fonction <code>c</code> comme suit</p>
<pre class="r"><code>c(1, 1, 1, 1, 1, 2, 2, 2, 2, 2)</code></pre>
<pre><code>##  [1] 1 1 1 1 1 2 2 2 2 2</code></pre>
<p>il est plus succinct de le créer en utilisant conjointement les fonctions <code>rep</code> et <code>c</code> comme suit</p>
<pre class="r"><code>rep(c(1, 2), each = 5)</code></pre>
<pre><code>##  [1] 1 1 1 1 1 2 2 2 2 2</code></pre>
<p>L’utilisation de l’argument <code>each</code> de <code>rep</code> produit des répétitions consécutives élément par élément. Si la fonction <code>rep</code> est appelée sans attribuer explicitement les valeurs fournies en entrée à des arguments, alors la deuxième valeur fournie sera assignée à l’argument <code>times</code> et non <code>each</code>. Dans ce cas, un unique entier positif fourni en deuxième position provoque la répétition du vecteur entier fourni en première position un certain nombre de fois, comme dans cet exemple.</p>
<pre class="r"><code>rep(c(1, 2), 5)</code></pre>
<pre><code>##  [1] 1 2 1 2 1 2 1 2 1 2</code></pre>
<p>Le nombre de répétitions pourrait aussi varier d’un élément à l’autre en fournissant à l’argument <code>times</code> un vecteur de nombre de répétitions aussi long que le vecteur fourni comme premier argument.</p>
<pre class="r"><code>rep(c(1, 2), c(4, 3))</code></pre>
<pre><code>## [1] 1 1 1 1 2 2 2</code></pre>
<p>Il est même possible d’exploiter simultanément les arguments <code>each</code> et <code>times</code>.</p>
<pre class="r"><code>rep(c(1, 2), each = 3, times = 2)</code></pre>
<pre><code>##  [1] 1 1 1 2 2 2 1 1 1 2 2 2</code></pre>
</div>
<div id="la-creation-de-sequences-avec-loperateur-ou-la-fonction-seq" class="section level3">
<h3>La création de séquences avec l’opérateur <code>':'</code> ou la fonction <code>seq</code></h3>
<p>Pour créer un vecteur contenant une séquence régulière de nombres, l’opérateur <code>':'</code> ou la fonction <code>seq</code> sont très utiles.</p>
<p>Avec l’opérateur <code>':'</code>, les séquences créées comportent des nombres séparés par des bonds de 1, par exemple</p>
<pre class="r"><code>6:-2</code></pre>
<pre><code>## [1]  6  5  4  3  2  1  0 -1 -2</code></pre>
<pre class="r"><code>0.2:4.2</code></pre>
<pre><code>## [1] 0.2 1.2 2.2 3.2 4.2</code></pre>
<p>Le nombre placé devant l’opérateur indique le début de la séquence et le nombre placé après indique la fin.</p>
<p>La fonction <code>seq</code> généralise <code>':'</code> en permettant des bonds de longueur autre que 1. Voici des exemples.</p>
<pre class="r"><code>seq(from = 0, to = 9, by = 3)</code></pre>
<pre><code>## [1] 0 3 6 9</code></pre>
<pre class="r"><code>seq(from = 0, to = 9, length.out = 4)</code></pre>
<pre><code>## [1] 0 3 6 9</code></pre>
</div>
</div>
<div id="fonctions-de-concatenation-de-vecteurs" class="section level2">
<h2>Fonctions de concaténation de vecteurs</h2>
<div id="fonction-c-1" class="section level3">
<h3>Fonction <code>c</code></h3>
<p>En plus de servir à créer de nouveaux vecteurs, <code>c</code> permet de concaténer des vecteurs (autant que souhaité), comme dans cet exemple.</p>
<pre class="r"><code>c(de, ve, 6:-2)</code></pre>
<pre><code>##  [1]  2  3  4  1  2  3  5  6  5  4  5  0  0  6  5  4  3  2  1  0 -1 -2</code></pre>
</div>
<div id="fonction-append" class="section level3">
<h3>Fonction <code>append</code></h3>
<p>La fonction <code>append</code> fait aussi de la concaténation de vecteurs. Contrairement à <code>c</code>, elle est limitée à la fusion de deux vecteurs. Cependant, elle permet d’insérer le deuxième vecteur n’importe où dans le premier vecteur, pas nécessairement à la fin. Voici un exemple.</p>
<pre class="r"><code>append(de, ve, after = 3)</code></pre>
<pre><code>##  [1] 2 3 4 5 0 0 1 2 3 5 6 5 4</code></pre>
</div>
</div>
<div id="ajout-de-metadonnees-dans-un-vecteur" class="section level2">
<h2>Ajout de métadonnées dans un vecteur</h2>
<p>Supposons que l’objet <code>de</code> contienne les résultats de 10 lancers d’un dé : 2, 3, 4, 1, 2, 3, 5, 6, 5, 4. Dans cet objet, nous pourrions identifier à quel lancer chaque résultat fait référence en ajoutant des noms aux éléments du vecteur.</p>
<pre class="r"><code>names(de) &lt;- c(&quot;l1&quot;, &quot;l2&quot;, &quot;l3&quot;, &quot;l4&quot;, &quot;l5&quot;, &quot;l6&quot;, &quot;l7&quot;, &quot;l8&quot;, &quot;l9&quot;, &quot;l10&quot;)
# nous apprendrons bientôt à créer plus succinctement ce vecteur avec l&#39;instruction
# paste0(&quot;l&quot;, 1:10)</code></pre>
<p>Voyons de quoi a l’air l’objet <code>de</code> suite à cet ajout.</p>
<pre class="r"><code>de</code></pre>
<pre><code>##  l1  l2  l3  l4  l5  l6  l7  l8  l9 l10 
##   2   3   4   1   2   3   5   6   5   4</code></pre>
<pre class="r"><code>str(de)</code></pre>
<pre><code>##  Named num [1:10] 2 3 4 1 2 3 5 6 5 4
##  - attr(*, &quot;names&quot;)= chr [1:10] &quot;l1&quot; &quot;l2&quot; &quot;l3&quot; &quot;l4&quot; ...</code></pre>
<p>Il possède maintenant un attribut nommé <code>&quot;names&quot;</code>.</p>
<pre class="r"><code>attr(de, which = &quot;names&quot;)
# ou</code></pre>
<pre class="r"><code>names(de)</code></pre>
<pre><code>##  [1] &quot;l1&quot;  &quot;l2&quot;  &quot;l3&quot;  &quot;l4&quot;  &quot;l5&quot;  &quot;l6&quot;  &quot;l7&quot;  &quot;l8&quot;  &quot;l9&quot;  &quot;l10&quot;</code></pre>
<p>Cet attribut est un exemple de métadonnées. Il s’agit de données à propos des données.</p>
<p> </p>
<p>Nous avons déjà vu que tout attribut peut être retiré en lui assignant la valeur spéciale <code>NULL</code>. Pour retirer les noms que nous venons d’ajouter, nous pourrions donc faire comme ceci.</p>
<pre class="r"><code>names(de) &lt;- NULL
de</code></pre>
<pre><code>##  [1] 2 3 4 1 2 3 5 6 5 4</code></pre>
<p>Pour la tâche spécifique d’effacer l’attribut <code>&quot;names&quot;</code> ou <code>&quot;dimnames&quot;</code>, une autre façon de précéder est d’appeler la fonction <code>unname</code> comme suit.</p>
<pre class="r"><code>de &lt;- unname(de)</code></pre>
<p>Dans le cas d’un vecteur, il est également possible d’effacer d’un coup tous les attributs avec <code>as.vector</code> comme suit.</p>
<pre class="r"><code>de &lt;- as.vector(de)</code></pre>
<p>Redonnons maintenant des noms aux éléments de <code>de</code>, car ils seront utiles dans les prochains exemples.</p>
<pre class="r"><code>names(de) &lt;- c(&quot;l1&quot;, &quot;l2&quot;, &quot;l3&quot;, &quot;l4&quot;, &quot;l5&quot;, &quot;l6&quot;, &quot;l7&quot;, &quot;l8&quot;, &quot;l9&quot;, &quot;l10&quot;)</code></pre>
</div>
<div id="extraction-de-donnees-dans-un-vecteur" class="section level2">
<h2>Extraction de données dans un vecteur</h2>
<div id="un-seul-element" class="section level4">
<h4>Un seul élément</h4>
<p>Un élément d’un vecteur peut être extrait en l’identifiant par sa position comme suit.</p>
<pre class="r"><code>de[1]</code></pre>
<pre><code>## l1 
##  2</code></pre>
<pre class="r"><code>de[[1]]</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Remarquons que l’opérateur <code>[</code> préserve le nom de l’élément (l’attribut <code>names</code>), alors que l’opérateur <code>[[</code> ne le conserve pas, ce qui concorde avec les propriétés de ces opérateurs vues précédemment.</p>
<p>Un élément peut aussi être extrait en l’identifiant par son nom.</p>
<pre class="r"><code>de[&quot;l1&quot;]   </code></pre>
<pre><code>## l1 
##  2</code></pre>
<p>Mais l’opérateur d’extraction <code>$</code> ne fonctionne pas avec un objet atomique tel qu’un vecteur.</p>
<pre class="r"><code>de$l1</code></pre>
<pre><code>## Error in de$l1: $ operator is invalid for atomic vectors</code></pre>
</div>
<div id="plusieurs-elements" class="section level4">
<h4>Plusieurs éléments</h4>
<p>Pour extraire plusieurs éléments simultanément, il faut utiliser un autre vecteur afin d’identifier les éléments à extraire. Voici quelques exemples selon le type du vecteur d’identifiants.</p>
<div id="identifiants-numeriques" class="section level5">
<h5>- Identifiants numériques</h5>
<p>Dans cet exemple, les éléments à extraire sont identifiés par des nombres représentant leurs positions.</p>
<pre class="r"><code>posObs &lt;- c(3,6,7)
de[posObs]
# ou directement</code></pre>
<pre class="r"><code>de[c(3,6,7)]</code></pre>
<pre><code>## l3 l6 l7 
##  4  3  5</code></pre>
<p>Note : L’opérateur [[ sert à extraire uniquement un élément. Donc la commande suivante ne fonctionne pas.</p>
<pre class="r"><code>de[[c(3,6,7)]] </code></pre>
<pre><code>## Error in de[[c(3, 6, 7)]]: attempt to select more than one element in vectorIndex</code></pre>
<p> </p>
<p>Exemples de moyens rapides de créer des vecteurs de positions avec l’opérateur <code>':'</code> et la fonction <code>seq</code> :</p>
<ul>
<li>extraction des 5 premières observations (équivalent à <code>head(de, n = 5)</code>) :</li>
</ul>
<pre class="r"><code>de[1:5]</code></pre>
<pre><code>## l1 l2 l3 l4 l5 
##  2  3  4  1  2</code></pre>
<ul>
<li>extraction des observations en positions paires.</li>
</ul>
<pre class="r"><code>de[seq(from = 2, to = 10, by = 2)]</code></pre>
<pre><code>##  l2  l4  l6  l8 l10 
##   3   1   3   6   4</code></pre>
</div>
<div id="identifiants-caracteres" class="section level5">
<h5>- Identifiants caractères</h5>
<p>Dans cet exemple, des chaînes de caractères contenant les noms des éléments à extraire sont utilisées.</p>
<pre class="r"><code>de[c(&quot;l3&quot;,&quot;l6&quot;,&quot;l7&quot;)]</code></pre>
<pre><code>## l3 l6 l7 
##  4  3  5</code></pre>
</div>
<div id="identifiants-logiques" class="section level5">
<h5>- Identifiants logiques</h5>
<p>Voici un exemple de vecteur logique permettant d’identifier des éléments à extraire. Ce vecteur servira à extraire des éléments du vecteur <code>de</code>. Il doit donc être de longueur 10, tout comme <code>de</code>. Le vecteur contient la valeur <code>TRUE</code> aux positions des éléments à extraire et <code>FALSE</code> aux positions des éléments à exclure.</p>
<pre class="r"><code>index.logic &lt;- c(TRUE, rep(FALSE, 8), TRUE)
index.logic</code></pre>
<pre><code>##  [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE</code></pre>
<p>Ce vecteur est utile pour extraire le premier et le dernier élément de <code>de</code></p>
<pre class="r"><code>de[index.logic]</code></pre>
<pre><code>##  l1 l10 
##   2   4</code></pre>
<p>Nous verrons plus tard comment utiliser des opérateurs logiques pour créer des vecteurs d’identifiants logiques. Avec ces opérateurs, il sera facile d’extraire par exemple toutes les valeurs tombant dans un certain ensemble de valeurs acceptées.</p>

</div>
</div>
<div id="extraction-par-exclusion" class="section level4">
<h4>Extraction par exclusion</h4>
<p>Une autre méthode d’extraction d’éléments d’un vecteur consiste à identifier des éléments à exclure. Pour ce faire, il faut utiliser un indicateur numérique de position négatif. Voici un exemple qui permet d’extraire tous les éléments de <code>de</code> à l’exception des deux premiers.</p>
<pre class="r"><code>de[-(1:2)]          </code></pre>
<pre><code>##  l3  l4  l5  l6  l7  l8  l9 l10 
##   4   1   2   3   5   6   5   4</code></pre>
<p>Il est aussi possible de tronquer les derniers éléments en modifiant la longueur du vecteur.</p>
<pre class="r"><code>length(de) &lt;- 5
de</code></pre>
<pre><code>## l1 l2 l3 l4 l5 
##  2  3  4  1  2</code></pre>
<p>Si sa longueur initiale est réassignée au vecteur, que se passe-t-il?</p>
<pre class="r"><code>length(de) &lt;- 10
de</code></pre>
<pre><code>## l1 l2 l3 l4 l5                
##  2  3  4  1  2 NA NA NA NA NA</code></pre>
<p>R ne sachant pas quelles données mettre dans les positions supplémentaires, il introduit sa constante pour les données manquantes <code>NA</code>.</p>
</div>
</div>
<div id="les-vecteurs-de-chaines-de-caracteres" class="section level2">
<h2>Les vecteurs de chaînes de caractères</h2>
<p>Les vecteurs de chaînes de caractères sont un peu particuliers. Nous verrons dans un prochain cours des fonctions propres à la manipulation de vecteurs contenant ce type de données. Contentons-nous ici de regarder quelques exemples pour présenter ce genre de vecteurs.</p>
<pre class="r"><code>letters</code></pre>
<pre><code>##  [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot;
## [21] &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot;</code></pre>
<p><code>letters</code> est une constante R qui contient l’alphabet en caractères minuscules (<code>LETTERS</code> est l’équivalent en majuscules). Il s’agit d’un vecteur de chaînes de caractères.</p>
<pre class="r"><code>str(letters)</code></pre>
<pre><code>##  chr [1:26] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; ...</code></pre>
<p>Une autre constante R, <code>month.name</code>, contient les noms des mois de l’année en anglais. Utilisons cette constante pour illustrer la fonction <code>nchar</code> qui indique combien de caractères contiennent des chaînes de caractères.</p>
<pre class="r"><code>month.name</code></pre>
<pre><code>##  [1] &quot;January&quot;   &quot;February&quot;  &quot;March&quot;     &quot;April&quot;     &quot;May&quot;       &quot;June&quot;     
##  [7] &quot;July&quot;      &quot;August&quot;    &quot;September&quot; &quot;October&quot;   &quot;November&quot;  &quot;December&quot;</code></pre>
<pre class="r"><code>nchar(month.name)</code></pre>
<pre><code>##  [1] 7 8 5 5 3 4 4 6 9 7 8 8</code></pre>
<p>Comme bien des fonctions R, la fonction <code>nchar</code> travaille de façon vectorielle. Si elle reçoit en entrée un vecteur, elle fait un calcul pour chaque élément du vecteur.</p>
<p>Pour savoir combien de chaînes de caractères sont contenues dans <code>month.name</code>, il faut utiliser la fonction <code>length</code>.</p>
<pre class="r"><code>length(month.name)</code></pre>
<pre><code>## [1] 12</code></pre>
<p>La fonction <code>length</code> ne retourne donc pas le longueur d’une chaîne de caractères, mais bien la longueur d’un objet (soit le nombre d’éléments dans cet objet).</p>
<pre class="r"><code>length(&quot;January&quot;)</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>nchar(&quot;January&quot;)</code></pre>
<pre><code>## [1] 7</code></pre>
<div id="les-fonctions-paste-et-paste0" class="section level3">
<h3>Les fonctions <code>paste</code> et <code>paste0</code></h3>
<p>Une fonction très utile pour créer des vecteurs de chaînes de caractères est la fonction <code>paste</code>. Comme son nom l’indique, elle permet de coller ensemble des chaînes de caractères. Par exemple, l’appel à la fonction <code>paste</code> suivant combine <code>&quot;Hello&quot;</code> et <code>&quot;world&quot;</code> dans une seule chaîne de caractères.</p>
<pre class="r"><code>paste(&quot;Hello&quot;, &quot;world&quot;, sep = &quot; &quot;)</code></pre>
<pre><code>## [1] &quot;Hello world&quot;</code></pre>
<p>L’argument <code>sep = &quot; &quot;</code> indique à <code>paste</code> de séparer les chaînes de caractères par un espace lors de la combinaison.</p>
<p>Il exsite une fonctions raccourcie pour l’utilisation de la fonction <code>paste</code> avec <code>sep = &quot;&quot;</code> (aucun caratère pour séparer les chaînes de caractères) : la fonction <code>paste0</code>.</p>
<pre class="r"><code>paste0(&quot;Hello&quot;, &quot;world&quot;)</code></pre>
<pre><code>## [1] &quot;Helloworld&quot;</code></pre>
<p>En comparaison, la combinaison de ces deux chaînes de caractères avec la fonction <code>c</code> aurait créé un vecteur de longueur 2.</p>
<pre class="r"><code>tentative &lt;- c(&quot;Hello&quot;, &quot;world&quot;)
str(tentative)</code></pre>
<pre><code>##  chr [1:2] &quot;Hello&quot; &quot;world&quot;</code></pre>
<p>Les fonctions <code>paste</code> et <code>paste0</code> travaillent, tout comme <code>nchar</code>, de façon vectorielle. Si elles reçoivent en entrée des vecteurs, elles les combinent élément par élément et retournent un vecteur de même longueur que ceux fournis.</p>
<pre class="r"><code>paste(LETTERS, letters, sep = &quot;-&quot;)</code></pre>
<pre><code>##  [1] &quot;A-a&quot; &quot;B-b&quot; &quot;C-c&quot; &quot;D-d&quot; &quot;E-e&quot; &quot;F-f&quot; &quot;G-g&quot; &quot;H-h&quot; &quot;I-i&quot; &quot;J-j&quot; &quot;K-k&quot; &quot;L-l&quot; &quot;M-m&quot;
## [14] &quot;N-n&quot; &quot;O-o&quot; &quot;P-p&quot; &quot;Q-q&quot; &quot;R-r&quot; &quot;S-s&quot; &quot;T-t&quot; &quot;U-u&quot; &quot;V-v&quot; &quot;W-w&quot; &quot;X-x&quot; &quot;Y-y&quot; &quot;Z-z&quot;</code></pre>
<p>Les fonctions <code>paste</code> et <code>paste0</code> permettent aussi de combiner dans une seule chaîne de caractères les chaînes de caractères comprises dans un vecteur grâce à leur argument <code>collapse</code>.</p>
<pre class="r"><code>paste(LETTERS, collapse = &quot;,&quot;)</code></pre>
<pre><code>## [1] &quot;A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z&quot;</code></pre>
<hr />
</div>
</div>
</div>
<div id="la-matrice" class="section level1">
<h1>La matrice</h1>
<p>Une matrice est un objet atomique à deux dimensions. Elle possède des lignes et des colonnes. Toutes les données qu’elle contient sont du même type.</p>
<div id="obtention-dinformations-sur-une-matrice" class="section level2">
<h2>Obtention d’informations sur une matrice</h2>
<p>Observons la matrice <code>mat</code> présentée précédemment.</p>
<pre class="r"><code>mat</code></pre>
<pre><code>##       [,1]  [,2]  [,3]
## [1,]  TRUE FALSE FALSE
## [2,]  TRUE  TRUE FALSE
## [3,] FALSE  TRUE  TRUE
## [4,]  TRUE  TRUE  TRUE</code></pre>
<p>Quelles sont les informations relatives à cet objet?</p>
<pre class="r"><code>str(mat)</code></pre>
<pre><code>##  logi [1:4, 1:3] TRUE TRUE FALSE TRUE FALSE TRUE ...</code></pre>
<p>Il contient des éléments de type logique.</p>
<pre class="r"><code>dim(mat)</code></pre>
<pre><code>## [1] 4 3</code></pre>
<p>Il possède deux dimensions.</p>
<pre class="r"><code>nrow(mat)</code></pre>
<pre><code>## [1] 4</code></pre>
<p>La taille de sa première dimension est vue comme un nombre de lignes. Il y en a 4.</p>
<pre class="r"><code>ncol(mat)</code></pre>
<pre><code>## [1] 3</code></pre>
<p>La taille de sa deuxième dimension est vue comme un nombre de colonnes. Il y en a 3.</p>
<pre class="r"><code>length(mat)</code></pre>
<pre><code>## [1] 12</code></pre>
<p>La longueur d’une matrice est son nombre total d’éléments, soit 12 dans cet exemple.</p>
</div>
<div id="fonctions-de-creation-dune-matrice" class="section level2">
<h2>Fonctions de création d’une matrice</h2>
<div id="fonction-matrix" class="section level3">
<h3>Fonction <code>matrix</code></h3>
<p>La fonction <code>matrix</code> permet de créer un objet de type matrice à partir d’un vecteur contenant les éléments à mettre dans la matrice.</p>
<pre class="r"><code>mat &lt;- matrix(c(TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE), 
              ncol = 3, nrow = 4, byrow = FALSE)</code></pre>
<p>L’objet obtenu est celui que nous venons d’observer.</p>
<p>La fonction <code>matrix</code> attend comme premier argument un vecteur d’éléments, ensuite un nombre de colonnes (argument <code>ncol</code>) et/ou un nombre de lignes (argument <code>nrow</code>). L’argument <code>byrow</code> permet de spécifier si les éléments du vecteur fourni comme premier argument doivent être placés dans la matrice ligne par ligne ou colonne par colonne (ce qui est fait par défaut).</p>
</div>
<div id="fonction-as.matrix" class="section level3">
<h3>Fonction <code>as.matrix</code></h3>
<p>Pour tenter de convertir en matrice un objet d’un autre type, la fonction <code>as.matrix</code> est utile. Par exemple, convertissons en matrice la data frame <code>dat</code> créé précédemment.</p>
<pre class="r"><code>as.matrix(dat)</code></pre>
<pre><code>##      V1    V2           V3     
## [1,] &quot;3.5&quot; &quot;matin&quot;      NA     
## [2,] &quot;7.8&quot; &quot;après-midi&quot; &quot;FALSE&quot;
## [3,] &quot;9.9&quot; &quot;soir&quot;       &quot;FALSE&quot;
## [4,] &quot;5.7&quot; &quot;nuit&quot;       &quot; TRUE&quot;</code></pre>
<p>Étant donné qu’une matrice est un objet atomique, tous ses éléments doivent être des données du même type. Ici, toutes les données ont donc été converties en chaînes de caractères. Nous reviendrons plus loin sur les <a href="#conversions">conversions de types de données</a>.</p>
</div>
<div id="fonctions-rbind-et-cbind" class="section level3">
<h3>Fonctions <code>rbind</code> et <code>cbind</code></h3>
<p>Nous allons maintenant étendre notre exemple de données provenant de 10 lancers d’un dé à des données provenant de 10 lancers de 2 dés. Supposons donc qu’en plus des résultats du dé 1 (2, 3, 4, 1, 2, 3, 5, 6, 5, 4), nous avons les résultats du dé 2 : 1, 4, 2, 3, 5, 4, 6, 2, 5, 3.</p>
<p>Les fonctions <code>rbind</code> et <code>cbind</code> permettent de créer des matrices à partir d’une série de vecteurs de même longueur, comme dans cet exemple.</p>
<pre class="r"><code>de1 &lt;- c(2, 3, 4, 1, 2, 3, 5, 6, 5, 4)
de2 &lt;- c(1, 4, 2, 3, 5, 4, 6, 2, 5, 3)</code></pre>
<pre class="r"><code>des_lignes &lt;- rbind(de1, de2)
des_lignes</code></pre>
<pre><code>##     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## de1    2    3    4    1    2    3    5    6    5     4
## de2    1    4    2    3    5    4    6    2    5     3</code></pre>
<p>Le <code>r</code> dans le nom <code>rbind</code> indique que la fonction combine des vecteurs par <em>rows</em> en anglais ou lignes en français, dans le sens que chacun des vecteurs devient une ligne de la matrice produite.</p>
<p>Pour les données de lancers de dés, il serait plus approprié de combiner les vecteurs par colonnes, afin que les lignes de la matrice obtenue représentent des observations et les colonnes des variables. Nous utiliserons donc plutôt <code>cbind</code> (<code>c</code> pour <em>columns</em> en anglais ou colonnes en français)</p>
<pre class="r"><code>des &lt;- cbind(de1, de2)
des</code></pre>
<pre><code>##       de1 de2
##  [1,]   2   1
##  [2,]   3   4
##  [3,]   4   2
##  [4,]   1   3
##  [5,]   2   5
##  [6,]   3   4
##  [7,]   5   6
##  [8,]   6   2
##  [9,]   5   5
## [10,]   4   3</code></pre>
</div>
</div>
<div id="fonctions-de-concatenation-de-matrices" class="section level2">
<h2>Fonctions de concaténation de matrices</h2>
<div id="fonctions-rbind-et-cbind-1" class="section level3">
<h3>Fonctions <code>rbind</code> et <code>cbind</code></h3>
<p>Les fonctions <code>rbind</code> et <code>cbind</code> acceptent aussi en entrée des matrices, qu’elles concatènent, comme dans cet exemple.</p>
<pre class="r"><code>rbind(des_lignes, des_lignes)</code></pre>
<pre><code>##     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## de1    2    3    4    1    2    3    5    6    5     4
## de2    1    4    2    3    5    4    6    2    5     3
## de1    2    3    4    1    2    3    5    6    5     4
## de2    1    4    2    3    5    4    6    2    5     3</code></pre>
<p>Des matrices concaténées en lignes doivent avoir le même nombre de colonnes et des matrices concaténées en colonnes doivent avoir le même nombre de lignes.</p>
</div>
</div>
<div id="ajout-de-metadonnees-dans-une-matrice" class="section level2">
<h2>Ajout de métadonnées dans une matrice</h2>
<p>Les lignes et colonnes d’une matrice peuvent être nommées.</p>
<pre class="r"><code>rownames(des) &lt;- paste0(&quot;l&quot;, 1:10)
colnames(des) &lt;- paste0(&quot;de&quot;, 1:2)
str(des)</code></pre>
<pre><code>##  num [1:10, 1:2] 2 3 4 1 2 3 5 6 5 4 ...
##  - attr(*, &quot;dimnames&quot;)=List of 2
##   ..$ : chr [1:10] &quot;l1&quot; &quot;l2&quot; &quot;l3&quot; &quot;l4&quot; ...
##   ..$ : chr [1:2] &quot;de1&quot; &quot;de2&quot;</code></pre>
<p>Les noms des lignes et colonnes d’une matrice R sont des attributs de l’objet, tout comme ses dimensions.</p>
<pre class="r"><code>attributes(des)</code></pre>
<pre><code>## $dim
## [1] 10  2
## 
## $dimnames
## $dimnames[[1]]
##  [1] &quot;l1&quot;  &quot;l2&quot;  &quot;l3&quot;  &quot;l4&quot;  &quot;l5&quot;  &quot;l6&quot;  &quot;l7&quot;  &quot;l8&quot;  &quot;l9&quot;  &quot;l10&quot;
## 
## $dimnames[[2]]
## [1] &quot;de1&quot; &quot;de2&quot;</code></pre>
<p>Les noms des lignes peuvent être extraits des plusieurs façons :</p>
<pre class="r"><code>rownames(des)
#ou
dimnames(des)[[1]]
#ou</code></pre>
<pre class="r"><code>attr(des, which = &quot;dimnames&quot;)[[1]]</code></pre>
<pre><code>##  [1] &quot;l1&quot;  &quot;l2&quot;  &quot;l3&quot;  &quot;l4&quot;  &quot;l5&quot;  &quot;l6&quot;  &quot;l7&quot;  &quot;l8&quot;  &quot;l9&quot;  &quot;l10&quot;</code></pre>
<p>Les noms des colonnes peuvent être extraits de façons similaires avec la fonction <code>colnames</code> et l’élément 2 de l’attribut <code>dimnames</code>.</p>
</div>
<div id="extraction-de-donnees-dans-une-matrice" class="section level2">
<h2>Extraction de données dans une matrice</h2>
<p>Tout ce qui a été mentionné concernant l’extraction de données dans un vecteur fonctionne aussi pour une matrice. Cependant, il y a maintenant deux dimensions à considérer.</p>
<div id="un-seul-element-1" class="section level4">
<h4>Un seul élément</h4>
<p>Un élément est identifié par sa position en ligne et en colonne.</p>
<pre class="r"><code>des[9, 2]</code></pre>
<pre><code>## [1] 5</code></pre>
<p>En réalité, cette extraction est équivalente à</p>
<pre class="r"><code>des[19]</code></pre>
<pre><code>## [1] 5</code></pre>
<p>parce qu’en mémoire, une matrice est stockée comme un vecteur, en mettant bout à bout ses colonnes.</p>
</div>
<div id="plusieurs-elements-1" class="section level4">
<h4>Plusieurs éléments</h4>
<p>Il est possible d’extraire des lignes complètes,</p>
<pre class="r"><code>des[2:4, ]</code></pre>
<pre><code>##    de1 de2
## l2   3   4
## l3   4   2
## l4   1   3</code></pre>
<p>ou encore des colonnes.</p>
<pre class="r"><code>des[, -2]</code></pre>
<pre><code>##  l1  l2  l3  l4  l5  l6  l7  l8  l9 l10 
##   2   3   4   1   2   3   5   6   5   4</code></pre>
<p>Étant donné qu’il ne restait qu’une seule colonne, R a par défaut transformé la matrice en vecteur. Rappelons que pour empêcher cette simplification d’être effectuée, il faut utiliser l’argument <code>drop = FALSE</code>.</p>
<pre class="r"><code>des[, -2, drop = FALSE]</code></pre>
<pre><code>##     de1
## l1    2
## l2    3
## l3    4
## l4    1
## l5    2
## l6    3
## l7    5
## l8    6
## l9    5
## l10   4</code></pre>
<p>Les lignes ou les colonnes peuvent aussi être identifiées par leur nom dans l’extraction.</p>
<pre class="r"><code>des[, &quot;de1&quot;]</code></pre>
<pre><code>##  l1  l2  l3  l4  l5  l6  l7  l8  l9 l10 
##   2   3   4   1   2   3   5   6   5   4</code></pre>
<hr />
</div>
</div>
</div>
<div id="larray" class="section level1">
<h1>L’array</h1>
<p>Une matrice est en fait un cas particulier d’array, à 2 dimensions.</p>
<pre class="r"><code>is.array(mat)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>L’array est un objet atomique pouvant posséder un nombre quelconque de dimensions.</p>
<div id="obtention-dinformations-sur-un-array" class="section level2">
<h2>Obtention d’informations sur un array</h2>
<p>Reprenons l’array <code>arr</code> illustré précédemment.</p>
<pre class="r"><code>str(arr)</code></pre>
<pre><code>##  num [1:2, 1:3, 1:4] 2 4 3 1 6 3 9 2 6 3 ...</code></pre>
<p>Comme pour une matrice, la fonction <code>dim</code> retourne les tailles de ses dimensions.</p>
<pre class="r"><code>dim(arr)</code></pre>
<pre><code>## [1] 2 3 4</code></pre>
<p>Sa longueur est aussi le nombre total d’éléments qu’il contient.</p>
<pre class="r"><code>length(arr)</code></pre>
<pre><code>## [1] 24</code></pre>
</div>
<div id="fonction-de-creation-dun-array" class="section level2">
<h2>Fonction de création d’un array</h2>
<div id="fonction-array" class="section level3">
<h3>Fonction <code>array</code></h3>
<p>La fonction <code>array</code> sert à créer des arrays. Il faut lui fournir le vecteur des éléments à stocker dans l’array et la dimension de celui-ci, comme dans cet exemple.</p>
<pre class="r"><code>collection &lt;- array(1:12, dim = c(2, 2, 3))
collection</code></pre>
<pre><code>## , , 1
## 
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
## 
## , , 2
## 
##      [,1] [,2]
## [1,]    5    7
## [2,]    6    8
## 
## , , 3
## 
##      [,1] [,2]
## [1,]    9   11
## [2,]   10   12</code></pre>
<p>Les arrays sont utiles, notamment, pour ranger dans une même structure plusieurs matrices de même taille.</p>
</div>
<div id="fonction-as.array" class="section level3">
<h3>Fonction <code>as.array</code></h3>
<p>Il est aussi possible de tenter de créer un array à partir d’un objet R quelconque avec <code>as.array</code>. Par exemple, les vecteurs ne sont pas considérés comme des types particuliers d’arrays.</p>
<pre class="r"><code>vec</code></pre>
<pre><code>## [1] 2.0 4.9 2.0 0.2</code></pre>
<pre class="r"><code>is.array(vec)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>Cependant, un vecteur peut être transformé en array comme suit.</p>
<pre class="r"><code>array_vec &lt;- as.array(vec)
array_vec</code></pre>
<pre><code>## [1] 2.0 4.9 2.0 0.2</code></pre>
<pre class="r"><code>is.array(array_vec)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Même si les affichages des objets <code>vec</code> et <code>array_vec</code> sont identiques, les deux objets ne sont pas du même type.</p>
</div>
</div>
<div id="ajout-de-metadonnees-dans-un-array" class="section level2">
<h2>Ajout de métadonnées dans un array</h2>
<p>Pour donner des noms aux dimensions d’un array, il faut utiliser une liste comme suit.</p>
<pre class="r"><code>dimnames(collection) &lt;- list(paste0(&quot;ligne&quot;, 1:2), 
                             paste0(&quot;colonne&quot;, 1:2),
                             paste0(&quot;matrice&quot;, 1:3))
collection</code></pre>
<pre><code>## , , matrice1
## 
##        colonne1 colonne2
## ligne1        1        3
## ligne2        2        4
## 
## , , matrice2
## 
##        colonne1 colonne2
## ligne1        5        7
## ligne2        6        8
## 
## , , matrice3
## 
##        colonne1 colonne2
## ligne1        9       11
## ligne2       10       12</code></pre>
<pre class="r"><code>str(collection)</code></pre>
<pre><code>##  int [1:2, 1:2, 1:3] 1 2 3 4 5 6 7 8 9 10 ...
##  - attr(*, &quot;dimnames&quot;)=List of 3
##   ..$ : chr [1:2] &quot;ligne1&quot; &quot;ligne2&quot;
##   ..$ : chr [1:2] &quot;colonne1&quot; &quot;colonne2&quot;
##   ..$ : chr [1:3] &quot;matrice1&quot; &quot;matrice2&quot; &quot;matrice3&quot;</code></pre>
</div>
<div id="extraction-de-donnees-dans-un-array" class="section level2">
<h2>Extraction de données dans un array</h2>
<p>Quelques exemples :</p>
<ul>
<li>extraction de la première matrice,</li>
</ul>
<pre class="r"><code>collection[ , , 1]</code></pre>
<pre><code>##        colonne1 colonne2
## ligne1        1        3
## ligne2        2        4</code></pre>
<ul>
<li>extraction de l’élément en position (1,2) de toutes les matrices,</li>
</ul>
<pre class="r"><code>collection[1, 2, ]</code></pre>
<pre><code>## matrice1 matrice2 matrice3 
##        3        7       11</code></pre>
<ul>
<li>extraction de la deuxième ligne des matrices 2 et 3</li>
</ul>
<pre class="r"><code>collection[2 , , 2:3]</code></pre>
<pre><code>##          matrice2 matrice3
## colonne1        6       10
## colonne2        8       12</code></pre>
<hr />
</div>
</div>
<div id="la-liste" class="section level1">
<h1>La liste</h1>
<p>La liste est semblable au vecteur dans le sens qu’elle combine des éléments. Cependant, les éléments d’un vecteur sont des données, toutes de même type. Les éléments d’une liste sont plutôt des objets, de types quelconques. Il s’agit d’un objet récursif.</p>
<p>Les fonctions qui ont plus d’un objet à retourner en sortie (ex. la fonction <code>lm</code> pour faire de la régression) retournent une liste de tous ces objets.</p>
<div id="obtention-dinformations-sur-une-liste" class="section level2">
<h2>Obtention d’informations sur une liste</h2>
<p>Jetons un coup d’oeil à la liste <code>liste</code> tirée de l’introduction.</p>
<pre class="r"><code>str(liste)</code></pre>
<pre><code>## List of 3
##  $ : num [1:2, 1:2] 2 4 3 1
##  $ :List of 2
##   ..$ : num [1:2] 2 3
##   ..$ : num 8
##  $ :&#39;data.frame&#39;:    3 obs. of  2 variables:
##   ..$ V1: num [1:3] 2 4 3
##   ..$ V2: num [1:3] 1 5 3</code></pre>
<p>Elle contient un vecteur, une autre liste et un data frame. La liste est de longueur 3 car elle comporte trois sous-objets.</p>
<pre class="r"><code>length(liste)</code></pre>
<pre><code>## [1] 3</code></pre>
</div>
<div id="fonctions-de-creation-dune-liste" class="section level2">
<h2>Fonctions de création d’une liste</h2>
<div id="fonction-list" class="section level3">
<h3>Fonction <code>list</code></h3>
<p>Nous venons tout juste d’utiliser la fonction de création de listes nommée <code>list</code> pour créer la valeur à assigner à l’attribut <code>dimnames</code> de l’array <code>collection</code>.</p>
<pre class="r"><code>noms &lt;- list(paste0(&quot;ligne&quot;, 1:2), 
             paste0(&quot;colonne&quot;, 1:2),
             paste0(&quot;matrice&quot;, 1:3))
noms</code></pre>
<pre><code>## [[1]]
## [1] &quot;ligne1&quot; &quot;ligne2&quot;
## 
## [[2]]
## [1] &quot;colonne1&quot; &quot;colonne2&quot;
## 
## [[3]]
## [1] &quot;matrice1&quot; &quot;matrice2&quot; &quot;matrice3&quot;</code></pre>
<p>Pour utiliser cette fonction, il suffit de lui donner en entrée tous les objets à inclure dans la liste, dans l’ordre souhaité.</p>
</div>
<div id="fonction-as.list" class="section level3">
<h3>Fonction <code>as.list</code></h3>
<p>La fonction <code>as.list</code> permet quant à elle de transformer n’importe quel objet R en liste. Par exemple, en appliquant la fonction <code>as.list</code> sur un vecteur, elle crée une liste pour laquelle chaque élément du vecteur est devenu un vecteur de longueur 1 en élément de la liste.</p>
<pre class="r"><code>as.list(vec)</code></pre>
<pre><code>## [[1]]
## [1] 2
## 
## [[2]]
## [1] 4.9
## 
## [[3]]
## [1] 2
## 
## [[4]]
## [1] 0.2</code></pre>
<p>Pour obtenir plutôt une liste de longueur 1 comportant le vecteur comme seul élément, il aurait plutôt fallu utiliser la fonction <code>list</code> comme suit.</p>
<pre class="r"><code>list(vec)</code></pre>
<pre><code>## [[1]]
## [1] 2.0 4.9 2.0 0.2</code></pre>
</div>
<div id="fonction-vector-1" class="section level3">
<h3>Fonction <code>vector</code></h3>
<p>La fonction <code>vector</code> permet aussi de créer des listes (rappelons qu’une liste est considérée être un vecteur récursif).</p>
<pre class="r"><code>ex &lt;- vector(mode = &quot;list&quot;, length = 2)
ex</code></pre>
<pre><code>## [[1]]
## NULL
## 
## [[2]]
## NULL</code></pre>
<p>Une liste créée avec la fonction <code>vector</code>, comme dans l’exemple ci-dessus, est initialement vide. Elle est remplie en assignant des objets à ses éléments.</p>
<pre class="r"><code>ex[[1]] &lt;- matrix(1:8, nrow = 2, ncol = 4, byrow = TRUE)
ex</code></pre>
<pre><code>## [[1]]
##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    5    6    7    8
## 
## [[2]]
## NULL</code></pre>
</div>
</div>
<div id="fonction-de-concatenation-de-listes" class="section level2">
<h2>Fonction de concaténation de listes</h2>
<div id="fonction-c-2" class="section level3">
<h3>Fonction <code>c</code></h3>
<p>Les éléments de plusieurs listes peuvent être concaténés avec la fonction <code>c</code> comme suit.</p>
<pre class="r"><code>combine &lt;- c(noms, ex)
combine</code></pre>
<pre><code>## [[1]]
## [1] &quot;ligne1&quot; &quot;ligne2&quot;
## 
## [[2]]
## [1] &quot;colonne1&quot; &quot;colonne2&quot;
## 
## [[3]]
## [1] &quot;matrice1&quot; &quot;matrice2&quot; &quot;matrice3&quot;
## 
## [[4]]
##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    5    6    7    8
## 
## [[5]]
## NULL</code></pre>
<p>Ainsi, la fonction <code>c</code> n’est pas seulement utile avec les vecteurs atomiques, elle l’est aussi avec les vecteurs récursifs.</p>
</div>
</div>
<div id="ajout-de-metadonnees-dans-une-liste" class="section level2">
<h2>Ajout de métadonnées dans une liste</h2>
<p>Les éléments d’une liste peuvent être nommés en utilisant la fonction <code>names</code> sur une liste déjà existante comme suit.</p>
<pre class="r"><code>names(noms) &lt;- c(&quot;lignes&quot;, &quot;colonnes&quot;, &quot;matrices&quot;)
noms</code></pre>
<pre><code>## $lignes
## [1] &quot;ligne1&quot; &quot;ligne2&quot;
## 
## $colonnes
## [1] &quot;colonne1&quot; &quot;colonne2&quot;
## 
## $matrices
## [1] &quot;matrice1&quot; &quot;matrice2&quot; &quot;matrice3&quot;</code></pre>
<pre class="r"><code>str(noms)</code></pre>
<pre><code>## List of 3
##  $ lignes  : chr [1:2] &quot;ligne1&quot; &quot;ligne2&quot;
##  $ colonnes: chr [1:2] &quot;colonne1&quot; &quot;colonne2&quot;
##  $ matrices: chr [1:3] &quot;matrice1&quot; &quot;matrice2&quot; &quot;matrice3&quot;</code></pre>
<p>Ils peuvent aussi être nommés directement dans une commande de création avec la fonction <code>list</code>, en précédant la spécification de chaque objet par un nom et l’opérateur <code>=</code>.</p>
<pre class="r"><code>exemple &lt;- list(mat = des, fct = casefold, liste = noms)
exemple</code></pre>
<pre><code>## $mat
##     de1 de2
## l1    2   1
## l2    3   4
## l3    4   2
## l4    1   3
## l5    2   5
## l6    3   4
## l7    5   6
## l8    6   2
## l9    5   5
## l10   4   3
## 
## $fct
## function (x, upper = FALSE) 
## if (upper) toupper(x) else tolower(x)
## &lt;bytecode: 0x000000001906e580&gt;
## &lt;environment: namespace:base&gt;
## 
## $liste
## $liste$lignes
## [1] &quot;ligne1&quot; &quot;ligne2&quot;
## 
## $liste$colonnes
## [1] &quot;colonne1&quot; &quot;colonne2&quot;
## 
## $liste$matrices
## [1] &quot;matrice1&quot; &quot;matrice2&quot; &quot;matrice3&quot;</code></pre>
</div>
<div id="extraction-delements-dans-une-liste" class="section level2">
<h2>Extraction d’éléments dans une liste</h2>
<div id="un-seul-element-2" class="section level4">
<h4>Un seul élément</h4>
<p>Voici quelques exemples :</p>
<pre class="r"><code>noms[1]          </code></pre>
<pre><code>## $lignes
## [1] &quot;ligne1&quot; &quot;ligne2&quot;</code></pre>
<pre class="r"><code>noms[[1]]</code></pre>
<pre><code>## [1] &quot;ligne1&quot; &quot;ligne2&quot;</code></pre>
<p>Nous avons déjà vu un exemple similaire. Il est important de remarquer ici que <code>noms[1]</code> est une liste de longueur 1, alors que <code>noms[[1]]</code> est l’objet en position 1 dans la liste <code>noms</code>, soit ici un vecteur. L’opérateur <code>[[</code> sort l’élément extrait de la structure de l’objet d’origine si celui-ci est récursif.</p>
<p>D’ailleurs, puisqu’une liste est un objet récursif, l’opérateur <code>$</code> peut être utilisé pour extraire un de ses éléments. Cependant, l’opérateur <code>$</code> est seulement utilisable lorsque les éléments de la liste sont nommés. Il faut inscrire le nom de l’élément à extraire après l’opérateur, comme dans cet exemple.</p>
<pre class="r"><code>noms$lignes</code></pre>
<pre><code>## [1] &quot;ligne1&quot; &quot;ligne2&quot;</code></pre>
<p>Cette dernière opération est équivalente à la suivante.</p>
<pre class="r"><code>noms[[&quot;lignes&quot;]]</code></pre>
<pre><code>## [1] &quot;ligne1&quot; &quot;ligne2&quot;</code></pre>
<p>Contrairement à l’opérateur <code>[[</code>, l’opérateur <code>$</code> n’exige pas que le nom de l’élément à extraire soit encadré de guillemets, sauf s’il comporte un ou des espaces.</p>
<p>Il est parfois utile d’utiliser des opérateurs d’extraction à la chaîne. Par exemple, la commande suivante extrait l’élément <code>lignes</code> dans le sous-objet <code>liste</code> de la liste <code>exemple</code>.</p>
<pre class="r"><code>exemple$liste$lignes</code></pre>
<pre><code>## [1] &quot;ligne1&quot; &quot;ligne2&quot;</code></pre>
</div>
<div id="plusieurs-elements-2" class="section level4">
<h4>Plusieurs éléments</h4>
<p>Pour extraire d’un coup plusieurs éléments d’une liste, il faut employer l’opérateur <code>[</code>. Voici un exemple.</p>
<pre class="r"><code>noms[1:2]</code></pre>
<pre><code>## $lignes
## [1] &quot;ligne1&quot; &quot;ligne2&quot;
## 
## $colonnes
## [1] &quot;colonne1&quot; &quot;colonne2&quot;</code></pre>
</div>
<div id="extraction-par-exclusion-1" class="section level4">
<h4>Extraction par exclusion</h4>
<p>La façon la plus simple de retirer un élément d’une liste est d’assigner la valeur <code>NULL</code> à l’élément en question.</p>
<pre class="r"><code>noms$lignes &lt;- NULL
noms</code></pre>
<pre><code>## $colonnes
## [1] &quot;colonne1&quot; &quot;colonne2&quot;
## 
## $matrices
## [1] &quot;matrice1&quot; &quot;matrice2&quot; &quot;matrice3&quot;</code></pre>
<hr />
</div>
</div>
</div>
<div id="le-data-frame" class="section level1">
<h1>Le data frame</h1>
<p>Peu de langages de programmation possèdent une structure de données équivalente au data frame de R. Il s’agit d’une structure spécifiquement conçue pour stocker des jeux de données.</p>
<div id="jeux-de-donnees" class="section level2">
<h2>Jeux de données</h2>
<p>Afin de mieux comprendre le data frame, rappelons d’abord quelques définitions relatives à un jeu de données<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<div id="definitions-relatives-a-un-jeu-de-donnees" class="section level3">
<h3>Définitions relatives à un jeu de données</h3>
<ul>
<li><p><strong>Données</strong> : En statistique, des données sont des valeurs numériques (des nombres) ou alphanumériques (des chaînes de caractères) représentant les observations de certaines variables sur certains individus. Elles se présentent souvent sous la forme de jeux de données, c’est-à-dire de tableaux de valeurs, stockées dans un fichier informatique.</p></li>
<li><p><strong>Population</strong> : La population est l’ensemble de référence sur lequel porte l’étude dans le cadre de laquelle les données ont été recueillies.</p></li>
<li><p><strong>Individu ou unité statistique</strong> : Un individu est un élément de la population. L’ensemble des individus constitue la population. Chaque observation est associée à un individu.</p></li>
<li><p><strong>Échantillon</strong> : L’échantillon est un sous-groupe de la population, composé des individus pour lesquels des observations ont été recueillies. Si des mesures ont été prises pour tous les individus de la population, il s’agit d’un recensement.</p></li>
<li><p><strong>Variable</strong> : Le terme variable désigne la représentation d’une caractéristique des individus. Ainsi, une variable n’est pas la caractéristique elle-même, mais plutôt une mesure de cette caractéristique.</p></li>
<li><p><strong>Observation</strong> : Une observation est l’ensemble des valeurs obtenues en mesurant des variables sur un individu de la population.</p></li>
</ul>
</div>
<div id="representation-dun-jeu-de-donnees-en-r" class="section level3">
<h3>Représentation d’un jeu de données en R</h3>
<p>Dans un logiciel informatique, une façon courante de stocker un jeu de données est d’utiliser une structure de données à deux dimensions et d’y placer les observations en lignes et les variables en colonnes. En R, si toutes les variables sont du même type, il est possible d’utiliser une matrice. Cependant, lorsque les valeurs observées des différentes variables ne sont pas du même type, par exemple si certaines sont numériques et d’autres caractères, il est impossible de regrouper ces variables au sein d’une seule matrice. Le data frame a été créé pour stocker un tel jeu de données.</p>
<p>Observons de nouveau la structure du data frame illustré en introduction.</p>
<pre class="r"><code>dat</code></pre>
<pre><code>##    V1         V2    V3
## 1 3.5      matin    NA
## 2 7.8 après-midi FALSE
## 3 9.9       soir FALSE
## 4 5.7       nuit  TRUE</code></pre>
<p>Il s’agit d’un exemple de jeu de données sous la forme « observations en lignes, variables en colonnes ». La sortie de la fonction <code>str</code> appliquée à un data frame énonce clairement cette interprétation du data frame.</p>
<pre class="r"><code>str(dat)</code></pre>
<pre><code>## &#39;data.frame&#39;:    4 obs. of  3 variables:
##  $ V1: num  3.5 7.8 9.9 5.7
##  $ V2: chr  &quot;matin&quot; &quot;après-midi&quot; &quot;soir&quot; &quot;nuit&quot;
##  $ V3: logi  NA FALSE FALSE TRUE</code></pre>
<p>Ici, la mention « <code>4 obs. of 3 variables</code> » signifie que les lignes doivent être vues comme des observations et les colonnes comme des variables.</p>
</div>
</div>
<div id="obtention-dinformations-sur-un-data-frame" class="section level2">
<h2>Obtention d’informations sur un data frame</h2>
<p>Le data frame <code>dat</code> possède les attributs <code>names</code>, <code>row.names</code> et <code>class</code>.</p>
<pre class="r"><code>attributes(dat)</code></pre>
<pre><code>## $names
## [1] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot;
## 
## $row.names
## [1] 1 2 3 4
## 
## $class
## [1] &quot;data.frame&quot;</code></pre>
<p>Tout data frame possède ces attributs par défaut. Il s’agit des noms des éléments selon la dimension, ainsi que d’une « classe » identifiant le type de l’objet. Les types d’objets vus précédemment n’ont pas un tel attribut.</p>
<p>En contrepartie, la dimension est un attribut pour les matrices et les arrays, alors qu’elle n’en est pas un pour les data frames. Les fonctions <code>dim</code>, <code>nrow</code> et <code>ncol</code> fonctionnent tout de même avec des data frames.</p>
<pre class="r"><code>dim(dat)</code></pre>
<pre><code>## [1] 4 3</code></pre>
<pre class="r"><code>nrow(dat)</code></pre>
<pre><code>## [1] 4</code></pre>
<pre class="r"><code>ncol(dat)</code></pre>
<pre><code>## [1] 3</code></pre>
<p>Comme pour tout objet R, la longueur d’un data frame est le nombre d’éléments qu’il contient.</p>
<pre class="r"><code>length(dat)</code></pre>
<pre><code>## [1] 3</code></pre>
<p>Pourquoi la longueur de <code>dat</code> n’est-elle pas <span class="math inline">\(4 \times 3 = 12\)</span>?</p>
<p>Parce qu’un data frame est un objet récursif dont les éléments sont les colonnes.</p>
<pre class="r"><code>typeof(dat)</code></pre>
<pre><code>## [1] &quot;list&quot;</code></pre>
<p>Alors, le nombre d’éléments dans un data frame correspond au nombre de colonnes. C’est aussi pour cette raison que les noms des éléments d’un data frame sont aussi considérés comme les noms des colonnes.</p>
<pre class="r"><code>names(dat)</code></pre>
<pre><code>## [1] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot;</code></pre>
<pre class="r"><code>colnames(dat)</code></pre>
<pre><code>## [1] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot;</code></pre>
</div>
<div id="fonction-de-creation-dun-data-frame" class="section level2">
<h2>Fonction de création d’un data frame</h2>
<div id="fonction-data.frame" class="section level3">
<h3>Fonction <code>data.frame</code></h3>
<p>Ajoutons à la matrice <code>des</code> créée précédemment, qui contient des données fictives de lancers de deux dés, une colonne contenant le nom de la personne qui a lancé le dé. Le résultat ne peut pas être une matrice si nous voulons conserver des données de type numérique dans les deux premières colonnes et caractère dans la troisième colonne. Il faut donc créer un data frame, ce que réalise la commande suivante.</p>
<pre class="r"><code>desPlus &lt;- data.frame(des, lanceur = rep(c(&quot;Luc&quot;, &quot;Kim&quot;), each = 5))
desPlus</code></pre>
<pre><code>##     de1 de2 lanceur
## l1    2   1     Luc
## l2    3   4     Luc
## l3    4   2     Luc
## l4    1   3     Luc
## l5    2   5     Luc
## l6    3   4     Kim
## l7    5   6     Kim
## l8    6   2     Kim
## l9    5   5     Kim
## l10   4   3     Kim</code></pre>
<p>Il faut donner en entrée à la fonction <code>data.frame</code> tous les vecteurs et/ou facteurs qu’il doit contenir, dans l’ordre désiré. La fonction <code>data.frame</code> accepte aussi en entrée des matrices, comme dans l’exemple précédent, auquel cas les colonnes des matrices en entrée deviennent des colonnes dans le data frame en sortie.</p>
<p>Regardons la structure interne du data frame que nous venons de créer.</p>
<pre class="r"><code>str(desPlus)</code></pre>
<pre><code>## &#39;data.frame&#39;:    10 obs. of  3 variables:
##  $ de1    : num  2 3 4 1 2 3 5 6 5 4
##  $ de2    : num  1 4 2 3 5 4 6 2 5 3
##  $ lanceur: Factor w/ 2 levels &quot;Kim&quot;,&quot;Luc&quot;: 2 2 2 2 2 1 1 1 1 1</code></pre>
<p>Pourquoi la troisième colonne est-elle un facteur plutôt qu’un vecteur ? Parce que par défaut la fonction <code>data.frame</code>, soit la principale fonction de création d’un data frame, transforme les vecteurs contenant des données de type caractère en facteur. Il est possible d’empêcher la fonction <code>data.frame</code> d’avoir ce comportement grâce à l’argument <code>stringsAsFactors</code> comme suit.</p>
<pre class="r"><code>desPlus &lt;- data.frame(des, lanceur = rep(c(&quot;Luc&quot;, &quot;Kim&quot;), each = 5), 
                      stringsAsFactors = FALSE)
str(desPlus)</code></pre>
<pre><code>## &#39;data.frame&#39;:    10 obs. of  3 variables:
##  $ de1    : num  2 3 4 1 2 3 5 6 5 4
##  $ de2    : num  1 4 2 3 5 4 6 2 5 3
##  $ lanceur: chr  &quot;Luc&quot; &quot;Luc&quot; &quot;Luc&quot; &quot;Luc&quot; ...</code></pre>
<p>Notons que la valeur par défaut de l’argument <code>stringsAsFactors</code> peut aussi être changée avec la commande.</p>
<pre class="r"><code>options(stringsAsFactors = FALSE)</code></pre>
<p>Cependant, cette commande provoque un changement global qui affecte toutes les fonctions ayant un argument <code>stringsAsFactors</code> (la fonction <code>data.frame</code> n’est pas la seule à avoir cet argument).</p>
</div>
<div id="fonction-as.data.frame" class="section level3">
<h3>Fonction <code>as.data.frame</code></h3>
<p>Pour transformer, si possible, un objet R en data frame, il faut utiliser la fonction <code>as.data.frame</code>. Par exemple, transformons la matrice <code>mat</code> en data frame.</p>
<pre class="r"><code>df_mat &lt;- as.data.frame(mat)
df_mat</code></pre>
<pre><code>##      V1    V2    V3
## 1  TRUE FALSE FALSE
## 2  TRUE  TRUE FALSE
## 3 FALSE  TRUE  TRUE
## 4  TRUE  TRUE  TRUE</code></pre>
</div>
</div>
<div id="fonctions-de-concatenation-de-data-frame" class="section level2">
<h2>Fonctions de concaténation de data frame</h2>
<div id="fonction-data.frame-1" class="section level3">
<h3>Fonction <code>data.frame</code></h3>
<p>En plus de servir à créer des data frames, la fonction <code>data.frame</code> permet d’en combiner par concaténation de colonnes.</p>
<pre class="r"><code>jour &lt;- data.frame(jour = rep(1,10))
str(jour)</code></pre>
<pre><code>## &#39;data.frame&#39;:    10 obs. of  1 variable:
##  $ jour: num  1 1 1 1 1 1 1 1 1 1</code></pre>
<pre class="r"><code>autre &lt;- data.frame(desPlus, jour)
str(autre)</code></pre>
<pre><code>## &#39;data.frame&#39;:    10 obs. of  4 variables:
##  $ de1    : num  2 3 4 1 2 3 5 6 5 4
##  $ de2    : num  1 4 2 3 5 4 6 2 5 3
##  $ lanceur: chr  &quot;Luc&quot; &quot;Luc&quot; &quot;Luc&quot; &quot;Luc&quot; ...
##  $ jour   : num  1 1 1 1 1 1 1 1 1 1</code></pre>
</div>
<div id="fonctions-rbind-et-cbind-2" class="section level3">
<h3>Fonctions <code>rbind</code> et <code>cbind</code></h3>
<p>Une concaténation de data frames peut aussi s’effectuer avec les fonctions <code>rbind</code> et <code>cbind</code>. Comme avec une matrice, <code>rbind</code> effectue une concaténation en lignes et <code>cbind</code> en colonnes.</p>
<p>La fonction <code>rbind</code> permet donc de mettre en commun les observations de plusieurs data frames, comme dans cet exemple.</p>
<pre class="r"><code>desPlus_Exp2 &lt;- data.frame(de1 = c(3,5), de2 = c(4,2), lanceur = &quot;Paul&quot;)
desPlus_Exp3 &lt;- data.frame(de1 = c(6,1), de2 = c(2,5), lanceur = &quot;Paul&quot;)
rbind(desPlus, desPlus_Exp2, desPlus_Exp3)</code></pre>
<pre><code>##     de1 de2 lanceur
## l1    2   1     Luc
## l2    3   4     Luc
## l3    4   2     Luc
## l4    1   3     Luc
## l5    2   5     Luc
## l6    3   4     Kim
## l7    5   6     Kim
## l8    6   2     Kim
## l9    5   5     Kim
## l10   4   3     Kim
## 1     3   4    Paul
## 2     5   2    Paul
## 11    6   2    Paul
## 21    1   5    Paul</code></pre>
<p>Pour que la concaténation fonctionne, les noms des variables (colonnes) dans les data frames doivent concorder.</p>
<p>Une concaténation de data frames avec <code>cbind</code> est quant à elle similaire à une concaténation avec <code>data.frame</code> : des variables sont rassemblées dans un seul data frame.</p>
<pre class="r"><code>cbind(desPlus, jour)</code></pre>
<pre><code>##     de1 de2 lanceur jour
## l1    2   1     Luc    1
## l2    3   4     Luc    1
## l3    4   2     Luc    1
## l4    1   3     Luc    1
## l5    2   5     Luc    1
## l6    3   4     Kim    1
## l7    5   6     Kim    1
## l8    6   2     Kim    1
## l9    5   5     Kim    1
## l10   4   3     Kim    1</code></pre>
<p>Cette fois, les noms des observations (lignes) n’ont pas besoin de concorder entre les data frames, mais les nombres d’observations doivent être égaux.</p>
</div>
</div>
<div id="ajout-de-metadonnees-dans-un-data-frame" class="section level2">
<h2>Ajout de métadonnées dans un data frame</h2>
<p>La fonction <code>data.frame</code> attribue toujours par défaut des noms aux lignes et colonnes des data frames qu’elle crée. Voyons un exemple.</p>
<pre class="r"><code>essai &lt;- data.frame(1:5, letters[1:5])
essai</code></pre>
<pre><code>##   X1.5 letters.1.5.
## 1    1            a
## 2    2            b
## 3    3            c
## 4    4            d
## 5    5            e</code></pre>
<pre class="r"><code>attributes(essai)</code></pre>
<pre><code>## $names
## [1] &quot;X1.5&quot;         &quot;letters.1.5.&quot;
## 
## $class
## [1] &quot;data.frame&quot;
## 
## $row.names
## [1] 1 2 3 4 5</code></pre>
<p>Les noms par défaut des colonnes ne sont pas toujours pertinents. Il vaut donc mieux nommer les colonnes lors de la création, directement dans l’appel à la fonction <code>data.frame</code>. Pour ce faire, il suffit de précéder les éléments à combiner d’un nom et de l’opérateur <code>=</code>, comme dans cet exemple.</p>
<pre class="r"><code>data.frame(chiffre = 1:5, lettre = letters[1:5])</code></pre>
<pre><code>##   chiffre lettre
## 1       1      a
## 2       2      b
## 3       3      c
## 4       4      d
## 5       5      e</code></pre>
<p>Avec cette technique, les noms ont besoin d’être encadrés de guillemets uniquement s’ils comprennent un ou des espaces.</p>
<p>Les noms des colonnes d’un data frame peuvent aussi être remplacés a posteriori avec la fonction <code>names</code> ou <code>colnames</code> accompagnée d’une assignation.</p>
<pre class="r"><code>names(essai) &lt;- c(&quot;chiffre&quot;, &quot;lettre&quot;)</code></pre>
</div>
<div id="extraction-delements-dun-data-frame" class="section level2">
<h2>Extraction d’éléments d’un data frame</h2>
<p>L’extraction d’éléments d’un data frame s’effectue comme pour une liste ou encore comme pour une matrice. Les deux options sont possibles.</p>
<div id="en-traitant-le-data-frame-comme-une-liste" class="section level4">
<h4>En traitant le data frame comme une liste</h4>
<p>Comme il a déjà été mentionné à quelques reprises maintenant, le data frame est un objet récursif et ses éléments sont ses colonnes. Alors, extraire des éléments d’un data frame signifie extraire des colonnes.</p>
<p>Tous les opérateurs d’indiçage introduits plus tôt fonctionnent avec le data frame, comme le démontre ces exemples.</p>
<pre class="r"><code>desPlus[c(&quot;de1&quot;, &quot;de2&quot;)]</code></pre>
<pre><code>##     de1 de2
## l1    2   1
## l2    3   4
## l3    4   2
## l4    1   3
## l5    2   5
## l6    3   4
## l7    5   6
## l8    6   2
## l9    5   5
## l10   4   3</code></pre>
<pre class="r"><code>desPlus[[1]]</code></pre>
<pre><code>##  [1] 2 3 4 1 2 3 5 6 5 4</code></pre>
<pre class="r"><code>desPlus$de1</code></pre>
<pre><code>##  [1] 2 3 4 1 2 3 5 6 5 4</code></pre>
</div>
<div id="en-traitant-le-data-frame-comme-une-matrice" class="section level4">
<h4>En traitant le data frame comme une matrice</h4>
<p>Il est aussi possible d’exploiter les deux dimensions du data frame et d’extraire des éléments de ses colonnes. Pour ce faire, il faut simplement traiter le data frame comme une matrice et fournir deux arguments à l’opérateur d’indiçage <code>[</code> ou <code>[[</code> : le premier pour identifier des lignes, le deuxième pour identifier des colonnes. Voici quelques exemples.</p>
<pre class="r"><code>desPlus[, &quot;de1&quot;]</code></pre>
<pre><code>##  [1] 2 3 4 1 2 3 5 6 5 4</code></pre>
<pre class="r"><code>desPlus[c(rep(FALSE, 6), rep(TRUE, 3), FALSE), 2:3]</code></pre>
<pre><code>##    de2 lanceur
## l7   6     Kim
## l8   2     Kim
## l9   5     Kim</code></pre>
<pre class="r"><code>desPlus[[1, 1]]</code></pre>
<pre><code>## [1] 2</code></pre>
</div>
<div id="extraction-par-exclusion-2" class="section level4">
<h4>Extraction par exclusion</h4>
<p>Comme pour une liste, assigner la valeur NULL à un élément d’un data frame l’efface de celui-ci, comme dans cet exemple.</p>
<pre class="r"><code>autre$jour &lt;- NULL
autre</code></pre>
<pre><code>##     de1 de2 lanceur
## l1    2   1     Luc
## l2    3   4     Luc
## l3    4   2     Luc
## l4    1   3     Luc
## l5    2   5     Luc
## l6    3   4     Kim
## l7    5   6     Kim
## l8    6   2     Kim
## l9    5   5     Kim
## l10   4   3     Kim</code></pre>
</div>
</div>
<div id="extensions-du-data-frame" class="section level2">
<h2>Extensions du data frame</h2>
<p>Certains packages R offrent des structures de données alternatives au data frame. Deux de ces structures sont mentionnées ici, car elles sont de plus en plus utilisées dans la communauté R. Elles ne sont cependant pas approfondies.</p>
<div id="le-tibble" class="section level3">
<h3>Le tibble</h3>
<p>Les packages du <a href="https://www.tidyverse.org/"><code>tidyverse</code></a> utilisent des <a href="http://tibble.tidyverse.org/articles/tibble.html">tibbles</a> en remplacment des data frames. Le <code>tidyverse</code> est une collection de packages dit être spécialisés en « science des données ». Plusieurs des développeurs de ces packages sont affiliés à <a href="https://www.rstudio.com/">RStudio</a>. Cette collection comprend notamment le très populaire package <a href="http://ggplot2.tidyverse.org/"><code>ggplot2</code></a> et d’autres packages développés par Hadley Wickham.</p>
<p>Voyons un exemple de tibble.</p>
<pre class="r"><code>library(tibble)
desPlus_tibble &lt;- tibble(de1 = c(2, 3, 4, 1, 2, 3, 5, 6, 5, 4),
                         de2 = c(1, 4, 2, 3, 5, 4, 6, 2, 5, 3), 
                         lanceur = rep(c(&quot;Luc&quot;, &quot;Kim&quot;), each = 5))
desPlus_tibble</code></pre>
<pre><code>## # A tibble: 10 x 3
##      de1   de2 lanceur
##    &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;  
##  1     2     1 Luc    
##  2     3     4 Luc    
##  3     4     2 Luc    
##  4     1     3 Luc    
##  5     2     5 Luc    
##  6     3     4 Kim    
##  7     5     6 Kim    
##  8     6     2 Kim    
##  9     5     5 Kim    
## 10     4     3 Kim</code></pre>
<pre class="r"><code>str(desPlus_tibble)</code></pre>
<pre><code>## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;:    10 obs. of  3 variables:
##  $ de1    : num  2 3 4 1 2 3 5 6 5 4
##  $ de2    : num  1 4 2 3 5 4 6 2 5 3
##  $ lanceur: chr  &quot;Luc&quot; &quot;Luc&quot; &quot;Luc&quot; &quot;Luc&quot; ...</code></pre>
<p>Un tibble se manipule comme un data frame, mais il possède les distinctions suivantes :</p>
<ul>
<li>les colonnes contenant des données de type caractère ne sont pas transformées en facteurs par défaut (pas d’argument <code>stringsAsFactors</code>).</li>
<li>l’affichage (<em>print</em>) a été repensé : pas plus de 10 lignes affichées par défaut, abréviations des types des colonnes affichées;</li>
<li>l’extraction d’éléments d’un tibble avec l’opérateur <code>[</code> retourne toujours un autre tibble, sa sortie n’est jamais simplifiée (pas d’argument <code>drop</code>);</li>
<li>la règle de recyclage lors de la création d’un tibble s’applique seulement pour des vecteurs de longueur unitaire;</li>
<li>certaines opérations d’extraction sont plus rapides.</li>
</ul>
<div id="pour-en-apprendre-davantage" class="section level4">
<h4>Pour en apprendre davantage</h4>
<p>Voici quelques références pour ceux intéressés à en apprendre davantage à propos des tibbles :</p>
<ul>
<li><a href="http://tibble.tidyverse.org/articles/tibble.html" class="uri">http://tibble.tidyverse.org/articles/tibble.html</a></li>
<li><a href="http://r4ds.had.co.nz/tibbles.html" class="uri">http://r4ds.had.co.nz/tibbles.html</a></li>
<li><a href="http://blog.jumpingrivers.com/posts/2018/trouble_with_tibbles/" class="uri">http://blog.jumpingrivers.com/posts/2018/trouble_with_tibbles/</a></li>
</ul>
</div>
</div>
<div id="le-data-table" class="section level3">
<h3>Le data table</h3>
<p>Le <a href="https://github.com/Rdatatable/data.table/wiki">data table</a> est une extension du data frame développée dans le but de rendre plus rapides et conviviales les manipulations de jeu de données en R.</p>
<p>Voyons un exemple de data table.</p>
<pre class="r"><code>library(data.table)
desPlus_data.table &lt;- data.table(de1 = c(2, 3, 4, 1, 2, 3, 5, 6, 5, 4),
                                 de2 = c(1, 4, 2, 3, 5, 4, 6, 2, 5, 3), 
                                 lanceur = rep(c(&quot;Luc&quot;, &quot;Kim&quot;), each = 5))
desPlus_data.table</code></pre>
<pre><code>##     de1 de2 lanceur
##  1:   2   1     Luc
##  2:   3   4     Luc
##  3:   4   2     Luc
##  4:   1   3     Luc
##  5:   2   5     Luc
##  6:   3   4     Kim
##  7:   5   6     Kim
##  8:   6   2     Kim
##  9:   5   5     Kim
## 10:   4   3     Kim</code></pre>
<pre class="r"><code>str(desPlus_data.table)</code></pre>
<pre><code>## Classes &#39;data.table&#39; and &#39;data.frame&#39;:   10 obs. of  3 variables:
##  $ de1    : num  2 3 4 1 2 3 5 6 5 4
##  $ de2    : num  1 4 2 3 5 4 6 2 5 3
##  $ lanceur: chr  &quot;Luc&quot; &quot;Luc&quot; &quot;Luc&quot; &quot;Luc&quot; ...
##  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>Nous remarquons tout d’abord les différences suivantes avec le data frame :</p>
<ul>
<li>les colonnes contenant des données de type caractère ne sont pas transformées en facteurs par défaut (la valeur par défaut de l’argument <code>stringsAsFactors</code> est <code>FALSE</code>);</li>
<li>l’affichage des noms des lignes est un peu différent.</li>
</ul>
<p>Au-delà de ces distinctions mineures, la vraie force du data table est la rapidité d’exécution des manipulations et la possibilité d’en faire beaucoup plus avec l’opérateur <code>[</code> comparativement au data frame. Pour illustrer ce dernier point, voici un exemple de calcul de statistiques descriptives avec l’opérateur <code>[</code>.</p>
<pre class="r"><code>desPlus_data.table[,
                   .(moy_de1 = mean(de1), moy_de2 = mean(de2)), 
                   by = lanceur]</code></pre>
<pre><code>##    lanceur moy_de1 moy_de2
## 1:     Luc     2.4       3
## 2:     Kim     4.6       4</code></pre>
<p>Les deux premiers arguments (<code>i</code> et <code>j</code>) de l’opérateur <code>[</code> acceptent plus de valeurs pour un data table que pour un data frame. Dans le cas d’un data frame, ces arguments servent uniquement à identifier des lignes et des colonnes. Pour un data table, ils ont plus d’utilités et servent notamment à demander le calcul de statistiques sur une partie des données. Dans l’exemple ci-dessus, le calcul de moyennes sur les variables <code>de1</code> et <code>de2</code> est demandé. La syntaxe pour demander de tels calculs est simple.</p>
<p>De plus, l’opérateur <code>[</code> pour le data table possède plusieurs autres arguments, dont l’argument <code>by</code>. Dans la commande précédente, l’argument <code>by</code> a permis de demander un calcul distinct selon la valeur d’une variable.</p>
<p>Dans les valeurs fournies aux arguments de l’opérateur <code>[</code> pour le data table, il est possible de référer aux colonnes du data table par leurs noms sans encadrer ces noms de guillemets.</p>
<p>Nous verrons dans un prochain cours comment produire avec les fonctionnalités de base de R les mêmes calculs que ceux de l’exemple exploité ici.</p>
<div id="pour-en-apprendre-davantage-1" class="section level4">
<h4>Pour en apprendre davantage</h4>
<p>Voici quelques références pour ceux intéressés à en apprendre davantage à propos des data tables :</p>
<ul>
<li><a href="https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html" class="uri">https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html</a></li>
<li><a href="https://github.com/Rdatatable/data.table/wiki" class="uri">https://github.com/Rdatatable/data.table/wiki</a></li>
<li><a href="https://stt4230.rbind.io/tutoriels_etudiants/hiver_2017/data.table/" class="uri">https://stt4230.rbind.io/tutoriels_etudiants/hiver_2017/data.table/</a></li>
</ul>
<hr />
</div>
</div>
</div>
</div>
<div id="le-facteur" class="section level1">
<h1>Le facteur</h1>
<p>Le facteur possède plusieurs propriétés du vecteur, mais il est conçu pour stocker les valeurs observées d’une variable catégorique. Son nom vient de la terminologie utilisée en analyse de la variance (ANOVA).</p>
<div id="obtention-dinformations-sur-un-facteur." class="section level2">
<h2>Obtention d’informations sur un facteur.</h2>
<p>Reprenons l’exemple en introduction.</p>
<pre class="r"><code>fac</code></pre>
<pre><code>## [1] 5 2 5 5
## Levels: 2 5</code></pre>
<p>Le facteur possède des attributs de plus qu’un vecteur, soit un identifiant de ses niveaux (modalités possibles) ainsi qu’une classe pour spécifier qu’il s’agit d’un facteur.</p>
<pre class="r"><code>attributes(fac)</code></pre>
<pre><code>## $levels
## [1] &quot;2&quot; &quot;5&quot;
## 
## $class
## [1] &quot;factor&quot;</code></pre>
<p>La fonction <code>levels</code> retourne les niveaux d’un facteur, et la fonction <code>nlevels</code> retourne le nombre de niveaux.</p>
<pre class="r"><code>levels(fac)</code></pre>
<pre><code>## [1] &quot;2&quot; &quot;5&quot;</code></pre>
<pre class="r"><code>nlevels(fac)</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Pour prendre le moins de place possible en mémoire, les données dans un facteur sont toujours stockées sous la forme d’entiers : les chiffres 1 à disons <span class="math inline">\(l\)</span> où <span class="math inline">\(l\)</span> est le nombre de niveaux du facteur. La sortie de <code>str</code> avec un facteur affiche ces entiers.</p>
<pre class="r"><code>str(fac)</code></pre>
<pre><code>##  Factor w/ 2 levels &quot;2&quot;,&quot;5&quot;: 2 1 2 2</code></pre>
<p>Cependant, les niveaux, ou modalités, du facteur sont stockés sous forme de caractère, peu importe leur nature d’origine.</p>
</div>
<div id="fonction-de-creation-dun-facteur" class="section level2">
<h2>Fonction de création d’un facteur</h2>
<div id="fonctions-factor-et-as.factor" class="section level3">
<h3>Fonctions <code>factor</code> et <code>as.factor</code></h3>
<p>Pour créer un facteur de toutes pièces, il faut faire appel à la fonction <code>factor</code> ou <code>as.factor</code>.</p>
<pre class="r"><code>reponses &lt;- factor(rep(c(&quot;roche&quot;, &quot;papier&quot;, &quot;ciseau&quot;), 3))
reponses</code></pre>
<pre><code>## [1] roche  papier ciseau roche  papier ciseau roche  papier ciseau
## Levels: ciseau papier roche</code></pre>
<pre class="r"><code>str(reponses)</code></pre>
<pre><code>##  Factor w/ 3 levels &quot;ciseau&quot;,&quot;papier&quot;,..: 3 2 1 3 2 1 3 2 1</code></pre>
<p>Les niveaux du facteur sont extraits automatiquement par la fonction <code>factor</code> et placés en ordre alphanumérique. Pour contrôler l’ordre des facteurs, il faut spécifier cet ordre dans la commande de création du facteur avec l’argument <code>levels</code>.</p>
<pre class="r"><code>reponses &lt;- factor(rep(c(&quot;roche&quot;, &quot;papier&quot;, &quot;ciseau&quot;), 3),
                   levels = c(&quot;roche&quot;, &quot;papier&quot;, &quot;ciseau&quot;))
reponses</code></pre>
<pre><code>## [1] roche  papier ciseau roche  papier ciseau roche  papier ciseau
## Levels: roche papier ciseau</code></pre>
<pre class="r"><code>str(reponses)</code></pre>
<pre><code>##  Factor w/ 3 levels &quot;roche&quot;,&quot;papier&quot;,..: 1 2 3 1 2 3 1 2 3</code></pre>
<p>Il est utile de contrôler l’ordre des niveaux d’un facteur, car dans des sorties ou graphiques produits avec un facteur, l’ordre de ses niveaux est respecté.</p>
<p>La fonction <code>as.factor</code> agit comme la fonction <code>factor</code>, mais elle ne possède pas d’arguments supplémentaires au vecteur à transformer.</p>
</div>
</div>
<div id="fonction-de-modification-dun-facteur" class="section level2">
<h2>Fonction de modification d’un facteur</h2>
<div id="fonction-levels" class="section level3">
<h3>Fonction <code>levels</code></h3>
<p>Pour modifier les libellés des niveaux, il suffit de combiner l’utilisation de la fonction <code>levels</code> à une assignation de données comme suit.</p>
<pre class="r"><code>levels(reponses) &lt;- c(&quot;pomme&quot;, &quot;orange&quot;, &quot;poire&quot;)
reponses</code></pre>
<pre><code>## [1] pomme  orange poire  pomme  orange poire  pomme  orange poire 
## Levels: pomme orange poire</code></pre>
<pre class="r"><code>str(reponses)</code></pre>
<pre><code>##  Factor w/ 3 levels &quot;pomme&quot;,&quot;orange&quot;,..: 1 2 3 1 2 3 1 2 3</code></pre>
</div>
</div>
<div id="ajout-de-metadonnees-dans-un-facteur" class="section level2">
<h2>Ajout de métadonnées dans un facteur</h2>
<p>Les éléments d’un facteur peuvent être nommés, comme pour un vecteur.</p>
<pre class="r"><code>names(reponses) &lt;- letters[1:9]
reponses</code></pre>
<pre><code>##      a      b      c      d      e      f      g      h      i 
##  pomme orange  poire  pomme orange  poire  pomme orange  poire 
## Levels: pomme orange poire</code></pre>
<pre class="r"><code>str(reponses)</code></pre>
<pre><code>##  Factor w/ 3 levels &quot;pomme&quot;,&quot;orange&quot;,..: 1 2 3 1 2 3 1 2 3
##  - attr(*, &quot;names&quot;)= chr [1:9] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ...</code></pre>
</div>
<div id="extraction-delements-dun-facteur" class="section level2">
<h2>Extraction d’éléments d’un facteur</h2>
<p>L’extraction d’éléments d’un facteur se réalise comme avec un vecteur. Par exemple :</p>
<pre class="r"><code>extrait &lt;- reponses[1:2]
extrait</code></pre>
<pre><code>##      a      b 
##  pomme orange 
## Levels: pomme orange poire</code></pre>
<pre class="r"><code>nlevels(extrait)</code></pre>
<pre><code>## [1] 3</code></pre>
<p>Ici, aucun élément contenant la modalité <code>poire</code> n’est conservé. Pourtant, dans les métadonnées du facteur, il est encore inscrit que le facteur possède 3 niveaux. Pour effacer des métadonnées d’un facteur les niveaux non observés, il faut utiliser la fonction <code>droplevels</code>.</p>
<pre class="r"><code>extrait2 &lt;- droplevels(extrait)
extrait2</code></pre>
<pre><code>##      a      b 
##  pomme orange 
## Levels: pomme orange</code></pre>
<pre class="r"><code>nlevels(extrait2)</code></pre>
<pre><code>## [1] 2</code></pre>
</div>
<div id="les-facteurs-ordonnes" class="section level2">
<h2>Les facteurs ordonnés</h2>
<p>Il est possible de spécifier un ordre dans les valeurs des niveaux d’un facteur. Il ne s’agit pas ici simplement de l’ordre dans lequel sont placés les niveaux qui a été mentionné précédemment. Il s’agit plutôt des valeurs relatives des niveaux les uns par rapport aux autres. Pour une variable catégorique ordinale, les modalités ou niveaux de la variable peuvent être ordonnés. Il existe une structure de données R pour stocker une telle variable. Il s’agit des facteurs ordonnés.</p>
<p>Créons par exemple un facteur ordonné contenant des niveaux de satisfaction de clients.</p>
<pre class="r"><code>satisfaction &lt;- factor(c(&quot;très satisfait&quot;, &quot;satisfait&quot;, &quot;très satisfait&quot;, &quot;insatisfait&quot;, 
                         &quot;très satisfait&quot;, &quot;satisfait&quot;, &quot;satisfait&quot;),
                       levels = c(&quot;très insatisfait&quot;, &quot;insatisfait&quot;, &quot;satisfait&quot;, 
                                  &quot;très satisfait&quot;),
                       ordered = TRUE)
satisfaction</code></pre>
<pre><code>## [1] très satisfait satisfait      très satisfait insatisfait   
## [5] très satisfait satisfait      satisfait     
## 4 Levels: très insatisfait &lt; insatisfait &lt; ... &lt; très satisfait</code></pre>
<pre class="r"><code>str(satisfaction)</code></pre>
<pre><code>##  Ord.factor w/ 4 levels &quot;très insatisfait&quot;&lt;..: 4 3 4 2 4 3 3</code></pre>
<p>Grâce à l’argument <code>ordered = TRUE</code>, l’objet obtenu est plus qu’un facteur. Il s’agit d’un facteur ordonné. La distinction ente le facteur et le facteur ordonné est utilisée par certaines fonctions R, notamment des fonctions d’ajustement de modèles.</p>
<hr />
</div>
</div>
<div id="conversions" class="section level1">
<h1>Conversions de type de données</h1>
<p>Rappelons-nous que tous les éléments d’un objet atomique doivent être du même type. Que se passe-t-il alors si nous tentons de modifier un élément d’un vecteur pour le remplacer par une donnée d’un type différent du type des éléments d’origine dans le vecteur?</p>
<pre class="r"><code>de &lt;- c(2, 3, 4, 1, 2, 3, 5, 6, 5, 4)
str(de)</code></pre>
<pre><code>##  num [1:10] 2 3 4 1 2 3 5 6 5 4</code></pre>
<pre class="r"><code>de[1] &lt;- &quot;2&quot;
str(de)</code></pre>
<pre><code>##  chr [1:10] &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;5&quot; &quot;6&quot; &quot;5&quot; &quot;4&quot;</code></pre>
<p>Dans l’exemple ci-dessus, tous les éléments, à l’origine réels, sont devenus des chaînes de caractères, soit le type de la nouvelle donnée.</p>
<p>Voici un autre exemple.</p>
<pre class="r"><code>de[1] &lt;- FALSE
str(de)</code></pre>
<pre><code>##  chr [1:10] &quot;FALSE&quot; &quot;3&quot; &quot;4&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;5&quot; &quot;6&quot; &quot;5&quot; &quot;4&quot;</code></pre>
<p>Cette fois, c’est le type de la nouvelle donnée qui a été modifié pour être conforme aux éléments déjà présents dans le vecteur. La nouvelle donnée, à l’origine logique, a été transformée en chaîne de caractères.</p>
<p>Les exemples précédents illustrent la conversion implicite de types. Ces conversions sont qualifiées d’« implicites », car l’utilisateur n’a pas indiqué clairement à R ce qu’il doit faire. Il n’est pas possible de stocker dans un vecteur des éléments de types différents. Ce qui était demandé à R dans ces exemples était donc en théorie incorrect. Plusieurs langages de programmation génèrent une erreur suite à une telle tentative d’opération.</p>
<p>Cependant, R étant conçu pour des gens qui s’y connaissent parfois peu en informatique, il ne génère pas d’erreur. Il arrange les choses pour l’utilisateur. Il fait une conversion de type des données sans même imprimer un message d’avertissement. Lorsqu’il doit choisir entre deux types de données, il opte toujours pour le type le moins contraignant des deux. Pour les types que nous utiliserons dans ce cours, leur classement du moins contraignant au plus contraignant est le suivant :</p>
<blockquote>
<p>caractère &gt; réel &gt; entier &gt; logique.</p>
</blockquote>
<p>Afin de s’assurer de garder le contrôle de nos objets, il est aussi possible de réaliser des conversions explicites avec les fonctions <code>as.</code>(<code>character</code>/<code>numeric</code>/<code>double</code>/<code>integer</code>/<code>logical</code>/…). Une conversion est dite « explicite » lorsque l’utilisateur indique à R vers quel type faire la conversion.</p>
<p> </p>
<p><strong>Exemple</strong> : Comment créer un vecteur d’entiers?</p>
<ul>
<li>l’opérateur <code>':'</code> crée par défaut des vecteurs d’entiers lorsque la valeur de départ est un entier</li>
</ul>
<pre class="r"><code>vect1 &lt;- 1:3
str(vect1)</code></pre>
<pre><code>##  int [1:3] 1 2 3</code></pre>
<ul>
<li>la fonction <code>as.integer</code> effectue la conversion vers le type entier</li>
</ul>
<pre class="r"><code>vect2 &lt;- c(1,2,3)
str(vect2)</code></pre>
<pre><code>##  num [1:3] 1 2 3</code></pre>
<pre class="r"><code>vect3 &lt;- as.integer(vect2)
str(vect3)</code></pre>
<pre><code>##  int [1:3] 1 2 3</code></pre>
<ul>
<li>le caractère <code>L</code> placé tout de suite après un nombre entier (sans espace entre le nombre et <code>L</code>) est un indicateur du type entier</li>
</ul>
<pre class="r"><code>vect4 &lt;- c(1L,2L,3L)
str(vect4)</code></pre>
<pre><code>##  int [1:3] 1 2 3</code></pre>
<p> </p>
<div id="utilite-des-conversions-implicites-de-type" class="section level4">
<h4>Utilité des conversions implicites de type</h4>
<p>Nous éviter des erreurs!</p>
<p>Voici une assignation qui retourne le résultat escompté en R grâce aux conversions implicites de type, mais qui ne retournerait pas le résultat escompté dans certains autres langages.</p>
<pre class="r"><code>x &lt;- c(1L, 4L) # x est d&#39;abord créé avec le type entier
typeof(x)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>x[1] &lt;- 1/2
x</code></pre>
<pre><code>## [1] 0.5 4.0</code></pre>
<pre class="r"><code>typeof(x)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<p>L’objet <code>x</code> a changé le type de ses éléments afin de pouvoir garder en mémoire correctement la nouvelle donnée assignée à son premier élément. Dans d’autres langages, par exemple en C, la donnée <code>0.5</code> aurait été tronquée à <code>0</code>.</p>
</div>
<div id="conversions-explicites-de-chaines-de-caracteres-vers-des-nombres" class="section level4">
<h4>Conversions explicites de chaînes de caractères vers des nombres</h4>
<p>Il est même possible de convertir certains caractères en nombres. Lorsque la chaîne de caractères contient en fait des caractères numériques utilisant le point comme signe décimal, la conversion est directe avec <code>as.numeric</code> (ou <code>as.double</code> ou <code>as.integer</code>).</p>
<pre class="r"><code>vect5 &lt;- c(&quot;3.5&quot;, &quot;4.6&quot;, &quot;7&quot;)
as.numeric(vect5)  </code></pre>
<pre><code>## [1] 3.5 4.6 7.0</code></pre>
<p>Pour les cas particuliers, il faut plutôt utiliser la fonction <code>type.convert</code>.</p>
<pre class="r"><code>vect6 &lt;- c(&quot;3,5&quot;, &quot;4,6&quot;, &quot;-&quot;)
as.numeric(vect6)  </code></pre>
<pre><code>## Warning: NAs introduced by coercion</code></pre>
<pre><code>## [1] NA NA NA</code></pre>
<pre class="r"><code>type.convert(vect6, na.strings = &quot;-&quot;, dec = &quot;,&quot;)</code></pre>
<pre><code>## [1] 3.5 4.6  NA</code></pre>
<hr />
</div>
</div>
<div id="synthese" class="section level1">
<h1>Synthèse</h1>
<div id="contenant-versus-contenu" class="section level4">
<h4>Contenant versus contenu</h4>
<p><strong>Objet</strong> R servant de structure de données</p>
<p><span class="math inline">\(\qquad =\)</span> CONTENANT</p>
<p><strong>Éléments</strong> stockés dans cet objet</p>
<p><span class="math inline">\(\qquad =\)</span> CONTENU :</p>
<ul>
<li><strong>données</strong> : valeurs observées de variables aléatoires, valeurs de résultats de calculs (ex.: statistiques descriptives, coefficients d’une modèle), etc.</li>
<li><strong>métadonnées = attributs</strong> (souvent facultatives) :<br />
nom des éléments (par dimension), nombre d’éléments par dimension pour les matrices et arrays, niveaux d’un facteur, etc.</li>
</ul>
</div>
<div id="caracteristiques-des-structures-de-donnees-en-r" class="section level4">
<h4>Caractéristiques des structures de données en R</h4>
<ul>
<li>Type de l’objet : <code>is.</code>(<code>atomic</code>/<code>recursive</code>), <code>is.</code>(<code>vector</code>/<code>matrix</code>/<code>array</code>/<code>list</code>/<code>data.frame</code>/<code>factor</code>)</li>
<li>Type des données en éléments : <code>typeof</code>, <code>is.</code>(<code>numeric</code>/<code>character</code>/<code>logical</code>/…)
<ul>
<li>valeurs numériques (<code>numeric</code>):<br />
entières (<code>integer</code>) ou réelles (<code>double</code>)</li>
<li>chaînes de caractères (<code>character</code>)</li>
<li>valeurs logiques (<code>logical</code>)</li>
<li>types moins communs de valeurs :<br />
nombres complexes (<code>complex</code>), bits (<code>raw</code>), etc.</li>
<li>si éléments = sous-objets (par exemple pour une liste ou un data frame), <code>typeof</code> retourne la valeur <code>&quot;list&quot;</code></li>
</ul></li>
<li>Nombre total d’éléments : <code>length</code></li>
</ul>
</div>
<div id="types-de-structures-de-donnees-en-r" class="section level4">
<h4>Types de structures de données en R</h4>
<table>
<thead>
<tr class="header">
<th>Nombre de dimensions</th>
<th>Objets atomiques</th>
<th>Objets récursifs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td><strong>vecteur</strong></td>
<td><strong>liste</strong></td>
</tr>
<tr class="even">
<td>2</td>
<td><strong>matrice</strong></td>
<td><strong>data frame</strong></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\vdots\)</span></td>
<td><span class="math inline">\(\vdots\)</span></td>
<td></td>
</tr>
<tr class="even">
<td>n</td>
<td><strong>array</strong></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>Objets atomiques : Éléments = données toutes du même type</li>
<li>Objets récursifs : Éléments = objets de types quelconques</li>
</ul>
<p><strong>facteur</strong> = une généralisation du vecteur pour stocker les observations d’une variable catégorique</p>

</div>
<div id="attributs-selon-le-type-dobjet" class="section level4">
<h4>Attributs selon le type d’objet</h4>
<p>Fonctions pour extraire des attributs : <code>attributes</code> (tous les attributs), <code>attr</code> (un seul attribut), <code>names</code>, <code>dimnames</code>, <code>colnames</code>, <code>rownames</code>, <code>dim</code>, <code>nrow</code>, <code>ncol</code>, <code>class</code>, <code>levels</code>, etc.</p>
<table>
<thead>
<tr class="header">
<th>Type d’objet</th>
<th>names</th>
<th>dimnames</th>
<th>dim</th>
<th>class</th>
<th>levels</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>vecteur</td>
<td>(<span class="math inline">\(\checkmark\)</span>)</td>
<td>-</td>
<td>-</td>
<td><span class="math inline">\(\bullet\)</span></td>
<td>-</td>
</tr>
<tr class="even">
<td>matrice ou array</td>
<td>-</td>
<td>(<span class="math inline">\(\checkmark\)</span>)</td>
<td><span class="math inline">\(\checkmark\)</span></td>
<td><span class="math inline">\(\bullet\)</span></td>
<td>-</td>
</tr>
<tr class="odd">
<td>liste</td>
<td>(<span class="math inline">\(\checkmark\)</span>)</td>
<td>-</td>
<td>-</td>
<td><span class="math inline">\(\bullet\)</span></td>
<td>-</td>
</tr>
<tr class="even">
<td>data frame</td>
<td>(<span class="math inline">\(\checkmark\)</span>)</td>
<td>(<span class="math inline">\(\checkmark\)</span>, <span class="math inline">\(\bullet\)</span>)</td>
<td><span class="math inline">\(\bullet\)</span></td>
<td><span class="math inline">\(\checkmark\)</span></td>
<td>-</td>
</tr>
<tr class="odd">
<td>facteur</td>
<td>(<span class="math inline">\(\checkmark\)</span>)</td>
<td>-</td>
<td>-</td>
<td><span class="math inline">\(\checkmark\)</span></td>
<td><span class="math inline">\(\checkmark\)</span></td>
</tr>
</tbody>
</table>
<p>Légende :<br />
« - » = attribut non existant pour ce type d’objet<br />
« <span class="math inline">\(\checkmark\)</span> » = attribut existe (non obligatoire si encadré de parenthèses)<br />
« <span class="math inline">\(\bullet\)</span> » = métadonnée existante, mais pas dans les attributs obtenus avec la fonction <code>attributes</code></p>
</div>
<div id="extraction-delements-1" class="section level4">
<h4>Extraction d’éléments</h4>
<ul>
<li>Opérateurs d’indiçage :
<ul>
<li><code>[</code> : extrait un ou plusieurs éléments, préserve la structure de l’objet, sauf si une simplification est possible et <code>drop = TRUE</code> (<code>TRUE</code> est la valeur par défaut du paramètre);</li>
<li><code>[[</code> et <code>$</code> : extrait un seul élément, laisse tomber des attributs d’un objet atomique, sort de la structure d’un objet récursif<br />
(<code>$</code> s’utilise seulement avec des objets récursifs);<br />
</li>
</ul></li>
<li>Fonctions : <code>head</code>, <code>tail</code>, <code>subset</code>.</li>
</ul>
<p>Différentes façons d’identifier les éléments à extraire avec <code>[</code> :</p>
<ul>
<li>entier(s) positif(s) (entre 1 et la longueur de la dimension concernée) : <em>positions des éléments à conserver</em>,</li>
<li>entier(s) négatif(s) (entre 1 et la longueur de la dimension concernée) : <em>- positions des éléments à éliminer</em>,</li>
<li>chaîne(s) de caractères (possible seulement si les éléments sont nommés) : <em>noms des éléments à conserver</em>,</li>
<li>vecteur de logiques (doit être de la même longueur que celle de la dimension concernée) : <code>TRUE</code> <em>pour les éléments à conserver,</em> <code>FALSE</code> <em>pour ceux à éliminer.</em></li>
</ul>
</div>
<div id="remplacement-delements-dans-un-objet" class="section level4">
<h4>Remplacement d’éléments dans un objet</h4>
<p>Afin de modifier des éléments dans un objet, il faut soumettre une commande contenant les 3 composantes suivantes :</p>
<ol style="list-style-type: decimal">
<li>une extraction avec l’opérateur <code>[</code>, <code>[[</code> ou <code>$</code> pour identifier les éléments à remplacer (ou simplement le nom de l’objet s’il doit être remplacé dans son entièreté),</li>
<li>un opérateur d’assignation (<code>&lt;-</code>),</li>
<li>les valeurs de remplacement, dans une structure correspondant à la section à remplacer dans l’objet, <em>par exemple :</em></li>
</ol>
<pre class="r"><code>matriceA[1:2,3] &lt;- c(3,5)</code></pre>
<div id="regle-de-recyclage" class="section level5">
<h5>Règle de recyclage</h5>
<p>Lors d’une assignation ou de toute opération faisant intervenir 2 vecteurs de longueurs différentes, les éléments du vecteur le plus court sont répétés de façon à ce que ce vecteur devienne de la même longueur que le vecteur le plus long.</p>
</div>
</div>
<div id="conversions-de-types-de-donnees" class="section level4">
<h4>Conversions de types de données</h4>
<p>Les types de données communs, du moins contraignant au plus contraignant :</p>
<ul>
<li>caractères &gt; réels &gt; entiers &gt; logiques</li>
</ul>
<p>R fait automatiquement des <strong>conversions implicites</strong> en respectant cet ordonnancement des types de données</p>
<p>Fonctions R pour effectuer des <strong>conversions explicites</strong> :<br />
<code>as.</code>(<code>character</code>/<code>double</code>/<code>integer</code>/<code>logical</code>), <code>type.convert</code></p>
<div id="donnee-manquante" class="section level5">
<h5>Donnée manquante</h5>
<p>Peu importe le type, une <strong>donnée manquante</strong> est toujours représentée en R par <code>NA</code>.</p>
</div>
</div>
<div id="le-vecteur-1" class="section level4">
<h4>Le vecteur</h4>
<p>Simple objet atomique de dimension 1</p>
<ul>
<li>fonctions de création :
<ul>
<li><code>c</code>, <code>vector</code>, <code>as.vector</code>;</li>
<li>valeurs répétées : <code>rep</code>;</li>
<li>séquences régulières : <code>:</code>, <code>seq</code>;</li>
<li>chaînes de caractères : <code>paste</code>, <code>paste0</code>, constantes (<code>letters</code>, <code>LETTERS</code>, <code>month.name</code>, etc.).</li>
</ul></li>
<li>fonctions d’ajout de valeurs :
<ul>
<li>par concaténation d’un autre vecteur : <code>c</code>;</li>
<li><code>append</code>;</li>
</ul></li>
<li>comment réaliser une extraction avec un opérateur :
<ul>
<li><code>[</code> ou <code>[[</code> avec un seul argument.</li>
</ul></li>
</ul>
</div>
<div id="la-matrice-1" class="section level4">
<h4>La matrice</h4>
<p>Généralisation du vecteur à 2 dimensions</p>
<ul>
<li>fonctions de création :
<ul>
<li><code>matrix</code>, <code>as.matrix</code>;</li>
<li>en combinant des vecteurs par lignes : <code>rbind</code>;</li>
<li>en combinant des vecteurs par colonnes : <code>cbind</code>;</li>
</ul></li>
<li>fonctions d’ajout de valeurs :
<ul>
<li>par concaténation d’une autre matrice ou d’un vecteur :<br />
<code>rbind</code>, <code>cbind</code>;</li>
</ul></li>
<li>comment réaliser une extraction avec un opérateur :
<ul>
<li><code>[</code> ou <code>[[</code> avec deux arguments, soit un par dimension (ne pas fournir de valeur pour les dimensions à conserver complètes).</li>
</ul></li>
</ul>
</div>
<div id="le-array" class="section level4">
<h4>Le array</h4>
<p>Généralisation du vecteur ou de la matrice à une dimension quelconque</p>
<ul>
<li>fonctions de création :
<ul>
<li><code>array</code>, <code>as.array</code>;</li>
</ul></li>
<li>fonctions d’ajout de valeurs :
<ul>
<li>par concaténation d’un autre array :<br />
<code>abind</code> du package <code>abind</code> (pas vu dans le cours);</li>
</ul></li>
<li>comment réaliser une extraction avec un opérateur :
<ul>
<li><code>[</code> ou <code>[[</code> avec autant d’arguments qu’il y a de dimensions (ne pas fournir de valeur pour les dimensions à conserver complètes).</li>
</ul></li>
</ul>
</div>
<div id="la-liste-1" class="section level4">
<h4>La liste</h4>
<p>Objet récursif de dimension 1</p>
<ul>
<li>fonctions de création :
<ul>
<li><code>list</code>, <code>as.list</code>, <code>vector</code>;</li>
</ul></li>
<li>fonctions d’ajout de valeurs :
<ul>
<li>par concaténation avec <code>c</code>;</li>
</ul></li>
<li>comment réaliser une extraction avec un opérateur :
<ul>
<li><code>[</code> ou <code>[[</code> avec un seul argument,</li>
<li>ou encore $ pour extraire un élément nommée.</li>
</ul></li>
</ul>
</div>
<div id="le-data-frame-1" class="section level4">
<h4>Le data frame</h4>
<p>Objet récursif de dimension 2 conçu pour stocker</p>
<ul>
<li>des jeux de données (ligne = observation, colonne = variable)
<ul>
<li><span class="math inline">\(\approx\)</span> liste de vecteurs ou facteurs de même longueur,</li>
<li><span class="math inline">\(\approx\)</span> matrice avec valeurs de types pouvant varier entre colonnes;</li>
</ul></li>
<li>fonctions de création :
<ul>
<li><code>data.frame</code>, <code>as.data.frame</code>;</li>
</ul></li>
<li>fonctions d’ajout de valeurs :
<ul>
<li>par concaténation avec : <code>data.frame</code>, <code>cbind</code>, <code>rbind</code>;</li>
</ul></li>
<li>comment réaliser une extraction avec un opérateur :
<ul>
<li><code>[</code> ou <code>[[</code> avec 2 arguments, soit un par dimension,<br />
</li>
<li>ou encore $ pour extraire une colonne nommée.</li>
</ul></li>
</ul>
</div>
<div id="le-facteur-1" class="section level4">
<h4>Le facteur</h4>
<p>Généralisation du vecteur conçu pour stocker les valeurs observées d’une variable catégorique.</p>
<ul>
<li>fonctions de création : <code>factor</code>, <code>as.factor</code>;</li>
<li>fonctions en lien avec les niveaux du facteur :
<ul>
<li>pour extraire (ou modifier lorsqu’accompagné d’une assignation de valeurs) les niveaux : <code>levels</code>,</li>
<li>retourne le nombre de niveaux : <code>nlevels</code>,</li>
<li>pour éliminer des niveaux non présents : <code>droplevels</code>;</li>
</ul></li>
<li>comment réaliser une extraction avec un opérateur :
<ul>
<li><code>[</code> ou <code>[[</code> avec un seul argument.</li>
</ul></li>
</ul>
<hr />
</div>
</div>
<div id="references" class="section level1">
<h1>Références</h1>
<ul>
<li><p>R Core Team (2016). An Introduction to R.<br />
<a href="https://cran.r-project.org/doc/manuals/r-release/R-intro.html" class="uri">https://cran.r-project.org/doc/manuals/r-release/R-intro.html</a></p></li>
<li><p>R Core Team (2016). The R Language Definition.<br />
<a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html" class="uri">https://cran.r-project.org/doc/manuals/r-release/R-lang.html</a></p></li>
<li>Wickham, H. (2014). Advanced R. CRC Press.
<ul>
<li><a href="http://adv-r.had.co.nz/Data-structures.html" class="uri">http://adv-r.had.co.nz/Data-structures.html</a>,</li>
<li><a href="http://adv-r.had.co.nz/Subsetting.html" class="uri">http://adv-r.had.co.nz/Subsetting.html</a>.</li>
</ul></li>
</ul>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Ces définitions sont tirées de la référence suivante : Baillargeon, S., Rivest, L.-P., Simard, M., Ghazzali, N., Mérette, C., Belisle, C., Duchesne, T., Labbe, A. et Lakhal-Chaieb, L. (2013). Analyse de tableaux de fréquences : notes de cours, STT-4400/STT-6210. Université Laval, Département de mathématiques et de statistique.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
