---
title: "Calculs de base en R"
author: "Sophie Baillargeon, Université Laval"
date: "2020-01-20"
weight: 1
slug: "calculs_base_r"
categories: ["cours_2020-01-28"]
categories_weight: 1
lastmodifierdisplayname : "Sophie Baillargeon"
lastmodifieremail: "sophie.baillargeon@mat.ulaval.ca"
output:
  pdf_document: 
    toc: yes
    toc_depth: 3
    highlight: tango
  blogdown::html_page:
    toc: yes
    toc_depth: 3
    highlight: tango
header-includes:
- \usepackage{float}
- \usepackage[french]{babel}
- \frenchbsetup{StandardLayout}
- \hypersetup{colorlinks=true, urlcolor = {blue}, linkcolor = {blue}}
- \renewcommand{\linethickness}{0.05em}
---

***

R est un environnement spécialisé dans les calculs statistiques. Voyons comment réaliser de tels calculs en R, en se limitant pour l'instant à des calculs simples. Des fonctionnalités de R permettant de réaliser des calculs plus avancés (ex. réaliser des tests statistiques, ajuster des modèles, générer des observations aléatoires, faire de l'algèbre linéaire, etc.) seront vues dans un autre cours. Je présente ici des fonctionnalités utiles pour :

- implanter une formule mathématique;
- effectuer une transformation mathématique de variables dans un jeu de données;
- calculer des statistiques descriptives, par exemple dans le cadre d'une analyse exploratoire de données.


# Fonctionnement vectoriel et règle de recyclage

Tous les opérateurs et plusieurs des fonctions qui sont présentés dans cette fiche agissent de façon vectorielle. Ils effectuent un traitement élément par élément sur le ou les objets reçus en entrée.

Par exemple, si les deux matrices suivantes sont additionnées avec l'opérateur `+`,

```{r}
matrix(1:6 , nrow = 2, ncol = 3)
matrix(6:1 , nrow = 2, ncol = 3)
```

l'élément en position (i,j) dans la première matrice sera additionné à l'élément à la même position dans la deuxième matrice, et ce, pour toutes les positions. Le résultat de cette addition terme à terme est donc le suivant :

```{r}
matrix(1:6 , nrow = 2, ncol = 3) + matrix(6:1 , nrow = 2, ncol = 3)
```

&nbsp;

Si les deux objets intervenant dans l'opération ne sont pas de mêmes dimensions, la **règle de recyclage** s'applique. Cette règle avait déjà été mentionnée dans les notes sur les [structures de données en R](https://stt4230.rbind.io/manipulation_donnees/structures_r/#remplacement-delements). Étant donné son importance, revoyons-là plus en profondeur ici.

```{r}
x <- c(5, 6)
y <- c(2, 5, 3, 1)
x + y
```

L'instruction précédente effectue 4 additions, une pour chacun des 4 éléments du plus long des deux vecteurs dans l'opération, soit ici le deuxième. Le premier vecteur est plutôt de longueur 2. R répète donc ses éléments pour créer un vecteur aussi long que le deuxième

```{r}
rep(x, times = length(y)/length(x))
```

et effectue en réalité l'opération suivante :

```{r}
c(5, 6, 5, 6) + c(2, 5, 3, 1)
```

Cette règle de recyclage est exploitée, souvent sans que l'utilisateur en soit pleinement conscient,  lorsque l'un des deux vecteurs impliqués dans une opération est de longueur 1. Par exemple, la commande suivante impliquant un exposant,
```{r}
y ^ 2
```
est en fait traduite par R en la commande suivante :
```{r}
y ^ rep(2, times = length(y))
```

#### Règle de recyclage avec des objets à plus d'une dimension

\mbox{}

La règle de recyclage s'applique aussi dans des opérations faisant intervenir des objets à plus d'une dimension. Par exemple, pour additionner le même vecteur, disons
```{r}
y <- 3:1
y
```
à chacune des colonnes d'une matrice, disons
```{r}
mat <- matrix(1:12 , nrow = 3, ncol = 4)
mat
```
il suffit de lancer la commande suivante 
```{r}
mat + y
```
au lieu de la suivante, qui retourne exactement le même résultat.
```{r eval = FALSE}
mat + matrix(rep(y, times = length(mat)/length(y)), nrow = nrow(mat), ncol = ncol(mat))
```
Dans cette dernière commande, les deux arguments fournis à l'opérateur `+` sont réellement de mêmes dimensions, car la deuxième matrice est la suivante
```{r}
matrix(rep(y, length(mat)/length(y)), nrow = nrow(mat), ncol = ncol(mat))
```
Une règle de recyclage utilisée pour former une matrice de dimension appropriée va donc remplir la matrice une colonne à la fois, comme le fait la fonction `matrix` par défaut.

\newpage

#### Règle de recyclage lorsque la longueur de l'objet le plus long n'est pas multiple de la longueur de l'objet le plus court

\mbox{}

Lorsque la longueur de l'objet le plus long n'est pas multiple de la longueur de l'objet le plus court, la règle de recyclage fonctionne quand même. R recycle l'objet le plus court assez de fois pour arriver à un objet de longueur égale ou supérieure à l'objet le plus long. Ensuite, si l'objet recyclé est plus long que l'autre objet, il est tronqué de façon à ce que les deux objets aient la même longueur.

Prenons par exemple les deux vecteurs suivants :

```{r}
x <- 1:12
x
y <- 5:1
y
```

Supposons que la commande suivante soit soumise en R.

```{r eval = FALSE}
x + y
```

L'objet de gauche dans l'addition est de longueur 12 et l'objet de droite de longueur 5. L'objet de droite sera donc recyclé 3 fois,

```{r}
y_recycle <- rep(5:1, times = ceiling(length(x)/length(y)))
y_recycle
```

puis sa longueur sera réduite à la longueur de l'objet de gauche.

```{r}
length(y_recycle) <- length(x)
y_recycle
```

Ensuite l'addition terme à terme sera effectuée.

```{r}
x + y_recycle
```

Cependant, R émettra un avertissement pour nous informer qu'il a dû faire cet ajustement de longueur.

```{r eval = TRUE}
x + y
```

\newpage

# Fonctions et opérateurs pour des calculs mathématiques

## Opérateurs mathématiques

### Opérateurs arithmétiques

Voici une liste d'opérateurs arithmétiques disponibles en R :

- `+` : addition, 
- `-` : soustraction, 
- `*` : multiplication, 
- `/` : division,
- `^` : puissance, 
- `%/%` : division entière,
- `%%` : modulo = reste de la division entière.

Les premiers opérateurs sont usuels et ne requièrent aucune explication. Expliquons cependant brièvement les deux derniers opérateurs de cette liste.

#### Division entière et modulo

\mbox{}

L'opérateur `%/%` réalise une [division entière](https://fr.wikipedia.org/wiki/Division_euclidienne). Pour illustrer ce type de division, prenons l'exemple suivant.
```{r}
5 / 2
```
L'opérateur de division ordinaire `/` retourne un nombre réel. L'opérateur `%/%` retourne la partie entière du résultat obtenu avec `/`. La partie décimale est tronquée. 
```{r}
5 %/% 2
```
L'opérateur [modulo](https://fr.wikipedia.org/wiki/Modulo_(op%C3%A9ration)) `%%` retourne le reste de la division entière. Dans l'exemple traité ici, ce reste vaut 1 car 5 - 2*2 = 1.
```{r}
5 %% 2
```

**Astuces** :

- Cet opérateur est pratique pour tester si des nombres sont pairs ou impairs. Les nombres pairs sont des multiples de 2. Alors `x %% 2` retourne 0 pour les nombres pairs et 1 pour les nombres impairs.
- L'opérateur modulo peut aussi servir à tester si un nombre stocké sous le type `double` est en réalité un entier au sens mathématique. S'il s'agit d'un entier, `x %% 1` retournera 0.  


### Opérateurs de comparaison

Les opérateurs de comparaison permettent de comparer des valeurs. Ils retournent `TRUE` ou `FALSE`. Il s'agit des opérateurs suivants :
 
- `==` : égalité,
- `!=` : non-égalité,
- `>` : plus grand,
- `>=` : plus grand ou égal, 
- `<` : plus petit, 
- `<=` : plus petit ou égal.

\newpage

Supposons `x` et `y` les deux vecteurs numériques suivants.

```{r}
x <- c(2, 5, 7, 3)
y <- c(3, 5, 6, 4)
```

Comparons ces vecteurs à l'aide d'un opérateur de comparaison. Est-ce que les valeurs contenues dans `x` sont supérieures aux valeurs contenues dans `y` ?

```{r}
x > y
```

L'opérateur fonctionne de façon vectorielle, donc une comparaison est effectuée pour toutes les paires d'éléments à la même position dans les vecteurs `x` et `y`. Les valeurs dans le résultat retourné sont de type logique.

Les valeurs dans un vecteur peuvent aussi être comparées à une seule valeur, auquel cas la règle de recyclage s'applique.

```{r}
x != 5
```

#### Comparaison de valeurs non numériques

\mbox{}

Les opérateurs de comparaison ne fonctionnent pas seulement avec des valeurs numériques. Ils peuvent aussi être utilisés pour comparer des valeurs logiques ou caractères. Dans ce cas, il faut savoir que R considère que `FALSE` est inférieure à `TRUE`. 

```{r}
FALSE < TRUE 
```

Quant aux caractères, les opérateurs de comparaison utilisent l'ordre de classement des caractères pour déterminer, entre deux valeurs, celle qui est inférieure. Cet ordre dépend des paramètres régionaux de la session R. D'une langue à l'autre, cet ordre peut varier.

Pour connaître l'ordre utilisé dans une session R, les instructions suivantes sont utiles :

```{r eval = FALSE}
caracteres_speciaux <- 
  c("!", "\"", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", 
    "<", "=",">", "?", "@", "[", "\\", "]", "^", "_", "{", "|", "}", "~")
lettres_accentuees <- c("à", "â", "é", "è", "ê", "ë", "ï", "î", "ô", "ù", "ü", "û", "ç")
catacteres_ordonnes <- sort(c(caracteres_speciaux, 0:9, letters, LETTERS, 
                              lettres_accentuees, toupper(lettres_accentuees))) 
paste(catacteres_ordonnes, collapse = "")
```

J'ai obtenu le résultat suivant, qui sera peut-être différent sur votre ordinateur si vous n'avez pas les mêmes paramètres régionaux que moi.

```
"'-!\"#$%&()*,./:;?@[\\]^_{|}~+<=>0123456789aAàÀâÂbBcCçÇdDeEéÉèÈêÊëËfFgGhHiIîÎïÏjJkKlLmM
nNoOôÔpPqQrRsStTuUùÙûÛüÜvVwWxXyYzZ"
```

Ainsi, dans ma session R :

- les caractères spéciaux sont inférieurs aux chiffres et aux lettres, 
- les chiffres sont inférieurs aux lettres,
- les lettres sont classées en ordre alphabétique et
    + les lettres minuscules sont inférieures aux lettres majuscules,
    + les lettres non accentuées sont inférieures aux lettres accentuées.

Pour des chaînes à plus d'un caractère, la comparaison s'effectue caractère par caractère (premiers caractères comparés entre eux, puis deuxièmes en cas d’égalité, puis troisièmes en cas d'égalités aux deux premières positions, etc.). 

```{r}
"arborescence" < "arbre" 
```

Aussi, l’absence de caractères vaut moins que la présence.

```{r}
"a" < "aa"
```

**Remarque** : Afin de correctement ordonner des nombres, il faut s'assurer de les stocker sous un format numérique. S'ils sont stockés sous forme de chaînes de caractères, les résultats obtenus ne seront pas toujours ceux attendus, comme dans cet exemple pour lequel 2 est dit non inférieur à 10 lorsque les nombres sont fournis à l'opérateur de comparaison sous forme de chaînes de caractères.

```{r}
2 < 10
"2" < "10"
```


### Opérateurs et fonction logiques vectoriels

Un opérateur ou une fonction logique vectoriel prend en entrée un ou deux vecteurs de logiques et retourne un autre vecteur de valeurs logiques. Le R de base comporte les opérateurs et la fonction logiques vectoriels suivants :

- `!` : négation, 
- `&` : et,
- `|` : ou,
- `xor` : ou exclusif.

#### Opérateur de négation `!`

\mbox{}

L'opérateur `!` n'a qu'un seul argument, alors que les autres opérateurs logiques en ont deux. Il effectue une négation, donc transforme les `TRUE` en `FALSE` et les `FALSE` en `TRUE`.
```{r}
! c(TRUE, FALSE)
```


#### Opérateurs `&` et `|`, fonction `xor`

\mbox{}

Les opérateurs `&` et `|`, ainsi que la fonction `xor`, appliquent de façon vectorielle les [tables de vérité](https://fr.wikipedia.org/wiki/Table_de_v%C3%A9rit%C3%A9) des fonctions mathématiques logiques « et », « ou » et « ou exclusif » respectivement. 

**Rappel** : table de vérité de [« et »](https://fr.wikipedia.org/wiki/Conjonction_logique), [« ou »](https://fr.wikipedia.org/wiki/Disjonction_logique) et [« ou exclusif »](https://fr.wikipedia.org/wiki/Fonction_OU_exclusif)

```{r}
p <- rep(c(FALSE, TRUE), each = 2)
q <- rep(c(FALSE, TRUE), times = 2)
cbind(p, q, "p et q" = p & q, "p ou q" = p | q, "p xor q" = xor(p, q))
```

Ainsi, 

- l'instruction `x & y` retournera un vecteur contenant des `TRUE` aux positions pour lesquelles la valeur en `x` et la valeur en `y` sont toutes les deux `TRUE` et contenant des `FALSE` partout ailleurs;
- l'instruction `x | y` retournera un vecteur contenant des `FALSE` aux positions pour lesquelles la valeur en `x` et la valeur en `y` sont toutes les deux `FALSE` et contenant des `TRUE` partout ailleurs;
- l'instruction `xor(x, y)` retournera un vecteur contenant des `TRUE` aux positions pour lesquelles la valeur en `x` ou la valeur en `y` est `TRUE`, mais pas les deux, et contenant des `FALSE` partout ailleurs.


## Fonctions mathématiques agissant de façon vectorielle

R offre aussi plusieurs fonctions de calculs mathématiques, travaillant de façon vectorielle, dont les suivantes :

- racine carrée : `sqrt`;
- exponentielles et logarithmes : `exp`, `log` (= logarithme naturel), `log10`, `log2`;
- fonctions trigonométriques : `sin`, `cos`, `tan`, `acos`, `asin`, `atan`, `atan2`;
- fonctions relatives au signe : `abs`, `sign`;
- fonctions d'arrondissement : `ceiling`, `floor`, `round`, `trunc`, `signif`;
- fonctions reliées aux fonctions mathématiques [bêta](https://fr.wikipedia.org/wiki/Fonction_b%C3%AAta) et [gamma](https://fr.wikipedia.org/wiki/Fonction_gamma): `beta`, `gamma`, `factorial`, `choose`, etc.

Ces fonctions font un calcul distinct pour tous les éléments de l'objet fourni en entrée et retournent un résultat de même dimension que l'objet en entrée. Voici quelques exemples.

```{r}
# Vecteur de données numériques pour les exemples
x <- seq(from = -1.25, to = 1.5, by = 0.25)
x
# Arrondissement régulier au dixième près
round(x, digits = 1)
# Arrondissement à l'entier supérieur
ceiling(x)
# Arrondissement à la partie entière
trunc(x)
```

Ces fonctions arrivent aussi à effectuer des calculs par élément dans un objet atomique de dimension supérieure à un ou dans un data frame.

```{r}
# Matrice de données numériques pour les exemples
x_mat <- matrix(x, nrow = 2)
x_mat
# Extraction du signe
sign(x_mat)
```


## Fonctions mathématiques combinant des éléments

Certaines fonctions mathématiques en R effectuent des calculs faisant intervenir plus d'un élément de l'objet donné en entrée, plutôt que d'effectuer un calcul distinct pour chacun des éléments. C'est le cas des fonctions suivantes :

- somme ou produit de tous les éléments (retourne une seule valeur) : `sum`, `prod`;
- somme ou produit cumulatif des éléments (retourne un vecteur de même longueur que le vecteur en entrée) : `cummsum`, `cumprod`;
- différences entre des éléments : `diff`.

Voici quelques exemples.
```{r}
# Matrice de données numériques pour les exemples
mat <- matrix(c(2, 5, 3, 4, 6, 5, 4, 3, 1, 2, 9, 8), nrow = 3, ncol = 4)
mat
# Produit de tous les éléments
prod(mat)
# Somme cumulative des éléments (ici 2, 2+5, 2+5+3, 2+5+3+4, ...)
cumsum(mat)
```

#### Fonction `diff`

\mbox{}

Pour une matrice ou un data frame, `diff` calcule les différences terme à terme des éléments composant les lignes. Par défaut, la fonction calcule pour chaque ligne, à l'exception de la première, la différence entre la ligne et la ligne au-dessous.

```{r diff}
diff(mat)
```
La commande suivante retourne donc le même résultat que la précédente. 
```{r}
mat[-1, ] - mat[-nrow(mat), ]
```
Pour un vecteur, la fonction `diff` retourne les différences entre un élément (sauf le premier) et l'élément précédent. 
```{r}
diff(c(2, 5, 3, 4))
```
La fonction `diff` peut calculer des différences entre les éléments séparés par plus d'une position grâce à l'argument `lag`, comme dans cet exemple. 
```{r}
diff(c(2, 5, 3, 4), lag = 2)
# soustractions effectuées : 3-2 et 4-5
```


## Fonctions d'opérations sur des ensembles

Les fonctions R d'[opérations sur des ensembles](https://fr.wikipedia.org/wiki/Alg%C3%A8bre_des_parties_d%27un_ensemble) sont les suivantes : 

- `union` : union, 
- `intersect` : intersection, 
- `setdiff` : différence, 
- `setequal` : test d'égalité, 
- `is.element` : test d'inclusion.

Voici quelques exemples utilisant les deux ensembles suivants, stockés sous forme de vecteur :

```{r}
A <- c("m", "s", "e", "f", "m")
B <- c("m", "e", "h", "i")
```

Union de tous les éléments des ensembles `A` et `B`, en retirant les doublons :

```{r}
union(A, B)
```

Identification des éléments communs entre `A` et `B`, en retirant les doublons :

```{r}
intersect(A, B)
```

Identification des éléments de `A` ne se retrouvant pas dans `B`, en retirant les doublons :

```{r}
setdiff(A, B)
```

Test sur l'égalité entre les ensembles `A` et `B` :

```{r}
setequal(A, B)
```

Test sur la présence de `"d"` et `"e"` dans l'ensemble `A` :

```{r}
is.element(el = c("d", "e"), set = A)
```

## Mots-clés mathématiques

En R, le nombre $\pi$ est représenté par le mot-clé `pi`.
```{r}
pi
```

`Inf` est le symbole R pour l'infini $\infty$.
```{r}
-5 / 0
```

`NaN` est un mot-clé signifiant *Not A Number*. Ce mot-clé est retourné par R lorsqu'un utilisateur lui demande d'effectuer une opération mathématique impossible, par exemple :
```{r}
log(-1)
```

**Rappel** : Attention à ne pas confondre le mot-clé `NaN` avec le mot-clé `NA` qui signifie plutôt *Not Available* et qui sert à représenter les données manquantes.


***


# Fonctions pour le calcul de statistiques descriptives

## Fonctions retournant une seule statistique

Certaines fonctions de calcul de statistiques descriptives retournent en sortie une seule valeur. C'est le cas des fonctions suivantes :

- [mesures de position](https://fr.wikipedia.org/wiki/Indicateur_de_position) : `min`, `max`;
- [mesures de tendance centrale](https://fr.wikipedia.org/wiki/Indicateur_de_tendance_centrale) : `mean`, `median`;
- [mesure de dispersion](https://fr.wikipedia.org/wiki/Indicateur_de_dispersion) : `sd` (écart-type).

Utilisons le jeu de données `cars` du package `datasets` pour présenter quelques exemples. Ce jeu de données contient 50 observations de 2 variables numériques.

```{r}
str(cars)

# Moyenne des observations de la variable dist
mean(cars$dist)
```

Si l'objet en entrée a plus d'une dimension, la sortie est tout de même de longueur 1. Donc tous les éléments contenus dans l'objet sont mis en commun pour faire le calcul.
```{r}
max(cars)
```

#### Fonctions `which.max` et `which.min`

\mbox{}

Les fonctions `min`  et `max` retournent respectivement la valeur la plus petite et la valeur la plus grande parmi les éléments d'un objet. Les fonctions `which.max` et `which.min` retournent pour leur part la position dans l'objet du **premier** maximum ou minimum.  
```{r}
which.min(cars$speed)
```

Dans l'exemple précédent, il y a en fait deux observations qui prennent la valeur minimum de `min(cars$speed)`. La commande suivante permet de trouver la position de toutes les observations prenant la valeur minimale.

```{r}
which(cars$speed == min(cars$speed))
```

<!--Nous reviendrons sur la fonction `which` à la fin de cette fiche.-->


### Traitement des observations manquantes et argument `na.rm`

Les fonctions `min`, `max`, `mean`, `median` et `sd`, ainsi que quelques autres fonctions vues dans ces notes, ont un argument en commun nommé `na.rm`. Cet argument sert à indiquer à la fonction comment agir en présence de données manquantes (`NA`). Par défaut, `na.rm` prend la valeur `FALSE` pour ces fonctions. Cette valeur signifie que les données manquantes ne doivent pas être retirées avant d'effectuer le calcul. Cependant, en présence de données manquantes, ces fonctions ne sont pas en mesure de calculer des statistiques. Par exemple, supposons que nous voulions calculer la médiane des données dans le vecteur suivant.

```{r}
x <- c(3, 6, NA, 8, 11, 15, 23)
```

Si nous ne retirons pas la donnée manquante, nous obtenons le résultat suivant.

```{r}
median(x)
```

Ce résultat s'explique par le fait que la valeur de la médiane dépend de toutes les observations, incluant l'observation manquante, qui est inconnue. La valeur de la médiane est donc elle aussi inconnue. Pour calculer plutôt la médiane des observations non manquantes, il faut donner la valeur `TRUE` à l'argument `na.rm` comme suit.

```{r}
median(x, na.rm = TRUE)
```

Notons que la fonction `na.omit` permet de retirer les observations manquantes d'un objet R. Si l'objet est un vecteur, les éléments contenant `NA` sont retirés.

```{r}
na.omit(x)
```

La fonction `na.omit` ajoute deux attributs à l'objet, dont un pour identifier les observations retirées. 

Remarquons que les deux commandes suivantes retournent le même résultat.

```{r}
median(x, na.rm = TRUE)
median(na.omit(x))
```


Si la fonction `na.omit` reçoit en entrée une matrice ou un data frame, elle retire toutes les lignes contenant au moins un `NA`, comme dans cet exemple :

```{r}
exJeu <- data.frame(x, y = c(2, NA, 8, 9, 6, NA, 2)); 
exJeu
na.omit(exJeu)
```



## Fonctions pouvant retourner plusieurs statistiques

D'autres fonctions peuvent retourner plus d'une statistique, notamment les fonctions suivantes :

- mesures de position : `range`, `quantile`;
- résumé comprenant plusieurs mesures : `summary`;
- variances, covariances et corrélations : `var`, `cov`, `cor`.

#### Fonctions `range` et `quantile`

\mbox{}

La fonction `range` retourne à la fois le minimum est le maximum, comme dans cet exemple :
```{r range}
range(cars$speed)
```
Une façon simple d'obtenir l'étendue d'observations à partir de la sortie de la fonction `range` est de procéder comme suit :
```{r}
diff(range(cars$speed))
```

La fonction `quantile` calcule des quantiles empiriques. Par défaut, elle retourne le minimum, le maximum et les quartiles, comme dans cet exemple :
```{r quantile}
quantile(cars$speed)
```
L'argument `probs` permet de demander n'importe quels quantiles. Dans l'exemple suivant, les premiers et neuvièmes déciles sont demandés.
```{r}
quantile(cars$speed, probs = c(0.1, 0.9))
```

**Remarque** : Il existe plusieurs façons de calculer des quantiles. La fonction `quantile` implémente 9 algorithmes de calcul de quantiles (voir [`help(quantile)`](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/quantile.html)).


#### Fonction `summary`

\mbox{}

La fonction `summary` retourne les statistiques suivantes selon l'entrée qu'elle reçoit : 

- vecteur numérique : minimum, premier quartile, médiane, moyenne, troisième quartile, maximum;
- facteur : fréquences des modalités (comme la fonction `table` vue plus loin);
- matrice ou data frame : la fonction `summary` est appliquée séparément à chacune des colonnes.

Utilisons le jeu de données `Puromycin` du package `datasets` pour présenter quelques exemples d'utilisation de la fonction `summary`. Ce jeu de données contient 23 observations de 3 variables, dont deux numériques et une catégorique, stockée sous forme de facteur.

```{r}
str(Puromycin)

# Vecteur numérique en entrée :
summary(Puromycin$rate)

# Facteur en entrée :
summary(Puromycin$state)

# Data frame entier en entrée :
summary(Puromycin)
```


#### Fonctions `var`, `cov` et `cor`

\mbox{}

La fonction `var` peut prendre en entrée un vecteur ou un objet à deux dimensions. Si elle reçoit en entrée un vecteur, elle calcule la variance empirique de toutes les valeurs, comme dans cet exemple : 
```{r var}
var(cars$speed)
```
Cependant, si elle reçoit en entrée une matrice ou un data frame de valeurs numériques, elle considère que chaque colonne contient les observations d'une variable aléatoire. Elle va calculer une [matrice de variances-covariances](https://fr.wikipedia.org/wiki/Covariance), comme dans cet exemple :
```{r}
var(cars)
```
La fonction `cov` fait exactement le même calcul par défaut. 
```{r}
cov(cars)
```
Elle peut cependant calculer des covariances de Kendall ou de Spearman (toutes deux des statistiques non paramétriques basées sur les rangs des observations) au lieu de la covariance classique de Pearson. La fonction `cor` calcule des corrélations plutôt que des covariances. Elle aussi peut utiliser les définitions de [Pearson](https://fr.wikipedia.org/wiki/Corr%C3%A9lation_(statistiques)) (par défaut), [Kendall](https://fr.wikipedia.org/wiki/Tau_de_Kendall) et [Spearman](https://fr.wikipedia.org/wiki/Corr%C3%A9lation_de_Spearman). Voici un exemple de calcul de matrice de corrélations de Spearman.
```{r}
cor(cars, method = "spearman")
```


## Fonctions retournant un vecteur de statistiques

Certaines fonctions, telles que les suivantes, retournent autant de statistiques qu'il y a d'éléments dans l'objet donné en entrée.

- mesures de position : `cummin`, `cummax`, `pmin`, `pmax`;
- rangs : `rank`.

#### Fonctions `cummin` et `cummax`

\mbox{}

Les fonctions `cummin` et `cummax` calculent les minimums et les maximums cumulatifs. Comme nous pouvons le constater dans l'exemple suivant, la valeur en position `i` du vecteur retourné par une de ces deux fonctions est la valeur minimale ou maximale dans le sous-vecteur `x[1:i]`.
```{r}
cummin(x = c(-2, 4, -3, 4, 7, -6, 0))
```

#### Fonctions `pmin` et `pmax` 

\mbox{}

Les fonctions `pmin` et `pmax` calculent le minimum et le maximum par position, entre autant de vecteurs que désiré, comme dans l'exemple suivant. 
```{r}
pmax(c(-2, 4, -3, 4, 7, -6, 0), 
     c( 1, 2,  3, 4, 5,  6, 7),
     c( 5, 0, -2, 4, 5,  3, 3))
```
Ces fonctions sont utiles pour remplacer des valeurs par un seuil. Par exemple, l'instruction suivante permet de remplacer par zéro toute valeur négative contenue dans le vecteur en entrée.
```{r}
pmax(c(-2, 4, -3, 4, 7, -6, 0), 0)
```

#### Fonction `rank`

\mbox{}

Certains tests statistiques non paramétriques utilisent des statistiques basées sur les rangs des observations. Voici un exemple d'obtention de ces rangs avec la fonction `rank`.
```{r rank}
rank(c(-2, 4, -3, 4, 7, -6, 0))
```
Par défaut, en cas d'égalité, le rang moyen est utilisé. Pour changer cette option, il faut modifier la valeur de l'argument `ties.method`. Dans l'exemple suivant, le rang minimum est retourné en cas d'égalité.
```{r}
rank(c(-2, 4, -3, 4, 7, -6, 0), ties.method = "min")
```


## Fonctions de calcul de fréquences

Les fonctions `table`, `xtabs` et `ftable` permettent de calculer des fréquences.

Voici un petit jeu de données pour illustrer l'utilisation de ces fonctions. Il contient des observations concernant 7 individus fictifs : la couleur de leurs yeux, la couleur de leurs cheveux et leur genre.
```{r}
sondage <- data.frame(
  yeux    = c("brun",    "brun",     "bleu",    "brun",    "vert",     "brun",    "bleu"),
  cheveux = c("brun",    "noir",     "blond",   "brun",    "brun",     "blond",   "brun"),
  genre   = c("féminin", "masculin", "féminin", "féminin", "masculin", "féminin", "masculin")
)
sondage
```

#### Fonctions `table`

\mbox{}

La fonction `table` permet de compter le nombre d'occurrences de chacune des modalités d'une variable catégorique dans des données. Demandons, par exemple, à `table` de compter le nombre d'individus dans les données `sondage` classés dans chacune des catégories de couleurs de cheveux. 
```{r table}
table(sondage$cheveux)
```

La fonction `table` produit un tableau de fréquences à une variable si elle reçoit les observations d'une seule variable. Elle peut aussi produire des tableaux de fréquences croisées à deux variables ou plus.

```{r}
# Exemple de tableau de fréquences à deux variables (avec variables nommées)
table(yeux = sondage$yeux, cheveux = sondage$cheveux)
```

```{r}
# Exemple de tableau de fréquences à trois variables (data frame en entrée à table)
t3 <- table(sondage)
t3
```


#### Fonctions `ftable`

\mbox{}

La fonction `ftable` retourne un tableau de fréquences sous la forme d'une table « plate » (en anglais *flat*, d'où le `f` dans le nom de la fonction) dans le cas d'un croisement de 3 variables ou plus, plutôt que sous la forme d'un array comme le fait la fonction `table`. Elle accepte les mêmes types d'entrées que `table` (série d'objets atomiques à une dimension ou objet récursif dont les éléments sont interprétables en facteurs) et peut aussi recevoir une sortie de la fonction `table`, comme dans l'exemple suivant.

```{r}
ftable(t3)
```


#### Fonctions `xtabs`

\mbox{}

La fonction `xtabs` fait le même calcul que les fonctions précédentes, mais elle prend en entrée une formule. Le tableau de fréquences à deux variables créé précédemment peut être réobtenu de la façon suivante avec `xtabs`.

```{r}
xtabs(~ yeux + cheveux, data = sondage)
```

La fonction `xtabs` est utile lorsque les données que nous avons en main contiennent déjà des fréquences, car il est possible d'inclure une variable réponse contenant des dénombrements dans la formule que nous lui fournissons en entrée. Par exemple, `xtabs` permet de facilement retrouver le tableau de fréquences marginales croisées entre les variables `yeux` et `cheveux` à partir du tableau de fréquences à trois variables produit précédemment mis sous forme de data frame, qui a l'allure suivante.

```{r}
t3_df <- as.data.frame(t3)
t3_df
```

Il suffit de procéder comme suit :

```{r}
t2 <- xtabs(Freq ~ yeux + cheveux, data = t3_df)
t2
```


#### Autres fonctions relatives au calcul de fréquences

\mbox{}

Les fonctions `margin.table`, `addmargins` et `prop.table` permettent de calculer des fréquences marginales ou relatives à partir d'un tableau de fréquences. Voici quelques exemples d'utilisation de ces fonctions exploitant le tableau de fréquences à deux variables produit ci-dessus.

```{r}
# Fréquences marginales en colonnes :
margin.table(t2, margin = 2)

# Fréquences marginales ajoutées au tableau :
addmargins(t2)

# Fréquences relatives croisées :
prop.table(t2)

# Fréquences relatives conditionnelles à la variable yeux :
prop.table(t2, margin = 1)
```


#### Transformation du format d'un objet de classe `"table"`

\mbox{}

Les fonctions `table` et `xtabs` attribuent à l'objet qu'ils retournent en sortie la classe `"table"`, comme nous pouvons le constater en observant l'objet `t2`. 

```{r}
attributes(t2)
str(t2)
```

Il est parfois utile de transformer un objet de classe `"table"` en un array (matrice si la table croise deux variables) ou un data frame. Pour la transformation en array, il suffit de retirer l'attribut `class` avec la fonction `unclass`, comme dans cet exemple :

```{r}
str(unclass(t2))
```

Comme nous avons pu le constater dans un exemple précédent, la transformation en data frame crée pour sa part un jeu de données contenant une ligne par combinaison distincte des niveaux des facteurs croisés dans la table. Le data frame obtenu comporte une colonne par facteur, ainsi qu'une colonne nommée `Freq` contenant les fréquences dans la table. En voici un exemple :

```{r}
str(as.data.frame(t2))
```

## Fonctions pour l'énumération de combinaisons

Un fonction utile pour énumérer toutes les combinaisons des niveaux d'un facteur est `expand.grid`. Par exemple, retrouvons avec cette fonction toutes les combinaisons présentes dans le data frame `t3_df` créé précédemment.

```{r}
expand.grid(yeux = c("bleu", "brun", "vert"),
            cheveux = c("blond", "brun", "noir"),
            genre = c("féminin", "masculin"))
```

Il faut fournir en entrée à `expand.grid` les valeurs à combiner. Si les vecteurs ou facteurs contenant ces valeurs sont fournis avec des noms, comme dans l'exemple précédent (via les assignations), les colonnes du data frame retourné en sortie par `expand.grid` porteront ces noms.

Une autre fonction R permet d'énumérer des combinaisons possibles : la fonction `combn`. Il s'agit de combinaisons au sens mathématique cette fois, donc « de dispositions non ordonnées d'un certain nombre d'éléments d'un ensemble »[^1]. Par exemple, voici toutes les combinaisons possibles de 3 éléments parmi l'ensemble `c("Ève", "Jean", "Mia", "Paul")`, trouvées par la fonction `combn`.

```{r}
combn(x = c("Ève", "Jean", "Mia", "Paul"), m = 3)
```

Contrairement à `expand.grid` qui présente les combinaisons possibles ligne par ligne, chaque colonne de la sortie produite par `combn` représente une combinaison possible.

[^1]: Cette définition est tirée du site web suivant : http://www.alloprof.qc.ca/BV/pages/m1346.aspx

\newpage

Notons finalement que la fonction `choose` mentionnée précédemment permet de compter le nombre de combinaisons possibles de `k` éléments d'un ensemble de taille `n`. Elle calcule donc le [coefficient binomial](https://fr.wikipedia.org/wiki/Coefficient_binomial) ${n\choose k}$. 

```{r}
# Nombre de combinaisons possibles dans l'exemple précédent :
choose(n = 4, k = 3)
```



## Fonctions pour le traitement des observations dupliquées

Il est parfois utile de gérer les observations dupliquées dans un jeu de données. En R, les fonctions suivantes sont utiles avec des observations dupliquées :

- pour tester la présence d'observations dupliquées : `duplicated`,
- pour retirer les observations dupliquées : `unique`.

Une observation est ici définie par l'ensemble des valeurs observées de toutes les variables pour un individu (ou une unité) de la population statistique à l'étude. Donc une observation dupliquée est une ligne répétée (donc deux lignes ou plus complètement identiques) dans une matrice ou un data frame. Dans le cas d'une seule variable, stockée dans un vecteur, une observation dupliquée est une valeur présente plus d'une fois dans le vecteur.

Pour illustrer l'emploi des fonctions `duplicated` et `unique`, réutilisons le jeu de données `sondage`. Ce jeu de données contient une observation dupliquée.
```{r}
sondage
```
En effet, les lignes 1 et 4 sont identiques. La fonction `duplicated` identifie la 4e observation comme une duplication d'une autre observation.
```{r}
duplicated(sondage)
```
L'observation peut être retirée avec la fonction `unique` comme suit.
```{r}
unique(sondage)
```
Si elles reçoivent un vecteur en entrée, les fonctions `duplicated` et `unique` réagissent comme suit.
```{r}
duplicated(c(1, 3, 2, 1, 2, 1))
unique(c(1, 3, 2, 1, 2, 1))
```



***

# Fonctions de la famille des `apply`

R propose plusieurs fonctions, dites « de la famille des `apply` », qui ont pour but d'appliquer itérativement une autre fonction sur des sous-sections d'un objet. Les grandes étapes d'un traitement effectué par une de ces fonctions sont les suivantes :

- séparer un objet en sous-objets;
- répéter la même action pour tous les sous-objets : appeler une fonction en lui donnant comme premier argument le sous-objet;
- combiner les résultats obtenus.

Ces fonctions cachent en fait des boucles. Les fonctions de la famille des `apply` sont utiles pour :

- obtenir des statistiques marginales à partir d'une matrice ou d'un array,
- appliquer le même traitement à tous les éléments d'une liste, 
- calculer des statistiques descriptives selon les niveaux de facteurs,
- effectuer des calculs en parallèle (nous y reviendrons plus tard),
- etc.

Nous verrons ici les fonctions : `apply`, `lapply`, `sapply`, `mapply`, `tapply`, `by` et `aggregate`.

## Fonction `apply`

Si elle reçoit comme premier argument une matrice, la fonction `apply` appelle en boucle une fonction en lui donnant en entrée l'une après l'autre chacune des lignes ou des colonnes d'une matrice. Voici un exemple.
```{r}
mat <- matrix(1:12, nrow = 3, ncol = 4, byrow = TRUE)
mat[2,3] <- NA
mat

# Calcul sur chaque ligne :
apply(mat, MARGIN = 1, FUN = mean)

# Calcul sur chaque colonne :
apply(mat, MARGIN = 2, FUN = mean)
```

Pour ajouter un argument à envoyer à la fonction `FUN`, il suffit de l'ajouter à la liste des arguments fournis, préférablement en le nommant. C'est l'argument `...` qui permet ce transfert d'arguments entre une fonction principale et une fonction présente dans le corps de la fonction principale.
```{r}
apply(mat, MARGIN = 2, FUN = mean, na.rm = TRUE)
```

La fonction retourne une liste si `FUN` retourne plus d'une valeur.
```{r}
apply(mat, MARGIN = 1, FUN = summary)
```

De façon plus générale, la fonction `apply` peut itérer sur des sous-objets créés à partir d'un array à plus de deux dimensions.

```{r}
arr <- array(1:12, dim = c(2, 3, 2))
arr
apply(arr, MARGIN = c(1, 2), FUN = sum)
```

Si elle reçoit en entrée un data frame, elle le transformera en matrice avant d'effectuer les calculs.


### Fonctions raccourcies : `rowSums`, `colSums`, `rowMeans` et `colMeans`

Pour le calcul de sommes et de moyennes par lignes ou colonnes d'une matrice, il existe des fonctions raccourcies à la fonction `apply` : `rowSums`, `colSums`, `rowMeans`, `colMeans`. Par exemple :

```{r}
colMeans(mat, na.rm = TRUE)
```
est équivalent à `apply(mat,  MARGIN = 2, FUN = mean, na.rm = TRUE)` et
```{r}
rowSums(mat, na.rm = TRUE)
```
est équivalent à `apply(mat,  MARGIN = 1, FUN = sum, na.rm = TRUE)`.

Ces fonctions spécialisées ont été optimisées en termes de temps d'exécution.


## Fonctions `lapply`, `sapply` et `mapply`

Les fonctions `lapply`, `sapply` et `mapply` prennent en entrée un vecteur ou une liste (qui peut aussi être un data frame) et appliquent une fonction sur chaque élément de cet objet. Voici une liste qui sera utilisée pour illustrer l'emploi de ces fonctions. Cette liste contient les mots formant trois courtes phrases (ponctuation omise).

```{r}
phrases <- list(
  phrase1 = c("regarde", "la", "belle", "neige"),
  phrase2 = c("allons", "skier"),
  phrase3 = c("non", "il", "fait", "trop", "froid")
)
```


#### Fonction `sapply` :

\mbox{}

Supposons que nous voulons isoler le dernier mot de chaque phrase dans la liste `phrases`. L'action que nous souhaitons réaliser revient à extraire le dernier élément d'un vecteur. Elle doit être réalisée pour tous les vecteurs qui sont des éléments de la liste `phrases`. Nous pourrions réaliser cette tâche avec la commande suivante.

```{r}
derniers_mots <- sapply(phrases, FUN = tail, n = 1)
derniers_mots
```

Décortiquons maintenant cette commande. L'instruction `sapply(phrases, FUN = tail, n = 1)` permet d'appliquer la fonction `tail` à chaque élément de la liste `phrases`. Ces éléments sont tous des vecteurs. L'argument `n = 1` est passé à la fonction `tail`. Ainsi, seul le dernier élément de chaque vecteur est extrait. C'est comme si nous avions soumis la commande 

```{r eval = FALSE}
tail(phrases[[i]], n = 1)
```

séparément pour tous les éléments, donc pour `i` = 1, 2 et 3, puis que nous avions rassemblé les résultats.


#### Utilisation d'un opérateur comme valeur de l'argument `FUN` :

\mbox{}

Si nous cherchions plutôt à isoler le deuxième mot de chaque phrase dans la liste `phrases`, nous pourrions réaliser cette extraction avec la commande suivante.
```{r}
sapply(phrases, FUN = '[', 2)
```
Dans cet exemple, la fonction à appliquer est en fait l'opérateur d'extraction du crochet simple. Rappelons que les opérateurs sont en fait des fonctions. Donc, pour un vecteur quelconque, disons
```{r}
x <- phrases[[1]]
```
les commandes suivantes sont équivalentes.
```{r}
x[2]
'['(x, 2)
```
Ainsi, l'objet duquel nous voulons extraire est le premier argument à fournir à l'opérateur `[`. L'identifiant de l'élément à extraire (ici un entier représentant une position) est le deuxième argument à fournir à l'opérateur `[`. Si l'objet avait plus d'une dimension, il suffirait d'ajouter des arguments.

Lorsque l'argument `FUN` d'une fonction de la famille des `apply` est un opérateur, il faut toujours l'encadrer de guillemets (simples ou doubles).

#### Fonction `lapply` :

\mbox{}

La fonction `lapply` fait exactement le même calcul que la fonction `sapply`, mais retourne le résultat sous la forme d'une liste plutôt que sous une forme simplifiée. Voici un appel à `lapply` équivalent à l'appel à `sapply` qui a permis de créer `derniers_mots`. Les valeurs en sortie n'ont pas changé, mais elles sont stockées dans une liste plutôt que dans un vecteur.

```{r}
lapply(phrases, FUN = tail, n = 1)
```

#### Fonction `mapply` :

\mbox{}

Il aurait aussi été possible de solutionner le problème de l'extraction des derniers mots des phrases en utilisant la fonction `mapply`. La différence entre cette fonction et les fonctions `sapply` et `lapply` est qu'elle peut fournir à la fonction `FUN` plusieurs (ou de multiples, d'où le `m` dans `mapply`) arguments qui sont des vecteurs ou des listes.

Par exemple, nous pourrions extraire les derniers mots en appliquant l'opérateur `[` à chaque élément de la liste `phrases`, mais en spécifiant comme argument pour l'opérateur d'extraction la position du dernier élément. Cette position diffère un peu d'un élément à l'autre. Elle est égale à la longueur de l'élément.

Nous pourrions donc, dans un premier temps, calculer la longueur de chaque élément de `phrases` comme suit :

```{r}
longueurs_phrases <- sapply(phrases, length)
longueurs_phrases
```

Ayant en main un vecteur contenant les longueurs, nous pouvons utiliser `mapply` pour extraire les derniers éléments des vecteurs dans `phrases` par la commande suivante :

```{r}
mapply(FUN = "[", phrases, longueurs_phrases)
```

La boucle cachée derrière cet appel à la fonction `mapply` est la suivante : pour `i` allant de 1 à `r length(phrases)`, soit le nombre total d'éléments dans la liste `phrases`, l'extraction suivante est effectuée.

```{r, eval = FALSE}
"["(phrases[[i]], longueurs_phrases[[i]])
```

\newpage

Voici un autre exemple d'utilisation de la fonction `mapply`. Supposons que nous possédons trois listes contenant des vecteurs numériques, dont la longueur est la même selon la position, telles que les listes suivantes.

```{r}
liste1 <- list(c(1, 2, 3, 4, 5), c(1, 2, 3))
liste2 <- list(c(3, 5, 4, 2, 3), c(3, 4, 2))
liste3 <- list(c(0, 3, 9, 8, 6), c(7, 5, 0))
```

Nous pourrions utiliser `mapply` pour former des matrices en concaténant en lignes tous les vecteurs à la même position dans les listes, comme suit :

```{r}
mapply(FUN = rbind, liste1, liste2, liste3)
```

La fonction `mapply` est capable d'itérer sur les éléments d'un nombre indéterminé de vecteurs ou de listes.


## Fonctions `tapply`, `by` et `aggregate`

Ces fonctions appliquent elles aussi la même fonction à plusieurs sous-objets. Ce qui les distingue des autres fonctions de la famille des `apply` est la formation des sous-objets, qui se réalise cette fois selon les niveaux de facteurs.

Nous allons reprendre le jeu de données `Puromycin` pour illustrer l'utilisation de ces fonctions.

```{r}
str(Puromycin)
```

#### Fonction `tapply` :

\mbox{}

Nous pourrions par exemple calculer la moyenne de la variable `rate` selon les niveaux du facteur `state` comme suit.
```{r}
tapply(Puromycin$rate, INDEX = Puromycin$state, FUN = mean)
```
L'argument `INDEX` pourrait être une liste de plusieurs facteurs.
```{r}
tapply(Puromycin$rate, INDEX = Puromycin[, c("conc", "state")], FUN = mean)
```
Dans l'exemple ci-dessous, nous avons fourni à `INDEX` un data frame, mais rappelons-nous que les data frames sont des cas particulier de listes. De plus, un élément de ce data frame n'est pas un facteur. Il s'agit de la variable `conc`. Cela n'a pas posé problème parce que `lapply` est arrivé à transformer l'élément en facteur.

#### Fonction `by` :

\mbox{}

La fonction `by` prend comme objet en entrée un data frame et permet d'effectuer un calcul sur des sous-objets qui sont aussi des data frames. Par exemple, nous pourrions calculer la matrice de corrélations entre les observations des variables `conc` et `rate` selon les niveaux du facteur `state` comme suit.
```{r}
by(Puromycin[, c("conc", "rate")], INDICES = Puromycin$state, FUN = cor)
```


#### Fonction `aggregate` :

\mbox{}

Finalement, la fonction `aggregate` prend aussi en entrée un data frame, mais elle applique la fonction séparément pour chaque colonne du data frame.
```{r}
aggregate(Puromycin[, c("conc", "rate")], by = list(state = Puromycin$state), FUN = mean)
```
L'argument `by` doit obligatoirement être une liste. Nommer les éléments de la liste aide à clarifier la sortie.

La fonction `aggregate` accepte aussi des formules en entrée, comme dans les exemples ci-dessous.
```{r}
# Exemple avec deux variables réponses et une variable explicative (de groupement)
aggregate(cbind(conc, rate) ~ state, data = Puromycin, FUN = mean)
# Exemple avec une variable réponse et deux variables explicatives (de groupement)
aggregate(rate ~ conc + state, data = Puromycin, FUN = median)
```


## Autres fonctions pour réaliser des calculs par niveaux de facteurs

Quelques packages R offrent d'autres fonctions permettant de réaliser des calculs par niveaux de facteurs. L'utilisation de deux de ces packages, souvent mentionnés par la communauté R, est illustrée ici en reproduisant les deux exemples précédents. 

#### Package `dplyr`

\mbox{}

L'utilisation conjointe des fonctions [`group_by`](https://dplyr.tidyverse.org/reference/group_by.html) et [`summarize`](https://dplyr.tidyverse.org/reference/summarise.html) du package [`dplyr`](https://CRAN.R-project.org/package=dplyr) du [`tidyverse`](https://www.tidyverse.org/) permet d'agréger, en utilisant une statistique de notre choix, les observations de variables selon les niveaux de facteurs. En voici un exemple. 

```{r message = FALSE}
library(dplyr)
```

```{r}
# Exemple avec deux variables réponses et une variable explicative (de groupement)
summarize(group_by(Puromycin, state), conc = mean(conc), rate = mean(rate))
# Exemple avec une variable réponse et deux variables explicatives (de groupement)
summarize(group_by(Puromycin, conc, state), rate = median(rate))
```

Pour plus d'informations :

- https://dplyr.tidyverse.org/
- https://stt4230.rbind.io/tutoriels_etudiants/hiver_2016/agreger_donnees_dplyr/

\newpage

#### Package `data.table`

\mbox{}

Il est aussi possible de réaliser ces agrégations grâce à l'argument `by` de l'opérateur `[` du package [`data.table`](https://rdatatable.gitlab.io/data.table/). 

```{r message = FALSE}
library(data.table)
Puromycin_dt <- data.table(Puromycin)
```

```{r}
# Exemple avec deux variables réponses et une variable explicative (de groupement)
Puromycin_dt[, .(conc = mean(conc), rate = mean(rate)), by = state]
# Exemple avec une variable réponse et deux variables explicatives (de groupement)
Puromycin_dt[, .(rate = median(rate)), by = .(conc, state)]
```

Ce package offre l'avantage de pouvoir effectuer ces opérations rapidement sur de grands jeux de données.

Pour plus d'informations :

- https://rdatatable.gitlab.io/data.table/articles/datatable-intro.html#aggregations
- https://stt4230.rbind.io/tutoriels_etudiants/hiver_2017/data.table/


## Choix de la fonction de la famille des `apply` à utiliser

Les fonctions de la famille des `apply` servent à appliquer un même calcul sur différentes parties (sous-objets) d'une structure de données R (objet principal).

La structure de données peut être brisée en sous-objets de différentes façons. Par exemple, s'il s'agit d'une matrice, elle peut être séparée en lignes ou en colonnes. S'il s'agit d'une liste, elle peut être séparée en éléments. Il est aussi possible de briser un vecteur ou un data frame en blocs d'observations référant à différents niveaux de facteurs. Dans ces notes, les fonctions de la famille des `apply` ont été séparées en 3 catégories selon la façon de former les sous-objets.

Le format de la sortie retournée varie aussi d'une fonction à l'autre.

Quand vient le temps de choisir une fonction de la famille des `apply` à utiliser, il faut donc se demander :

- Quel est le type de l'objet sur lequel appliquer les calculs?
- Comment les sous-objets doivent-ils être formés?
- Quel format de sortie est le plus approprié?

Le tableau suivant permet de facilement comparer les fonctions de la famille des `apply` présentées en fournissant les réponses aux questions précédentes.

Fonction | Objet typique en entrée | Formation des sous-objets  | Format de la sortie 
---------------|------------------------------------|---------------------------------------|--------------------------
`apply`  | array (matrice) | selon une ou des dimensions | vecteur, array, liste
&nbsp; | &nbsp; | &nbsp; | &nbsp;
`lapply` | vecteur, liste (data frame) | éléments de l'objet en entrée | liste
`sapply` | vecteur, liste (data frame) | éléments de l'objet en entrée | simplifié par défaut
`mapply` | vecteurs, listes (data frames) | éléments des objets en entrée | simplifié par défaut
&nbsp; | &nbsp; | &nbsp; | &nbsp;
`tapply` | vecteur | selon les niveaux de facteurs | array ou liste
`by` | data frame | selon les niveaux de facteurs | array ou liste
`aggregate` | data frame | selon les niveaux de facteurs | data frame  
&nbsp;  |  | et par colonne du data frame | 




***

# Conditions logiques

Une condition logique est simplement une instruction R qui retourne une ou des valeurs logiques (`TRUE` ou `FALSE`). Ce type d'instruction a différentes utilités, par exemple :

- explorer des données : répondre à des questions du genre combien d'observations respectent une certaine condition;
- filtrer des données : extraire les observations respectant une certaine condition;
- définir une condition dans une structure de contrôle conditionnelle `if ... else`;
- etc.

## Conditions logiques vectorielles de longueur quelconque

Les deux premières utilités potentielles des conditions logiques énumérées ci-dessus requièrent la création d'un vecteur de valeurs logiques de la même longueur que l'objet R sur lequel la condition est testée. Nous avons vu au début de cette fiche des outils pour écrire de telles conditions logiques :

- les opérateurs de comparaison : `==`, `!=`, `>`, `>=`, `<` et `<=`;
- les opérateurs et fonctions logiques vectoriels : `!` (négation), `&` (et), `|` (ou) et `xor` (ou exclusif). 

Voici des exemples d'écriture de conditions logiques utilisant le vecteur suivant, que nous avons déjà manipulé dans des [notes précédentes](https://stt4230.rbind.io/manipulation_donnees/structures_r/#fonction-c).

```{r}
de <- c(2, 3, 4, 1, 2, 3, 5, 6, 5, 4)
```

Supposons que nous voulions connaître le nombre d'éléments dans ce vecteur numérique dont la valeur est supérieure à 3. La condition logique suivante nous permet d'identifier ces valeurs.

```{r}
condition <- de > 3
condition
```

Compter le nombre de valeurs supérieures à 3 dans `de` revient à compter le nombre de `TRUE` dans le vecteur précédent. Ce calcul se réalise facilement avec la fonction `sum` comme suit.

```{r}
sum(condition)
```

Même si une somme est une opération mathématique sur des valeurs numériques, la commande précédente ne retourne par d'erreur, car R réalise d'abord une [conversion implicite de type de données](https://stt4230.rbind.io/manipulation_donnees/structures_r/#conversions) pour transformer les valeurs logiques en nombres (`TRUE` devient 1 et `FALSE` devient 0), puis effectue la somme.

Le vecteur `condition` serait aussi utile pour extraire les éléments de `de` ayant une valeur supérieure à 3. Nous savons que l'[opérateur d'indiçage `[` et la fonction d'extraction `subset`](https://stt4230.rbind.io/manipulation_donnees/structures_r/#extraction-d%C3%A9l%C3%A9ments) acceptent en entrée un vecteur logique. Nous pouvons donc extraire les éléments respectant la condition comme suit.

```{r}
de[condition]
```

#### Fonction `which`

\mbox{}

Une fonction parfois utile avec un vecteur logique est la fonction `which`, utilisée précédemment dans un exemple. Elle permet de connaître les positions des `TRUE` dans le vecteur, comme l'illustre cet exemple :

```{r}
which(condition)
```

L'utilisation de `which` n'est cependant pas nécessaire lors de l'extraction d'éléments à partir d'un vecteur logique. Par exemple, les commandes `de[which(condition)]` et `de[condition]` produisent le même résultat, mais la commande sans appel à la fonction `which` a l'avantage d'être plus succincte.


#### Conditions combinant des vecteurs logiques

\mbox{}

La condition précédente était plutôt simple. Une condition plus complexe requiert souvent de combiner des vecteurs logiques à l'aide d'un opérateur logique. Par exemple, l'instruction suivante identifie les éléments du vecteur `de` dont la valeur se situe dans l'intervalle $[3, 5]$.

```{r}
de >= 3 & de <= 5
```

L'instruction suivante identifie pour sa part les éléments du vecteur `de` égaux à 1, 4 ou 6. 

```{r}
de == 1 | de == 4 | de == 6
```

Pour identifier les éléments du vecteur `de` non-égaux à 1, 4 ou 6, nous pourrions inverser le vecteur logique précédent avec l'opérateur de négation comme suit.

```{r}
!(de == 1 | de == 4 | de == 6)
```

Rappelons qu'en logique mathématique, la [négation d'une disjonction est équivalente à la conjonction de négations](https://fr.wikipedia.org/wiki/Table_de_v%C3%A9rit%C3%A9#NON-OU_logique). L'instruction suivante retourne donc le même résultat que la précédente.

```{r}
de != 1 & de != 4 & de != 6
```


### Opérateur `%in%` de comparaison à un ensemble de valeurs

Pour effectuer une comparaison à un ensemble de valeur, telle que le fait l'instruction `de == 1 | de == 4 | de == 6`, R offre un opérateur raccourcissant la syntaxe : l'opérateur `%in%`. Cet opérateur compare les éléments d'un vecteur (placé avant l'opérateur) aux éléments d'un ensemble présenté sous la forme d'un vecteur (placé après). Il retourne `TRUE` pour un élément égal à n'importe lequel des éléments de l'ensemble, `FALSE` sinon. L'instruction `de == 1 | de == 4 | de == 6` est donc équivalent à la suivante.

```{r}
de %in% c(1, 4, 6)
```

Combiné à un opérateur de négation `!`, l'opérateur `%in%` permet de facilement tester si les valeurs dans un vecteur sont différentes des valeurs d'un ensemble, comme dans cet exemple.

```{r}
! de %in% c(1, 4, 6)
```


### Fonctions de comparaison pour caractères spéciaux

Notons que tester si un ou des éléments sont égaux à `NA`, `NaN` ou `Inf` (constante pour l'infini), ne se fait pas directement avec l'opérateur `==` comme suit.

```{r}
c(1, 2, NA, 4, 5) == NA
```

Il faut plutôt utiliser la fonction `is.na`, `is.nan` ou `is.infinite`.

```{r}
is.na(c(1, 2, NA, 4, 5))
```


## Conditions logiques de longueur 1

Lors de l'écriture d'une condition logique, il faut parfois s'assurer de retourner un vecteur logique de longueur 1. C'est le cas lors de l'écriture d'une condition logique dans une structure de contrôle conditionnelle `if ... else` (que nous verrons plus loin). La condition dans un `if` doit être obligatoirement de longueur 1.


### Opérateurs et fonctions logiques non vectoriels

Les opérateurs et fonctions logiques suivants garantissent que le résultat retourné est de longueur 1.
 
- `&&` : et,
- `||` : ou,
- `isTRUE` et `isFALSE`.

Les opérateurs `&&` et `||` appliquent les mêmes tables de vérité que les opérateurs `&` et `|`, mais ils ne travaillent pas de façon vectorielle. Si, par inadvertance, `&&` ou `||` reçoit en entrée des vecteurs de longueurs supérieures à 1, il effectue une opération seulement sur les premiers éléments de ces vecteurs, comme dans cet exemple.

```{r}
de == 1 || de == 4 || de == 6
```

Les fonctions `isTRUE` et `isFALSE`, pour leur part, sont des fonctions raccourcies permettant d'effectuer les tests suivants.

```{r eval = FALSE}
is.logical(x) && length(x) == 1 && !is.na(x) && x   # isTRUE
is.logical(x) && length(x) == 1 && !is.na(x) && !x  # isFALSE
```

Elles permettent donc de s'assurer qu'une condition possède toutes les caractéristiques requises pour être fournie à un `if` (contenir des données logiques, être de longueur 1 et ne pas prendre la valeur `NA`).


### Fonctions `all` et `any`

Les fonctions `all` et `any` font partie des fonctions R retournant toujours une seule valeur logique. La fonction `all` indique si tous les éléments d'un vecteur logique sont `TRUE`. Par exemple, pour tester si toutes les valeurs dans le vecteur `de` sont entières au sens mathématique, nous pourrions utiliser la commande suivante.
```{r}
all(de %% 1 == 0)
```

La fonction `any` indique pour sa part si au moins un élément d'un vecteur logique est `TRUE`. Nous pourrions par exemple vérifier si le vecteur `de` comporte des valeurs négatives comme suit.
```{r}
any(de < 0)
```

### Fonctions de vérification de type

Finalement, les fonctions `is.numeric`, `is.character`, `is.logical`, `is.vector`, `is.matrix`, `is.data.frame`, `is.factor`, `is.null`, `is.function`, etc., testent une condition et retournent toujours un logique de longueur unitaire. Par exemple, testons si le vecteur `de` contient bien des données numériques.

```{r}
is.numeric(de)
```


***

# Comparaison de deux objets R

Les opérateurs de comparaison permettent de comparer les éléments d'objets R. Mais comment comparer des objets entiers? Cela dépend de ce qui doit être comparé.

- Pour comparer tous les éléments, mais pas les attributs : `all(x == y)`
    + retourne `TRUE` si tous les éléments sont égaux, 
    + `FALSE` sinon,
    + `NA` si un des deux objets comparés contient au moins une valeur manquante et que l'argument `na.rm` de la fonction `all` prend la valeur `FALSE`.
- Pour comparer les objets dans leur totalité (éléments, attributs, type de l'objet et de ses éléments) :  `identical(x, y)`
    + retourne `TRUE` si les deux objets comparés sont totalement identiques,
    + `FALSE` sinon.
- Pour comparer tous les éléments et les attributs, en acceptant des différences dans les valeurs numériques selon une certaine tolérance :  `all.equal(x, y)`
    + retourne `TRUE` en cas d'égalité respectant la tolérance, 
    + sinon retourne des informations sur les différences.


Voici quelques exemples.

#### Éléments identiques, mais attributs différents

\mbox{}

```{r}
# Objets comparés
x <- 1:5
y <- 1:5
names(x) <- letters[1:5]
str(x)
str(y)
```

&nbsp;

\newpage

```{r}
# Résultats des différentes comparaisons
all(x == y)
identical(x, y)
all.equal(x, y)
```

#### Éléments équivalents, mais de types différents, attributs identiques

\mbox{}

```{r}
# Objets comparés
x <- as.double(x)
str(x)
str(y)
```

&nbsp;

```{r}
# Résultats des différentes comparaisons
all(x == y)
identical(x, y)
all.equal(x, y)
```

#### Éléments numériques pas tout à fait identiques, attributs et types identiques

\mbox{}

```{r}
# Objets comparés
y <- 1:5 + 1e-10
str(x)
str(y)
```

Bien que les valeurs numériques dans `x` et `y` ne soient pas tout à fait identiques, elles semblent identiques à l'affichage de `x` et `y`.

```{r}
# Résultats des différentes comparaisons
all(x == y)
identical(x, y)
all.equal(x, y)
```

**Rappel** : Il est possible de contrôler le nombre de chiffres composant un nombre affichés dans la console R avec l'option `digits` de la session R.
```{r options}
optionsDefaut <- options()
options(digits = 11)
y
options(digits = optionsDefaut$digits)
```

***

# Résumé

#### Fonctions et opérateurs mathématiques et statistiques de base en R

\mbox{}

- fonctionnement vectoriel et règle de recyclage : calculs élément par élément pour un objet, ou encore terme à terme entre des objets;

Calcul | opère de façon vectorielle | combine, retourne une valeur | combine, retourne valeur(s) | combine, retourne un vecteur|
------------|------------------|----------|-----------|----------|
arithmétique | `+`, `-`, `*`, `/`, `^`, `%%`, `%/%` | `sum`, `prod` | | `cumsum`, `cumprod`, `diff` |
comparaison | `==`, `!=`, `>`, `>=`, `<`, `<=` | | | |
logique | `!`, `&`, `|`, `xor` | `&&`, `||` | | |
&nbsp; | &nbsp; | &nbsp; | &nbsp; | &nbsp;
racine carrée, exponentielle, logarithme, trigonométrie, signe, arrondissement, bêta, gamma | `sqrt`, `exp`, `log`, `log10`, `log2`, `sin`, `cos`, `tan`, `acos`, `asin`, `atan`, `atan2`, `abs`, `sign`, `ceiling`, `floor`, `round`, `trunc`, `signif`, `beta`, `gamma`, `factorial`, `choose`, etc. | | | |
&nbsp; | &nbsp; | &nbsp; | &nbsp; | &nbsp;
mesure de position | `pmin`, `pmax` | `min`, `max`, `which.min`, `which.max` | `range`, `quantile`, `summary` | `cummin`, `cummax`, `rank` 
tendance centrale | | `mean`, `median` | `summary` | |
dispersion | | `sd` | `var`, `cov`, `cor` | |
fréquences | | | `table`, `ftable`, `xtabs`, `summary` | |

- opérations sur des ensembles : `union`, `intersect`, `setdiff`, `setequal`, `is.element`;
- mots-clés mathématiques : `pi`, `Inf`, `NaN`.
- argument `na.rm` : spécifie le comportement de la fonction en présence de valeurs manquantes;
- calcul de fréquences marginales ou relatives à partir d’un tableau de fréquences :  
`margin.table`, `addmargins`, `prop.table`.
- énumération de combinaisons : `expand.grid`, `combn`;
- traitement des observations dupliquées : `duplicated`, `unique`.
  

#### Fonctions de la famille des `apply`

\mbox{}

Principe de base derrière ces fonctions (qui cachent des boucles) :

- séparer un objet en sous-objets;
- appeler une fonction en lui donnant comme premier argument tous les sous-objets, un à la fois;
- combiner les résultats obtenus.

Résumé du fonctionnement des fonctions présentées :

Fonction | Objet typique en entrée | Formation des sous-objets  | Format de la sortie 
---------------|------------------------------------|---------------------------------------|--------------------------
`apply`  | array (matrice) | selon une ou des dimensions | vecteur, array, liste
&nbsp; | &nbsp; | &nbsp; | &nbsp;
`lapply` | vecteur, liste (data frame) | éléments de l'objet en entrée | liste
`sapply` | vecteur, liste (data frame) | éléments de l'objet en entrée | simplifié par défaut
`mapply` | vecteurs, listes (data frames) | éléments des objets en entrée | simplifié par défaut
&nbsp; | &nbsp; | &nbsp; | &nbsp;
`tapply` | vecteur | selon les niveaux de facteurs | array ou liste
`by` | data frame | selon les niveaux de facteurs | array ou liste
`aggregate` | data frame | selon les niveaux de facteurs et par colonne du data frame | data frame  


Description des arguments à donner en entrée à ces fonctions :

- 1^e^ argument (sauf pour `mapply`) : objet à séparer et sur lequel appliquer la fonction;

- argument suivant : information pour spécifier comment séparer l'objet en sous-objets (sauf pour les fonctions prenant en entrée une liste, soit pour `lapply`, `sapply` et `mapply`, car dans ce cas les sous-objets sont les éléments de la liste);

- argument suivant (celui nommé `FUN`) : la fonction à appliquer (les sous-objets lui seront fournis comme premier argument);

- `...` : il est possible de passer des arguments supplémentaires à la fonction à appliquer (`FUN`) simplement en les donnant en argument à la fonction de la famille des `apply` grâce aux `...` (rappel : il s'agit de la deuxième utilité de l'argument `...` mentionnée dans les notes sur les [concepts de base en R](https://stt4230.rbind.io/introduction/base_r/#largument-...-et-ses-deux-utilites.)).

Note : La fonction `aggregate` accepte aussi une formule en entrée.

Autres fonctions pour réaliser des calculs par niveaux de facteurs (comme `tapply`, `by` et `aggregate`) :

- fonctions [`group_by`](https://dplyr.tidyverse.org/reference/group_by.html) et [`summarize`](https://dplyr.tidyverse.org/reference/summarise.html) du package [`dplyr`](https://CRAN.R-project.org/package=dplyr) utilisées conjointement;
- opérateur `[` du package [`data.table`](https://rdatatable.gitlab.io/data.table/) utilisé en exploitant son argument `by`.


#### Écriture de conditions logiques

\mbox{}

Fonctions opérant de façon vectorielle :

- Opérateurs de comparaison :
	`==`, `!=`, `>`, `>=` , `<`, `<=`.
- Opérateurs et fonction logiques : `!` (négation), `&` (et), `|` (ou), `xor` (ou exclusif).
- Opérateur de comparaison à un ensemble de valeurs : `%in%`.
- Fonctions de comparaison pour caractères spéciaux :
	`is.na`, `is.nan`, `is.infinite`.

Fonctions retournant toujours un logique de longueur 1 :

- Opérateurs logiques non vectoriels : `&&` (et), `||` (ou), `isTRUE`, `isFALSE`.
- Fonctions qui condensent un vecteur logique en une seule valeur
	logique : `all`, `any`.
- Fonctions de vérification de type :  
`is.`(`numeric`/`character`/`logical`/`vector`/`matrix`/`array`/`list`/`data.frame`/`factor`/`null`/...)  
(il en existe beaucoup!).

\newpage

#### Comparaison de deux objets R


- Pour comparer uniquement les valeurs, pas les attributs :
`all(x == y)`.
- Pour comparer les objets dans leur totalité (valeurs, attributs, type
de l'objet ou des éléments) : `identical(x, y)`.
- Pour comparer les valeurs et les attributs, en acceptant des
différences dans les valeurs numériques selon une certaine tolérance :
`all.equal(x, y)`.


***


# Références

Livres :

- Cotton, R. (2013). Learning R: A Step-by-Step Function Guide to Data Analysis, O'Reilly Media.
- Teetor, P. (2011). R Cookbook. O'Reilly Media. http://www.cookbook-r.com/
- Muenchen, R. A. (2011). R for SAS and SPSS Users. Second edition. Springer.
- Zumel, N. et Mount, J. (2014). Practical Data Science with R. Manning Publications Co.
- Zuur, A. F., Ieno, E. N. et Meesters, E. H.W.G. (2009). A Beginner's Guide to R. Springer.

Ressource web pour mieux comprendre les fonctions de la famille des `apply` :

- https://www.datacamp.com/community/tutorials/r-tutorial-apply-family


