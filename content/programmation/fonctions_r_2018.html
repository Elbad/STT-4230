---
title: "Fonctions en R"
author: "Sophie Baillargeon, Université Laval"
date: "2018-03-12"
weight: 3
slug: "struct_controle_r"
categories: ["cours_2018-03-20"]
categories_weight: 2
lastmodifierdisplayname : "Sophie Baillargeon"
lastmodifieremail: "sophie.baillargeon@mat.ulaval.ca"
output:
  pdf_document:
    toc: yes
    toc_depth: 3
  blogdown::html_page:
    toc: true
header-includes:
- \usepackage[french]{babel}
- \frenchbsetup{StandardLayout}
- \hypersetup{colorlinks=true, urlcolor = {blue}, linkcolor = {blue}}
editor_options: 
  chunk_output_type: console
---





<div id="TOC">
<ul>
<li><a href="#syntaxe-generale-dune-fonction-r">Syntaxe générale d’une fonction R</a><ul>
<li><a href="#composantes-dune-fonction-r">Composantes d’une fonction R</a></li>
<li><a href="#fonction-sans-nom">Fonction sans nom</a></li>
</ul></li>
<li><a href="#arguments-en-entree">Arguments en entrée</a><ul>
<li><a href="#valeurs-par-defaut-des-arguments">Valeurs par défaut des arguments</a><ul>
<li><a href="#valeur-par-defaut-pour-un-argument-acceptant-seulement-un-petit-nombre-de-chaines-de-caracteres-specifiques">Valeur par défaut pour un argument acceptant seulement un petit nombre de chaînes de caractères spécifiques</a></li>
</ul></li>
<li><a href="#appel-dune-fonction">Appel d’une fonction</a></li>
<li><a href="#argument-...">Argument <code>...</code></a><ul>
<li><a href="#utilite-1-recevoir-un-nombre-indetermine-darguments">Utilité 1 : recevoir un nombre indéterminé d’arguments</a></li>
<li><a href="#utilite-2-passer-des-arguments-a-une-autre-fonction">Utilité 2 : passer des arguments à une autre fonction</a></li>
</ul></li>
</ul></li>
<li><a href="#sortie-dune-fonction">Sortie d’une fonction</a><ul>
<li><a href="#fonction-match.call">Fonction <code>match.call</code></a></li>
<li><a href="#effets-de-bord-dune-fonction">Effets de bord d’une fonction</a></li>
</ul></li>
<li><a href="#execution-dune-fonction-et-environnements-associes">Exécution d’une fonction et environnements associés</a><ul>
<li><a href="#portee-lexicale">Portée lexicale</a></li>
<li><a href="#chemin-de-recherche-complet">Chemin de recherche complet</a></li>
<li><a href="#bonnes-pratiques-concernant-les-objets-utilisables-dans-le-corps-dune-fonction">Bonnes pratiques concernant les objets utilisables dans le corps d’une fonction</a></li>
</ul></li>
<li><a href="#exemple-de-creation-dune-fonction-r">Exemple de création d’une fonction R</a><ul>
<li><a href="#etapes-de-developpement-conseillees">Étapes de développement conseillées</a></li>
</ul></li>
<li><a href="#references">Références</a></li>
</ul>
</div>

<hr />
<p>Lorsqu’un bout de code R est susceptible d’être utilisé à répétition (par exemple pour faire un même calcul sur des données différentes), il est préférable d’en faire une fonction R.</p>
<p>Avantages des fonctions :</p>
<ul>
<li>sauver du temps,</li>
<li>diminuer les risques de faire des erreurs,</li>
<li>rédiger du code plus clair et plus court, donc plus facile à comprendre et à partager.</li>
</ul>
<p>Bref, faire des fonctions est une bonne pratique de programmation.</p>
<div id="syntaxe-generale-dune-fonction-r" class="section level1">
<h1>Syntaxe générale d’une fonction R</h1>
<p>Pour créer une fonction en R, il faut utiliser le mot-clé <code>function</code> en respectant la syntaxe suivante :</p>
<pre class="r"><code>nomFonction &lt;- function(arg1, arg2, arg3){
  instructions  # formant le corps de la fonction
}</code></pre>
<p><code>arg1</code>, <code>arg2</code> et <code>arg3</code> représentent les arguments de la fonction, soit les objets qui peuvent être fournis en entrée à la fonction.</p>
<p>Voici un exemple de fonction qui reprend un exemple présenté dans les notes sur les <a href="https://stt4230.rbind.io/programmation/struct_controle_r/#ecriture-generale">structures de contrôle en R</a>. Elle calcule des statistiques descriptives simples selon le type des éléments du vecteur donné en entrée.</p>
<pre class="r"><code>statDesc &lt;- function(x){
  if (is.numeric(x)) {
    min &lt;- min(x)
    moy &lt;- mean(x)
    max &lt;- max(x)
    stats &lt;- c(min = min, moy = moy, max = max)
  } else if (is.character(x) || is.factor(x)) {
    stats &lt;- table(x)
  } else {
    stats &lt;- NA
  }
  stats
}</code></pre>
<p>Après avoir soumis le code de création de cette fonction dans la console, la fonction se retrouve dans l’environnement de travail. Il est alors possible de l’appeler.</p>
<pre class="r"><code>statDesc(x = iris$Species)</code></pre>
<pre><code>## x
##     setosa versicolor  virginica 
##         50         50         50</code></pre>
<p>Nous pourrions ajouter un argument à cette fonction. Par exemple, nous pourrions offrir l’option d’une sortie présentée sous la forme de matrice plutôt que de vecteur.</p>
<pre class="r"><code>statDesc &lt;- function(x, sortieMatrice){
  # Calcul
  if (is.numeric(x)) {
    stats &lt;- c(min = min(x), moy = mean(x), max = max(x))
  } else if (is.character(x) || is.factor(x)) {
    stats &lt;- table(x, dnn = NULL)
  } else {
    stats &lt;- NA
  }
  # Production de la sortie
  if (sortieMatrice){
    stats &lt;- as.matrix(stats)
    colnames(stats) &lt;- if (is.character(x) || is.factor(x)) &quot;frequence&quot; else &quot;stat&quot;
  }
  stats
}</code></pre>
<p>Le code de la fonction a aussi été un peu reformaté. Nous pouvons maintenant appeler la fonction comme suit.</p>
<pre class="r"><code>statDesc(x = iris$Species, sortieMatrice = TRUE)</code></pre>
<pre><code>##            frequence
## setosa            50
## versicolor        50
## virginica         50</code></pre>
<div id="composantes-dune-fonction-r" class="section level2">
<h2>Composantes d’une fonction R</h2>
<p>Les composantes d’une fonction R sont :</p>
<ul>
<li>la liste de ses arguments, possiblement avec des valeurs par défaut (nous allons y revenir);</li>
</ul>
<pre class="r"><code>args(statDesc)</code></pre>
<pre><code>## function (x, sortieMatrice) 
## NULL</code></pre>
<ul>
<li>le corps de la fonction, soit les instructions qui la constituent.</li>
</ul>
<pre class="r"><code>body(statDesc)</code></pre>
<pre><code>## {
##     if (is.numeric(x)) {
##         stats &lt;- c(min = min(x), moy = mean(x), max = max(x))
##     }
##     else if (is.character(x) || is.factor(x)) {
##         stats &lt;- table(x, dnn = NULL)
##     }
##     else {
##         stats &lt;- NA
##     }
##     if (sortieMatrice) {
##         stats &lt;- as.matrix(stats)
##         colnames(stats) &lt;- if (is.character(x) || is.factor(x)) 
##             &quot;frequence&quot;
##         else &quot;stat&quot;
##     }
##     stats
## }</code></pre>
<ul>
<li>l’environnement englobant de la fonction (défini plus loin).</li>
</ul>
<pre class="r"><code>environment(statDesc)</code></pre>
<pre><code>## &lt;environment: R_GlobalEnv&gt;</code></pre>
</div>
<div id="fonction-sans-nom" class="section level2">
<h2>Fonction sans nom</h2>
<p>Notons qu’une fonction n’a même pas besoin de porter de nom. La grande majorité du temps, une fonction est conçue pour être appelée à plusieurs reprises et il est alors nécessaire qu’elle ait un nom. Cependant, certaines fonctions sont parfois à usage unique.</p>
<p>Par exemple, il est parfois utile de se créer une fonction pour personnaliser le calcul effectué par une fonction de la famille des <code>apply</code>. Si cette fonction est très courte et a peu de chance d’être réutilisée, il n’est pas nécessaire de la nommer.</p>
<p>Voici un exemple. Si nous voulions calculer le minimum, la moyenne et le maximum (comme le fait notre fonction <code>statDesc</code>) de toutes les variables numériques du jeu de données <code>iris</code>, mais selon le niveau de la variable <code>Species</code>, nous pourrions utiliser trois appels à la fonction <code>aggregate</code> comme suit.</p>
<pre class="r"><code>aggregate(x = iris[, -5], by = list(iris$Species), FUN = min)</code></pre>
<pre><code>##      Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width
## 1     setosa          4.3         2.3          1.0         0.1
## 2 versicolor          4.9         2.0          3.0         1.0
## 3  virginica          4.9         2.2          4.5         1.4</code></pre>
<pre class="r"><code>aggregate(x = iris[, -5], by = list(iris$Species), FUN = mean)</code></pre>
<pre><code>##      Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width
## 1     setosa        5.006       3.428        1.462       0.246
## 2 versicolor        5.936       2.770        4.260       1.326
## 3  virginica        6.588       2.974        5.552       2.026</code></pre>
<pre class="r"><code>aggregate(x = iris[, -5], by = list(iris$Species), FUN = max)</code></pre>
<pre><code>##      Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width
## 1     setosa          5.8         4.4          1.9         0.6
## 2 versicolor          7.0         3.4          5.1         1.8
## 3  virginica          7.9         3.8          6.9         2.5</code></pre>
<p>Nous pourrions aussi créer une fonction qui calcule les trois statistiques et donner cette fonction en entrée à <code>aggregate</code> comme valeur à l’argument <code>FUN</code>.</p>
<pre class="r"><code>aggregate(x   = iris[, -5], 
          by  = list(iris$Species), 
          FUN = function(x) c(min = min(x), moy = mean(x), max = max(x)))</code></pre>
<pre><code>##      Group.1 Sepal.Length.min Sepal.Length.moy Sepal.Length.max Sepal.Width.min
## 1     setosa            4.300            5.006            5.800           2.300
## 2 versicolor            4.900            5.936            7.000           2.000
## 3  virginica            4.900            6.588            7.900           2.200
##   Sepal.Width.moy Sepal.Width.max Petal.Length.min Petal.Length.moy Petal.Length.max
## 1           3.428           4.400            1.000            1.462            1.900
## 2           2.770           3.400            3.000            4.260            5.100
## 3           2.974           3.800            4.500            5.552            6.900
##   Petal.Width.min Petal.Width.moy Petal.Width.max
## 1           0.100           0.246           0.600
## 2           1.000           1.326           1.800
## 3           1.400           2.026           2.500</code></pre>
<p>Nous n’avons jamais donné de nom à la fonction et cela n’a causé aucun problème. Nous n’avons même pas utilisé d’accolades pour encadrer le corps de la fonction. Ce n’est pas nécessaire lorsque celui-ci est composé d’une seule instruction.</p>
</div>
</div>
<div id="arguments-en-entree" class="section level1">
<h1>Arguments en entrée</h1>
<p>Les arguments sont définis en énumérant leurs noms entre les parenthèses après le mot-clé <code>function</code>.</p>
<pre class="r"><code>nomFonction &lt;- function(arg1, arg2, arg3){
  instructions  # formant le corps de la fonction
}</code></pre>
<p>Il est aussi possible qu’une fonction ne possède aucun argument.</p>
<pre class="r"><code>HelloWorld &lt;- function() cat(&quot;Hello World !&quot;)</code></pre>
<p>Comme nous le savons déjà, pour appeler une fonction sans fournir d’arguments, il faut tout de même utiliser les parenthèses.</p>
<pre class="r"><code>HelloWorld()</code></pre>
<pre><code>## Hello World !</code></pre>
<p>Omettre les parenthèses retourne le code source de la fonction.</p>
<pre class="r"><code>HelloWorld</code></pre>
<pre><code>## function() cat(&quot;Hello World !&quot;)</code></pre>
<div id="valeurs-par-defaut-des-arguments" class="section level2">
<h2>Valeurs par défaut des arguments</h2>
<p>Afin de définir une valeur par défaut pour un argument, il faut accompagner son nom dans l’énumération des arguments d’un opérateur <code>=</code> et d’une instruction R retournant la valeur par défaut. Par exemple, dans la fonction <code>statDesc</code>, il serait préférable de définir un format par défaut pour la sortie.</p>
<pre class="r"><code>statDesc &lt;- function (x, sortieMatrice = FALSE) {
  # Calcul
  if (is.numeric(x)) {
    stats &lt;- c(min = min(x), moy = mean(x), max = max(x))
  } else if (is.character(x) || is.factor(x)) {
    stats &lt;- table(x, dnn = NULL)
  } else {
    stats &lt;- NA
  }
  # Production de la sortie
  if (sortieMatrice){
    stats &lt;- as.matrix(stats)
    colnames(stats) &lt;- if (is.character(x) || is.factor(x)) &quot;frequence&quot; else &quot;stat&quot;
  }
  stats
}</code></pre>
<p>Les arguments qui ne possèdent pas de valeur par défaut sont obligatoires. Si une fonction est appelée sans donner de valeur en entrée à un paramètre obligatoire, une erreur est produite.</p>
<pre class="r"><code>statDesc(sortieMatrice = FALSE)</code></pre>
<pre><code>## Error in statDesc(sortieMatrice = FALSE): argument &quot;x&quot; is missing, with no default</code></pre>
<p>Les arguments ayant une valeur par défaut peuvent, pour leur part, ne pas être fournis en entrée.</p>
<pre class="r"><code>statDesc(x = iris$Sepal.Length)</code></pre>
<pre><code>##      min      moy      max 
## 4.300000 5.843333 7.900000</code></pre>
<div id="valeur-par-defaut-pour-un-argument-acceptant-seulement-un-petit-nombre-de-chaines-de-caracteres-specifiques" class="section level3">
<h3>Valeur par défaut pour un argument acceptant seulement un petit nombre de chaînes de caractères spécifiques</h3>
<p>Attardons-nous maintenant à un cas particulier de valeur par défaut en R. Supposons qu’une fonction possède un argument qui prend en entrée une chaîne de caractères et que seulement un petit nombre de chaînes de caractères distinctes sont acceptées par cet argument. C’est le cas par exemple pour l’argument <code>useNA</code> de la fonction <code>table</code>. La fonction accepte seulement les valeurs <code>&quot;no&quot;</code>, <code>&quot;ifany&quot;</code> ou <code>&quot;always&quot;</code> pour cet argument. Donner une valeur autre à l’argument produira une erreur.</p>
<pre class="r"><code>table(iris$Species, useNA = &quot;test&quot;)</code></pre>
<pre><code>## Error in match.arg(useNA): &#39;arg&#39; should be one of &quot;no&quot;, &quot;ifany&quot;, &quot;always&quot;</code></pre>
<p>Une pratique courante en R pour un argument de ce type est de lui donner comme valeur dans l’énumération des arguments le vecteur de toutes ses valeurs possibles. C’est ce qui est fait dans la fonction table.</p>
<pre class="r"><code>args(table)</code></pre>
<pre><code>## function (..., exclude = if (useNA == &quot;no&quot;) c(NA, NaN), useNA = c(&quot;no&quot;, 
##     &quot;ifany&quot;, &quot;always&quot;), dnn = list.names(...), deparse.level = 1) 
## NULL</code></pre>
<p>La valeur par défaut de l’argument n’est en réalité pas le vecteur complet <code>c(&quot;no&quot;, &quot;ifany&quot;, &quot;always&quot;)</code>, mais plutôt le premier élément de ce vecteur, soit <code>&quot;no&quot;</code>. Il en est ainsi, car le corps de la fonction contient l’instruction suivante.</p>
<pre class="r"><code>useNA &lt;- match.arg(useNA)</code></pre>
<p>Nous devrions reproduire cette façon de faire dans nos propres fonctions qui possèdent un argument du même type que l’argument <code>useNA</code> de la fonction <code>table</code>. La fonction <code>match.arg</code> vérifie que la valeur donnée en entrée à un argument est bien une valeur acceptée ou retourne le premier élément du vecteur de valeurs possibles si aucune valeur n’a été donnée en entrée à l’argument. Par exemple, remplaçons l’argument <code>sortieMatrice</code> de notre fonction <code>statDesc</code> par l’argument <code>formatSortie</code> comme suit.</p>
<pre class="r"><code>statDesc &lt;- function (x, formatSortie = c(&quot;vecteur&quot;, &quot;matrice&quot;, &quot;liste&quot;)) {
  # Calcul
  if (is.numeric(x)) {
    stats &lt;- c(min = min(x), moy = mean(x), max = max(x))
  } else if (is.character(x) || is.factor(x)) {
    stats &lt;- table(x, dnn = NULL)
  } else {
    stats &lt;- NA
  }
  # Production de la sortie
  formatSortie &lt;- match.arg(formatSortie)
  if (formatSortie == &quot;matrice&quot;){
    stats &lt;- as.matrix(stats)
    colnames(stats) &lt;- if (is.character(x) || is.factor(x)) &quot;frequence&quot; else &quot;stat&quot;
  } else if (formatSortie == &quot;liste&quot;) {
    stats &lt;- as.list(stats)
  }
  stats
}</code></pre>
<p>La valeur par défaut de l’argument <code>formatSortie</code> est bel et bien <code>&quot;vecteur&quot;</code>.</p>
<pre class="r"><code>statDesc(x = iris$Sepal.Length)</code></pre>
<pre><code>##      min      moy      max 
## 4.300000 5.843333 7.900000</code></pre>
<pre class="r"><code>statDesc(x = iris$Sepal.Length, formatSortie = &quot;vecteur&quot;)</code></pre>
<pre><code>##      min      moy      max 
## 4.300000 5.843333 7.900000</code></pre>
<p>La présence du vecteur des chaînes de caractères possibles dans la définition des arguments est très informative.</p>
</div>
</div>
<div id="appel-dune-fonction" class="section level2">
<h2>Appel d’une fonction</h2>
<p>Les appels à nos propres fonctions respectent les mêmes règles que les <a href="https://stt4230.rbind.io/introduction/base_r/#comment-ecrire-un-appel-de-fonction">appels à n’importe quelle fonction R</a>. En plus du fonctionnement des valeurs par défaut décrit ci-dessus, rappelons que les arguments peuvent être fournis à une fonction R par position, par nom complet ou même par nom partiel. L’association des arguments à leurs valeurs se fait en respectant les règles de préséances suivantes :</p>
<ol style="list-style-type: decimal">
<li>d’abord les arguments fournis avec un nom exact se voient attribuer une valeur,</li>
<li>puis les arguments fournis avec un nom partiel,</li>
<li>et finalement les arguments non nommés, selon leurs positions.</li>
</ol>
<p>Voici quelques exemples.</p>
<pre class="r"><code>testAppel &lt;- function(x, option, param, parametre) {
  cat(&quot;l&#39;argument x prend la valeur&quot;, x, &quot;\n&quot;)
  cat(&quot;l&#39;argument option prend la valeur&quot;, option, &quot;\n&quot;)
  cat(&quot;l&#39;argument param prend la valeur&quot;, param, &quot;\n&quot;)
  cat(&quot;l&#39;argument parametre prend la valeur&quot;, parametre, &quot;\n&quot;)
}</code></pre>
<pre class="r"><code>testAppel(1, 2, 3, 4)</code></pre>
<pre><code>## l&#39;argument x prend la valeur 1 
## l&#39;argument option prend la valeur 2 
## l&#39;argument param prend la valeur 3 
## l&#39;argument parametre prend la valeur 4</code></pre>
<pre class="r"><code>testAppel(1, 2, param = 3, opt = 4)</code></pre>
<pre><code>## l&#39;argument x prend la valeur 1 
## l&#39;argument option prend la valeur 4 
## l&#39;argument param prend la valeur 3 
## l&#39;argument parametre prend la valeur 2</code></pre>
<pre class="r"><code>testAppel(1, par = 2, option = 3, 4)</code></pre>
<pre><code>## Error in testAppel(1, par = 2, option = 3, 4): argument 2 matches multiple formal arguments</code></pre>
<p>Une bonne pratique de programmation en R est d’utiliser l’association par positionnement seulement pour les premiers arguments, ceux les plus souvent utiliser. Les arguments moins communs devraient être nommés afin de conserver un code facile à comprendre.</p>
</div>
<div id="argument-..." class="section level2">
<h2>Argument <code>...</code></h2>
<p>Les deux utilités de l’<a href="https://stt4230.rbind.io/introduction/base_r/#largument-...-et-ses-deux-utilites.">argument <code>...</code></a> ont été mentionnées lors du premier cours. Nous pouvons utiliser cet argument dans nos propres fonctions, en exploitant l’une ou l’autre de ses utilités.</p>
<div id="utilite-1-recevoir-un-nombre-indetermine-darguments" class="section level3">
<h3>Utilité 1 : recevoir un nombre indéterminé d’arguments</h3>
<p>L’argument <code>...</code> peut permettre de prendre un nombre indéterminé d’objets en entrée, comme dans cet exemple.</p>
<pre class="r"><code>statDescMulti &lt;- function(...){
  args &lt;- list(...)
  lapply(X = args, FUN = statDesc)
}</code></pre>
<p>Le corps de la fonction doit contenir une instruction telle que <code>list(...)</code> pour récupérer tous les objets.</p>
<p>Voici un exemple d’appel à cette fonction.</p>
<pre class="r"><code>statDescMulti(iris$Sepal.Length, iris$Petal.Width, iris$Species)</code></pre>
<pre><code>## [[1]]
##      min      moy      max 
## 4.300000 5.843333 7.900000 
## 
## [[2]]
##      min      moy      max 
## 0.100000 1.199333 2.500000 
## 
## [[3]]
##     setosa versicolor  virginica 
##         50         50         50</code></pre>
<p>Il est même possible d’attribuer un nom aux arguments passés. Ces noms deviennent les noms des éléments de la liste retournée en sortie.</p>
<pre class="r"><code>statDescMulti(Sepal.Length = iris$Sepal.Length, 
              Petal.Width = iris$Petal.Width,
              Species = iris$Species)</code></pre>
<pre><code>## $Sepal.Length
##      min      moy      max 
## 4.300000 5.843333 7.900000 
## 
## $Petal.Width
##      min      moy      max 
## 0.100000 1.199333 2.500000 
## 
## $Species
##     setosa versicolor  virginica 
##         50         50         50</code></pre>
</div>
<div id="utilite-2-passer-des-arguments-a-une-autre-fonction" class="section level3">
<h3>Utilité 2 : passer des arguments à une autre fonction</h3>
<p>L’argument <code>...</code> permet aussi de passer des arguments à une fonction appelée dans le corps de la fonction. Par exemple, l’argument <code>...</code> serait utile à notre fonction <code>statDesc</code> pour contrôler le traitement des valeurs manquantes. Dans le corps de la fonction, les appels aux fonctions auxquelles nous souhaitons permettre le passage d’arguments doivent contenir l’argument <code>...</code>.</p>
<pre class="r"><code>statDesc &lt;- function (x, formatSortie = c(&quot;vecteur&quot;, &quot;matrice&quot;, &quot;liste&quot;), ...) {
  # Calcul
  if (is.numeric(x)) {
    stats &lt;- c(min = min(x, ...), moy = mean(x, ...), max = max(x, ...))
  } else if (is.character(x) || is.factor(x)) {
    stats &lt;- table(x, dnn = NULL)
  } else {
    stats &lt;- NA
  }
  # Production de la sortie
  formatSortie &lt;- match.arg(formatSortie)
  if (formatSortie == &quot;matrice&quot;){
    stats &lt;- as.matrix(stats)
    colnames(stats) &lt;- if (is.character(x) || is.factor(x)) &quot;frequence&quot; else &quot;stat&quot;
  } else if (formatSortie == &quot;liste&quot;) {
    stats &lt;- as.list(stats)
  }
  stats
}</code></pre>
<p>Dans cet exemple, l’argument <code>...</code> permet de passer des arguments aux fonctions <code>min</code>, <code>mean</code> et <code>max</code>.</p>
<pre class="r"><code>statDesc(x = c(iris$Sepal.Length, NA))</code></pre>
<pre><code>## min moy max 
##  NA  NA  NA</code></pre>
<pre class="r"><code>statDesc(x = c(iris$Sepal.Length, NA), na.rm = TRUE)</code></pre>
<pre><code>##      min      moy      max 
## 4.300000 5.843333 7.900000</code></pre>
</div>
</div>
</div>
<div id="sortie-dune-fonction" class="section level1">
<h1>Sortie d’une fonction</h1>
<p>Une fonction retourne :</p>
<ul>
<li>l’objet donné en argument à la fonction <code>return</code> dans le corps de la fonction,</li>
<li>ou, en l’absence d’appel à la fonction <code>return</code>, la dernière expression évaluée dans le corps de la fonction.</li>
</ul>
<p>Par exemple, la version suivante de la fonction <code>statDescMulti</code> retourne la liste des arguments fournis en entrée plutôt que le résultat de l’appel à <code>lapply</code> à cause de la présence de la fonction <code>return</code>.</p>
<pre class="r"><code>statDescMulti &lt;- function(...){
  args &lt;- list(...)
  return(args)
  lapply(X = args, FUN = statDesc)
}</code></pre>
<pre class="r"><code>statDescMulti(rating = attitude$rating, complaints = attitude$complaints)</code></pre>
<pre><code>## $rating
##  [1] 43 63 71 61 81 43 58 71 72 67 64 67 69 68 77 81 74 65 65 50 50 64 53
## [24] 40 63 66 78 48 85 82
## 
## $complaints
##  [1] 51 64 70 63 78 55 67 75 82 61 53 60 62 83 77 90 85 60 70 58 40 61 66
## [24] 37 54 77 75 57 85 82</code></pre>
<p>Une fonction ne peut retourner qu’un seul objet. Pour retourner plusieurs objets, il faut les combiner dans un seul objet (typiquement dans une liste), comme dans l’exemple suivant.</p>
<pre class="r"><code>statDescMulti &lt;- function(...){
  call &lt;- match.call()
  args &lt;- list(...)
  stats &lt;- lapply(X = args, FUN = statDesc)
  list(stats = stats, call = call)
}</code></pre>
<pre class="r"><code>statDescMulti(rating = attitude$rating, complaints = attitude$complaints)</code></pre>
<pre><code>## $stats
## $stats$rating
##      min      moy      max 
## 40.00000 64.63333 85.00000 
## 
## $stats$complaints
##  min  moy  max 
## 37.0 66.6 90.0 
## 
## 
## $call
## statDescMulti(rating = attitude$rating, complaints = attitude$complaints)</code></pre>
<p>Pour faciliter la réutilisation des résultats, il est souhaitable de toujours nommer les éléments d’une liste retournée en sortie.</p>
<div id="fonction-match.call" class="section level2">
<h2>Fonction <code>match.call</code></h2>
<p>L’exemple précédent fait intervenir la fonction <code>match.call</code>. Il est commun pour des fonctions d’ajustement de modèle telles que <code>lm</code> de retourner dans la sortie une copie de l’appel de la fonction.</p>
<pre class="r"><code>exemple &lt;- lm(rating ~ complaints, data = attitude)
exemple$call</code></pre>
<pre><code>## lm(formula = rating ~ complaints, data = attitude)</code></pre>
<p>C’est la fonction <code>match.call</code> qui permet de créer cet élément de la sortie.</p>
<p>Les fonctions <code>match.call</code> et <code>return</code> sont des exemples de fonctions seulement utiles dans le corps d’une fonction. Les appeler directement dans la console retourne une erreur ou une sortie sans intérêt.</p>
</div>
<div id="effets-de-bord-dune-fonction" class="section level2">
<h2>Effets de bord d’une fonction</h2>
<p>En plus de potentiellement retourner un objet, l’exécution d’une fonction peut produire des « effets de bord » (en anglais <em>side effects</em>). Ces effets de bords peuvent être en réalité le but principal de la fonction.</p>
<p>L’exemple le plus courant d’effet de bord est la <strong>production d’un graphique</strong>. Les fonctions graphiques ont un effet puisqu’elles créent ou ajoutent des éléments à un graphique. Cependant, certaines fonctions graphiques ne retournent pas d’objet.</p>
<pre class="r"><code>test &lt;- plot(rating ~ complaints, data = attitude)</code></pre>
<p><img src="/programmation/fonctions_r_2018_files/figure-html/unnamed-chunk-37-1.png" width="50%" style="display: block; margin: auto;" /></p>
<pre class="r"><code>test</code></pre>
<pre><code>## NULL</code></pre>
<p>Un autre exemple d’effet de bord est <strong>l’écriture dans un fichier externe</strong>. Par exemple, la fonction <code>write.table</code> ne retourne rien dans l’environnement de travail de la session R, mais enregistre des données dans un fichier externe, sur le disque de l’ordinateur.</p>
<p>Finalement toute interaction avec l’environnement de travail ou la session R autre que celle de créer un objet contenant la sortie de la fonction peut être considérée comme un effet de bord. Les fonctions suivantes sont toutes des exemples de fonctions ayant des effets de bord :</p>
<ul>
<li><code>library</code> : charge un package, ce qui modifie le chemin de recherche de R;</li>
<li><code>setwd</code> : modifie le répertoire courant;</li>
<li><code>options</code> : modifie les options de la session R;</li>
<li><code>par</code> : modifie les paramètres graphiques;</li>
<li>etc.</li>
</ul>
</div>
</div>
<div id="execution-dune-fonction-et-environnements-associes" class="section level1">
<h1>Exécution d’une fonction et environnements associés</h1>
<p>Lorsqu’une fonction R est appelée, un environnement est créé spécifiquement pour l’évaluation du corps de la fonction, puis détruit lorsque l’exécution est terminée. Rappelons que l’évaluation est simplement la façon dont R s’y prend pour comprendre ce qu’une commande R signifie. Attardons-nous à comprendre comment R fait pour trouver la valeur d’un objet lorsqu’il évalue les instructions dans le corps d’une fonction.</p>
<p>Au départ, l’environnement créé lors de l’appel d’une fonction contient seulement des <em>promesses d’évaluation</em>, car R utilise une évaluation d’arguments dite <em>paresseuse</em>. Il évalue les arguments seulement lorsque le corps de la fonction les utilise pour la première fois. Ainsi, au fur et à mesure que les lignes de code du corps de la fonction sont évaluées, les arguments de la fonction deviennent des objets dans l’environnement créé spécifiquement pour l’évaluation de la fonction.</p>
<p>Un objet associé à un argument donné en entrée lors de l’appel de la fonction est créé en évaluant la valeur qui lui a été attribuée. Pour créer les objets associés aux arguments auxquels aucune valeur n’a été fournie dans l’appel de la fonction, R évalue l’instruction fournie comme valeur par défaut dans la définition de la fonction.</p>
<p>Les instructions formant le corps de la fonction créent parfois de nouveaux objets. Ceux-ci sont créés dans l’environnement d’évaluation de la fonction. En informatique, ces objets sont appelés <strong>variables locales</strong>.</p>
<div id="portee-lexicale" class="section level2">
<h2>Portée lexicale</h2>
<p>Trouver la valeur des arguments et des variables locales en cours d’évaluation d’une fonction est simple pour R. Ces objets se trouvent directement dans l’environnement d’évaluation de la fonction. On dit en informatique qu’ils ont une <strong>portée locale</strong>.</p>
<p>Mais comment R trouve-t-il la valeur des objets appelés à l’intérieur d’une fonction, qui ne sont ni des arguments ni des variables locales?</p>
<p>Chaque langage de programmation suit une certaine règle pour résoudre ce problème. Les deux règles les plus courantes sont l’utilisation d’une <strong>portée lexicale</strong> (en anglais <em>lexical scoping</em>) ou encore d’une <strong>portée dynamique</strong> (en anglais <em>dynamic scoping</em>).</p>
<p>Avec une portée lexicale, si un objet appelé n’est pas trouvé dans l’environnement d’évaluation d’une fonction, le programme va le chercher dans l’environnement d’où la fonction a été <strong>créée</strong>, nommé <strong>environnement englobant</strong> (en anglais <em>enclosing environment</em>). Avec une portée dynamique, le programme va plutôt le chercher dans l’environnement d’où la fonction a été <strong>appelée</strong>, nommé <strong>environnement d’appel</strong> (en anglais <em>calling environment</em>).</p>
<p><strong>R utilise par défaut la portée lexicale.</strong></p>
<p>Voici un petit exemple pour illustrer la portée lexicale.</p>
<pre class="r"><code>a &lt;- 1
b &lt;- 2
f &lt;- function(x) {
  a*x + b
}</code></pre>
<p>Quelle valeur sera retournée par <code>f(2)</code>? Est-ce 1*2 + 2 = 4? Oui!</p>
<pre class="r"><code>f(2)</code></pre>
<pre><code>## [1] 4</code></pre>
<p>Les objets nommés <code>a</code> et <code>b</code> ne se retrouvaient pas dans l’environnement d’exécution de la fonction. Alors R a cherché leurs valeurs dans l’environnement englobant de la fonction <code>f</code>, qui est ici l’environnement de travail.</p>
<pre class="r"><code>environment(f)</code></pre>
<pre><code>## &lt;environment: R_GlobalEnv&gt;</code></pre>
<p>Il a trouvé <code>a</code> = 1 et <code>b</code> = 2. La fonction <code>environment</code> retourne l’environnement englobant d’une fonction.</p>
<p>Modifions maintenant l’exemple comme suit.</p>
<pre class="r"><code>g &lt;- function(x) {
  a &lt;- 2
  b &lt;- 1
  f(x)
}</code></pre>
<p>Quelle valeur sera retournée par <code>g(2)</code>? Est-ce 2*2 + 1 = 5? Non!</p>
<pre class="r"><code>g(2)</code></pre>
<pre><code>## [1] 4</code></pre>
<p>La fonction <code>g</code> est appelée dans l’environnement de travail. Elle appelle elle-même <code>f</code>. L’environnement d’appel de <code>f</code> est donc l’environnement d’exécution de <code>g</code>. Par contre, l’environnement englobant de <code>f</code> n’a pas changé. Il est encore l’environnement de travail, car c’est dans cet environnement que la fonction a été définie.</p>
<pre class="r"><code>environment(f)</code></pre>
<pre><code>## &lt;environment: R_GlobalEnv&gt;</code></pre>
<p>La portée lexicale permet de s’assurer que le fonctionnement de l’évaluation d’une fonction ne dépende pas du contexte dans lequel la fonction est appelée. Il dépend seulement de l’environnement d’où la fonction a été créée.</p>
<p>Si la portée en R était par défaut dynamique, <code>g(2)</code> aurait retourné la valeur 5.</p>
<p>Et si <code>f</code> était créée à l’intérieur de la fonction <code>g</code>?</p>
<pre class="r"><code>g&lt;-function(x) {
  f&lt;-function(x) {
    a*x + b
  }
  a &lt;- 2
  b &lt;- 1
  f(x)
}</code></pre>
<p>Que retourne <code>g(2)</code> maintenant?</p>
<pre class="r"><code>g(2)</code></pre>
<pre><code>## [1] 5</code></pre>
<p>L’environnement englobant de <code>f</code> est maintenant l’environnement d’exécution de <code>g</code>, car <code>f</code> a été défini dans le corps de la fonction <code>g</code>.</p>
<p>Notons que l’environnement englobant des fonctions disponibles en R autres que celles que nous avons créées en cours de session est l’espace de noms du package d’où provient la fonction. Par exemple, l’environnement englobant de la fonction <code>mean</code> est l’espace de noms du package <code>base</code>. Nous verrons plus en détail ce qu’est un espace de noms plus tard.</p>
<pre class="r"><code>environment(mean)</code></pre>
<pre><code>## &lt;environment: namespace:base&gt;</code></pre>
</div>
<div id="chemin-de-recherche-complet" class="section level2">
<h2>Chemin de recherche complet</h2>
<p>Le chemin de recherche de valeurs des objets lors de l’évaluation d’une fonction en R ne s’arrête pas à l’environnement d’exécution de la fonction suivi de l’environnement englobant de la fonction. Il remonte toujours jusqu’à l’environnement de travail. Parfois, l’environnement englobant est directement l’environnement de travail. Si l’environnement englobant est plutôt l’environnement d’exécution d’une autre fonction, alors la recherche se poursuit dans l’environnement englobant de cette fonction. En remontant ainsi le chemin des environnements englobants, on finit toujours par retomber sur l’environnement de travail. Et de là, le chemin de recherche se poursuit par les environnements de tous les packages chargés, tel que vu dans les notes sur des <a href="https://stt4230.rbind.io/programmation/info_techniques_r/#evaluation-dexpressions-en-r-et-environnements">informations techniques concernant R</a>. Nous pouvons donc utiliser, dans les fonctions que nous créons, des fonctions provenant d’autres packages. Il faut seulement s’assurer que ces packages soient chargés pour que nos fonctions roulent sans erreur.</p>
</div>
<div id="bonnes-pratiques-concernant-les-objets-utilisables-dans-le-corps-dune-fonction" class="section level2">
<h2>Bonnes pratiques concernant les objets utilisables dans le corps d’une fonction</h2>
<p>Il est recommandé d’utiliser dans une fonction uniquement des objets que nous sommes certains de pouvoir atteindre. L’idéal est de se limiter aux arguments de la fonction, aux objets créés dans la fonction (variables locales) ainsi qu’aux objets se trouvant dans des packages <em>chargés</em>.</p>
<p>Ceux qui comprennent bien le concept de portée lexical peuvent aussi s’amuser à utiliser des objets dans l’environnement englobant d’une fonction.</p>
<p>Cependant, il est risqué d’utiliser les objets de l’environnement de travail, même si cet environnement se retrouve toujours dans le chemin de recherche de valeurs des objets lors de l’évaluation d’une fonction. Le contenu de l’environnement de travail est constamment modifié au fil de nos sessions. Aussi, si nous partageons nos fonctions avec une autre personne, nous ne contrôlons pas le contenu de l’environnement de travail pendant la session R de cette personne.</p>
<p>Ces recommandations s’appliquent au code dans le corps d’une fonction, mais aussi aux instructions définissant les valeurs par défaut des arguments. Nous avons appris que ces instructions sont évaluées dans le corps de la fonction. Elles peuvent donc contenir sans problème d’autres arguments de la fonction. Cependant, nous devrions éviter d’utiliser des objets provenant de l’environnement de travail dans ces instructions.</p>
</div>
</div>
<div id="exemple-de-creation-dune-fonction-r" class="section level1">
<h1>Exemple de création d’une fonction R</h1>
<p>Nous allons créer ensemble une fonction qui calcule la quantité de nombres entiers impairs dans un vecteur numérique. Cet exemple est tiré de</p>
<ul>
<li>Matloff, N. (2011). The Art of R Programming : A Tour of Statistical Software Design. No Starch Press. Sections 1.3 et 7.4.</li>
</ul>
<div id="etapes-de-developpement-conseillees" class="section level2">
<h2>Étapes de développement conseillées</h2>
<ol style="list-style-type: decimal">
<li><strong>Planifier</strong> le travail (pas de programmation encore) :
<ul>
<li>définir clairement la tâche à accomplir par la fonction et la sortie qu’elle doit produire,</li>
<li>prévoir les étapes à suivre afin d’effectuer cette tâche,</li>
<li>identifier les arguments devant être fournis en entrée à la fonction.</li>
</ul></li>
<li><strong>Développer le corps de la fonction</strong>
<ul>
<li>2.1 Écrire le programme par étapes, d’abord sans former la fonction, en commentant bien le code et en travaillant sur des mini-données test.</li>
<li>2.2 Pour chaque petite étape ou sous-tâche, tester interactivement si le programme produit le résultat escompté (tester souvent en cours de travail, ainsi il y a moins de débogage à faire).</li>
</ul></li>
<li><strong>Créer la fonction</strong> à partir du programme développé.</li>
<li><strong>Documenter</strong> la fonction.</li>
</ol>
<p>D’autres étapes de développement seront abordées au prochain cours.</p>
<div id="planifier-le-travail" class="section level4">
<h4>1. Planifier le travail :</h4>
<ul>
<li>entrée = un vecteur de nombres (= 1 seul argument)</li>
<li>sortie = le dénombrement (une seule valeur)</li>
<li>utiliser l’opérateur modulo pour tester si un nombre est impair</li>
<li>nous pourrions travailler de façon vectorielle ou encore utiliser une boucle sur les éléments du vecteur</li>
</ul>
</div>
<div id="developper-le-corps-de-la-fonction" class="section level4">
<h4>2. Développer le corps de la fonction :</h4>
<p>Création de mini-données test</p>
<pre class="r"><code>x &lt;- c(6, 3, 5.5, 1, 0, -5)</code></pre>
<p>Ce vecteur contient 3 nombres entiers impairs. C’est le résultat que nous visons obtenir.</p>
<p>Code le plus simple qui me vient en tête :</p>
<pre class="r"><code>sum(x %% 2 == 1)</code></pre>
<pre><code>## [1] 3</code></pre>
<p>Nous obtenons bien 3. Ça marche pour les mini-données test.</p>
<p>Ce code est équivalent à la boucle suivante :</p>
<pre class="r"><code>k &lt;- 0
for (n in x){
  if (n %% 2 == 1) k &lt;- k + 1
}
k</code></pre>
<pre><code>## [1] 3</code></pre>
</div>
<div id="creer-la-fonction-a-partir-du-programme-developpe" class="section level4">
<h4>3. Créer la fonction à partir du programme développé :</h4>
<pre class="r"><code>compteImpair1 &lt;- function(x) {
  sum(x %% 2 == 1)
}

compteImpair2 &lt;- function(x) {
  k &lt;- 0
  for (n in x){
    if (n %% 2 == 1) k &lt;- k + 1
  }
  k
}</code></pre>
</div>
<div id="documenter-la-fonction." class="section level4">
<h4>4. Documenter la fonction.</h4>
<p><strong>Option 1</strong> : Documentation en commentaire dans le corps de la fonction.</p>
<pre class="r"><code>compteImpair1 &lt;- function(x) {
  # Fonction qui calcule la quantité de nombres entiers impairs dans un vecteur numérique
  # Argument en entrée : x = vecteur numérique
  # Sortie : le nombre de nombres entiers impairs dans x
  sum(x %% 2 == 1)
}</code></pre>
<p><strong>Option 2</strong> : Documentation en commentaire avant la définition de la fonction.</p>
<pre class="r"><code># Fonction qui calcule la quantité de nombres entiers impairs dans un vecteur numérique
# Argument en entrée : x = vecteur numérique
# Sortie : le nombre de nombres entiers impairs dans x
compteImpair2 &lt;- function(x) {
  k &lt;- 0
  for (n in x){
    if (n %% 2 == 1) k &lt;- k + 1
  }
  k
}</code></pre>
<p><strong>Options supplémentaires</strong> : Nous verrons d’autres options dans le cours sur les packages.</p>
</div>
<div id="comparaison-des-2-fonctions" class="section level4">
<h4>Comparaison des 2 fonctions :</h4>
<p>Nous avons créé 2 fonctions qui, à première vue, retournent toutes les deux le résultat escompté. Nous devrions par contre les tester sur plus de données pour en être certains. Ce sera fait dans les notes sur les tests et exceptions en R. Pour l’instant, tenons pour acquis que ces fonctions accomplissent correctement leur tâche.</p>
<p>Dans ce cas, laquelle des 2 fonctions devrions-nous utiliser?</p>
<p>Réponse : la plus rapide.</p>
<p>Créons un vecteur très grand pour comparer le temps d’exécution des deux fonctions.</p>
<pre class="r"><code>x &lt;- round(runif(1000000, -10, 10))</code></pre>
<p>Utilisons la fonction <code>system.time</code> pour évaluer les temps d’exécution.</p>
<pre class="r"><code>system.time(compteImpair1(x))</code></pre>
<pre><code>##    user  system elapsed 
##    0.01    0.00    0.03</code></pre>
<pre class="r"><code>system.time(compteImpair2(x))</code></pre>
<pre><code>##    user  system elapsed 
##    0.25    0.00    0.25</code></pre>
<p>L’écart dans les temps d’exécution des deux fonctions se creuse encore plus si nous augmentons la longueur du vecteur <code>x</code>.</p>
<p>Nous devrions donc choisir d’utiliser <code>compteImpair1</code> plutôt que <code>compteImpair2</code>.</p>
<p>Nous allons revenir plus tard sur l’optimisation des temps d’exécution de nos fonctions.</p>
<hr />
</div>
</div>
</div>
<div id="references" class="section level1">
<h1>Références</h1>
<ul>
<li>Matloff, N. (2011). The Art of R Programming : A Tour of Statistical Software Design. No Starch Press. Chapitre 7.</li>
<li><a href="http://adv-r.had.co.nz/Functions.html" class="uri">http://adv-r.had.co.nz/Functions.html</a></li>
<li><a href="http://adv-r.had.co.nz/Environments.html" class="uri">http://adv-r.had.co.nz/Environments.html</a></li>
<li><a href="https://www.datacamp.com/community/tutorials/functions-in-r-a-tutorial" class="uri">https://www.datacamp.com/community/tutorials/functions-in-r-a-tutorial</a></li>
</ul>
</div>
