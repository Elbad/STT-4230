---
title: "Calculs de base en R"
author: "Sophie Baillargeon, Université Laval"
date: "2019-01-16"
weight: 1
slug: "calculs_base_r"
categories: ["cours_2019-01-29"]
categories_weight: 1
lastmodifierdisplayname : "Sophie Baillargeon"
lastmodifieremail: "sophie.baillargeon@mat.ulaval.ca"
output:
  pdf_document:
    toc: yes
    toc_depth: 3
  blogdown::html_page:
    toc: true
header-includes:
- \usepackage{float}
- \usepackage[french]{babel}
- \frenchbsetup{StandardLayout}
- \hypersetup{colorlinks=true, urlcolor = {blue}, linkcolor = {blue}}
---






<div id="TOC">
<ul>
<li><a href="#fonctionnement-vectoriel-et-regle-de-recyclage">Fonctionnement vectoriel et règle de recyclage</a></li>
<li><a href="#fonctions-et-operateurs-pour-des-calculs-mathematiques">Fonctions et opérateurs pour des calculs mathématiques</a><ul>
<li><a href="#operateurs-mathematiques">Opérateurs mathématiques</a><ul>
<li><a href="#operateurs-arithmetiques">Opérateurs arithmétiques</a></li>
<li><a href="#operateurs-de-comparaison">Opérateurs de comparaison</a></li>
<li><a href="#operateurs-logiques">Opérateurs logiques</a></li>
</ul></li>
<li><a href="#fonctions-mathematiques-agissant-de-facon-vectorielle">Fonctions mathématiques agissant de façon vectorielle</a></li>
<li><a href="#fonctions-mathematiques-combinant-des-elements">Fonctions mathématiques combinant des éléments</a></li>
<li><a href="#fonctions-doperations-sur-des-ensembles">Fonctions d’opérations sur des ensembles</a></li>
<li><a href="#mots-cles-mathematiques">Mots-clés mathématiques</a></li>
</ul></li>
<li><a href="#fonctions-pour-le-calcul-de-statistiques-descriptives">Fonctions pour le calcul de statistiques descriptives</a><ul>
<li><a href="#fonctions-retournant-une-seule-statistique">Fonctions retournant une seule statistique</a><ul>
<li><a href="#traitement-des-observations-manquantes-et-argument-na.rm">Traitement des observations manquantes et argument <code>na.rm</code></a></li>
</ul></li>
<li><a href="#fonctions-pouvant-retourner-plusieurs-statistiques">Fonctions pouvant retourner plusieurs statistiques</a></li>
<li><a href="#fonctions-retournant-un-vecteur-de-statistiques">Fonctions retournant un vecteur de statistiques</a></li>
<li><a href="#fonctions-de-calcul-de-frequences">Fonctions de calcul de fréquences</a></li>
<li><a href="#fonctions-pour-le-traitement-des-observations-dupliquees">Fonctions pour le traitement des observations dupliquées</a></li>
</ul></li>
<li><a href="#fonctions-de-la-famille-des-apply">Fonctions de la famille des <code>apply</code></a><ul>
<li><a href="#fonction-apply">Fonction <code>apply</code></a><ul>
<li><a href="#fonctions-raccourcies-rowsums-colsums-rowmeans-et-colmeans">Fonctions raccourcies : <code>rowSums</code>, <code>colSums</code>, <code>rowMeans</code> et <code>colMeans</code></a></li>
</ul></li>
<li><a href="#fonctions-lapply-sapply-et-mapply">Fonctions <code>lapply</code>, <code>sapply</code> et <code>mapply</code></a></li>
<li><a href="#fonctions-tapply-by-et-aggregate">Fonctions <code>tapply</code>, <code>by</code> et <code>aggregate</code></a></li>
<li><a href="#choix-de-la-fonction-de-la-famille-des-apply-a-utiliser">Choix de la fonction de la famille des <code>apply</code> à utiliser</a></li>
</ul></li>
<li><a href="#ecriture-de-conditions-logiques">Écriture de conditions logiques</a><ul>
<li><a href="#operateurs-et-fonctions-retournant-toujours-un-logique-de-longueur-1">Opérateurs et fonctions retournant toujours un logique de longueur 1</a></li>
</ul></li>
<li><a href="#comparaison-de-deux-objets-r">Comparaison de deux objets R</a></li>
<li><a href="#synthese">Synthèse</a></li>
<li><a href="#references">Références</a></li>
</ul>
</div>

<hr />
<p>R est un environnement spécialisé dans les calculs statistiques. Voyons comment réaliser de tels calculs en R, en se limitant pour l’instant à des calculs simples. Des fonctionnalités de R permettant de réaliser des calculs plus avancés (ex. réaliser des tests statistiques, ajuster des modèles, générer des observations aléatoires, faire de l’algèbre linéaire, etc.) seront vues dans un autre cours. Je présente ici des fonctionnalités utiles pour :</p>
<ul>
<li>implanter une formule mathématique,</li>
<li>effectuer une transformation mathématique de variables dans un jeu de données,</li>
<li>calculer des statistiques descriptives, par exemple dans le cadre d’une analyse exploratoire de données.</li>
</ul>
<div id="fonctionnement-vectoriel-et-regle-de-recyclage" class="section level1">
<h1>Fonctionnement vectoriel et règle de recyclage</h1>
<p>Tous les opérateurs et plusieurs des fonctions qui sont présentées dans cette fiche agissent de façon vectorielle. Ils appliquent un calcul terme à terme entre deux objets atomiques (vecteurs, matrices ou arrays) ou data frames contenant uniquement des éléments numériques.</p>
<p>Par exemple, si les deux matrices suivantes sont additionnées avec l’opérateur <code>+</code>,</p>
<pre class="r"><code>matrix(1:6 , nrow = 2, ncol = 3)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6</code></pre>
<pre class="r"><code>matrix(6:1 , nrow = 2, ncol = 3)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    6    4    2
## [2,]    5    3    1</code></pre>
<p>l’élément en position (i,j) dans la première matrice sera additionné à l’élément à la même position dans la deuxième matrice, et ce, pour toutes les positions. Le résultats cette addition terme à terme est donc le suivant :</p>
<pre class="r"><code>matrix(1:6 , nrow = 2, ncol = 3) + matrix(6:1 , nrow = 2, ncol = 3)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    7    7    7
## [2,]    7    7    7</code></pre>
<p> </p>
<p>Si les deux objets intervenant dans l’opération ne sont pas de mêmes dimensions, la <strong>règle de recyclage</strong> s’applique. Cette règle avait déjà été mentionnée dans les notes sur les <a href="https://stt4230.rbind.io/manipulation_donnees/structures_r/#remplacement-delements">structures de données en R</a>. Étant donné son importance, revoyons-là plus en profondeur ici.</p>
<pre class="r"><code>c(5, 6) + c(2, 5, 3, 1)</code></pre>
<pre><code>## [1]  7 11  8  7</code></pre>
<p>L’instruction précédente effectue 4 additions, une pour chacun des 4 éléments du plus long des deux vecteurs dans l’opération, soit ici le deuxième. Le premier vecteur est plutôt de longueur 2. R répète donc ses éléments pour créer un vecteur aussi long que le deuxième</p>
<pre class="r"><code>rep(c(5, 6), 4/2)</code></pre>
<pre><code>## [1] 5 6 5 6</code></pre>
<p>et effectue en réalité l’opération suivante :</p>
<pre class="r"><code>c(5, 6, 5, 6) + c(2, 5, 3, 1)</code></pre>
<pre><code>## [1]  7 11  8  7</code></pre>
<p>Cette règle de recyclage est exploitée, souvent sans que l’utilisateur en soit pleinement conscient, lorsque l’un des deux vecteurs impliqués dans une opération est de longueur 1. Par exemple, la commande suivante impliquant un exposant,</p>
<pre class="r"><code>c(2, 5, 3, 1)^2</code></pre>
<pre><code>## [1]  4 25  9  1</code></pre>
<p>est en fait traduite par R en la commande suivante :</p>
<pre class="r"><code>c(2, 5, 3, 1)^rep(2, 4)</code></pre>
<pre><code>## [1]  4 25  9  1</code></pre>
<div id="regle-de-recyclage-avec-des-objets-a-plus-dune-dimension" class="section level4">
<h4>Règle de recyclage avec des objets à plus d’une dimension</h4>
<p>Cette règle ne s’applique pas seulement avec des vecteurs. Par exemple, pour additionner le même vecteur, disons</p>
<pre class="r"><code>3:1</code></pre>
<pre><code>## [1] 3 2 1</code></pre>
<p>à chacune des colonnes d’une matrice, disons</p>
<pre class="r"><code>matrix(1:12 , nrow = 3, ncol = 4)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   10
## [2,]    2    5    8   11
## [3,]    3    6    9   12</code></pre>
<p>il suffit de lancer la commande suivante</p>
<pre class="r"><code>matrix(1:12 , nrow = 3, ncol = 4) + 3:1</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    4    7   10   13
## [2,]    4    7   10   13
## [3,]    4    7   10   13</code></pre>
<p>au lieu de la suivante, qui retourne exactement le même résultat.</p>
<pre class="r"><code>matrix(1:12 , nrow = 3, ncol = 4) + matrix(rep(3:1, 4), nrow = 3, ncol = 4)</code></pre>
<p>Dans cette dernière commande, les deux arguments fournis à l’opérateur <code>+</code> sont réellement de mêmes dimensions, car la deuxième matrice est la suivante</p>
<pre class="r"><code>matrix(rep(3:1, 4), nrow = 3, ncol = 4)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    3    3    3    3
## [2,]    2    2    2    2
## [3,]    1    1    1    1</code></pre>
<p>Une règle de recyclage utilisée pour former une matrice de dimension appropriée va donc remplir la matrice une colonne à la fois, comme le fait la fonction <code>matrix</code> par défaut.</p>
</div>
<div id="regle-de-recyclage-lorsque-la-longueur-de-lobjet-le-plus-long-nest-pas-multiple-de-la-longueur-de-lobjet-le-plus-court" class="section level4">
<h4>Règle de recyclage lorsque la longueur de l’objet le plus long n’est pas multiple de la longueur de l’objet le plus court</h4>
<p>Lorsque la longueur de l’objet le plus long n’est pas multiple de la longueur de l’objet le plus court, la règle de recyclage fonctionne quand même. R recycle l’objet le plus court assez de fois pour arriver à un objet de longueur égale ou supérieure à l’objet le plus long. Ensuite, si l’objet recyclé est plus long que l’autre objet, il est tronqué de façon à ce que les deux objets aient la même longueur.</p>
<p>Supposons par exemple que la commande suivante soit soumise en R.</p>
<pre class="r"><code>1:12 + 5:1</code></pre>
<p>L’objet de gauche dans l’addition est de longueur 12 et l’objet de droite de longueur 5. L’objet de droite sera donc recyclé 3 fois,</p>
<pre class="r"><code>objet_recycle &lt;- rep(5:1, 3)
objet_recycle</code></pre>
<pre><code>##  [1] 5 4 3 2 1 5 4 3 2 1 5 4 3 2 1</code></pre>
<p>puis sa longueur sera réduite à la longueur de l’objet de gauche.</p>
<pre class="r"><code>length(objet_recycle) &lt;- length(1:12)
objet_recycle</code></pre>
<pre><code>##  [1] 5 4 3 2 1 5 4 3 2 1 5 4</code></pre>
<p>Ensuite l’addition terme à terme sera effectuée.</p>
<pre class="r"><code>1:12 + objet_recycle</code></pre>
<pre><code>##  [1]  6  6  6  6  6 11 11 11 11 11 16 16</code></pre>
<p>Cependant, R émettra un avertissement pour nous informer qu’il a dû faire cet ajustement de longueur.</p>
<pre class="r"><code>1:12 + 5:1</code></pre>
<pre><code>## Warning in 1:12 + 5:1: longer object length is not a multiple of shorter
## object length</code></pre>
<pre><code>##  [1]  6  6  6  6  6 11 11 11 11 11 16 16</code></pre>
</div>
</div>
<div id="fonctions-et-operateurs-pour-des-calculs-mathematiques" class="section level1">
<h1>Fonctions et opérateurs pour des calculs mathématiques</h1>
<div id="operateurs-mathematiques" class="section level2">
<h2>Opérateurs mathématiques</h2>
<div id="operateurs-arithmetiques" class="section level3">
<h3>Opérateurs arithmétiques</h3>
<p>Voici une liste d’opérateurs arithmétiques disponibles en R :</p>
<ul>
<li><code>+</code> : addition,</li>
<li><code>-</code> : soustraction,</li>
<li><code>*</code> : multiplication,</li>
<li><code>/</code> : division,</li>
<li><code>^</code> : puissance,</li>
<li><code>%/%</code> : division entière,</li>
<li><code>%%</code> : modulo = reste de la division entière.</li>
</ul>
<p>Les premiers opérateurs sont usuels et ne requièrent aucune explication. Expliquons cependant brièvement les deux derniers opérateurs de cette liste.</p>
<div id="division-entiere-et-modulo" class="section level4">
<h4>Division entière et modulo</h4>
<p>L’opérateur <code>%/%</code> réalise une division entière. Pour illustrer ce type de division, prenons l’exemple suivant.</p>
<pre class="r"><code>5/2</code></pre>
<pre><code>## [1] 2.5</code></pre>
<p>L’opérateur de division ordinaire <code>/</code> retourne un nombre réel. L’opérateur <code>%/%</code> retourne la partie entière du résultat obtenu avec <code>/</code>. La partie décimale est tronquée.</p>
<pre class="r"><code>5%/%2</code></pre>
<pre><code>## [1] 2</code></pre>
<p>L’opérateur modulo <code>%%</code> retourne le reste de la division entière. Dans l’exemple traité ici, ce reste vaut 1 car 5 - 2*2 = 1.</p>
<pre class="r"><code>5%%2</code></pre>
<pre><code>## [1] 1</code></pre>
<p><strong>Astuces</strong> : Cet opérateur est pratique pour tester si des nombres sont pairs ou impairs. Les nombres pairs sont des multiples de 2. Alors <code>x %% 2</code> retourne 0 pour les nombres pairs et 1 pour les nombres impairs. L’opérateur modulo peut aussi servir à tester si un nombre stocké sous le type <code>double</code> est en réalité un entier. S’il s’agit d’un entier, <code>x %% 1</code> retournera 0.</p>
</div>
</div>
<div id="operateurs-de-comparaison" class="section level3">
<h3>Opérateurs de comparaison</h3>
<p>Les opérateurs de comparaison permettent de comparer des valeurs. Ils retournent <code>TRUE</code> ou <code>FALSE</code>. Il s’agit des opérateurs suivants :</p>
<ul>
<li><code>==</code> : égalité,</li>
<li><code>!=</code> : non-égalité,</li>
<li><code>&gt;</code> : plus grand,</li>
<li><code>&gt;=</code> : plus grand ou égal,</li>
<li><code>&lt;</code> : plus petit,</li>
<li><code>&lt;=</code> : plus petit ou égal.</li>
</ul>
<p>Supposons <code>a</code> et <code>b</code> les deux vecteurs numériques suivants.</p>
<pre class="r"><code>a &lt;- c(2, 5, 7, 3)
b &lt;- c(3, 5, 6, 4)</code></pre>
<p>Comparons ces vecteurs à l’aide d’un opérateur de comparaison. Est-ce que les valeurs contenues dans <code>a</code> sont supérieures ou égales aux valeurs contenues dans <code>b</code> ?</p>
<pre class="r"><code>a &gt;= b</code></pre>
<pre><code>## [1] FALSE  TRUE  TRUE FALSE</code></pre>
<p>L’opérateur fonctionne de façon vectorielle, donc la comparaison est effectuée terme à terme. Les valeurs dans le résultat retourné sont de type logique.</p>
<p>Les valeurs dans un vecteur peuvent aussi être comparées à une seule valeur, auquel cas la règle de recyclage s’applique.</p>
<pre class="r"><code>a != 5</code></pre>
<pre><code>## [1]  TRUE FALSE  TRUE  TRUE</code></pre>
<div id="comparaison-de-valeurs-non-numeriques" class="section level4">
<h4>Comparaison de valeurs non numériques</h4>
<p>Les opérateurs de comparaison ne fonctionnent pas seulement avec des valeurs numériques. Ils peuvent aussi être utilisés pour comparer des valeurs logiques ou caractères. Dans ce cas, il faut savoir que R considère que <code>FALSE</code> est inférieure à <code>TRUE</code>.</p>
<pre class="r"><code>FALSE &lt; TRUE </code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Quant aux caractères, les opérateurs de comparaison utilisent l’ordre de classement des caractères pour déterminer, entre deux valeurs, celle qui est inférieure. Cet ordre dépend des paramètres régionaux de la session R. D’une langue à l’autre, cet ordre peut varier.</p>
<p>Pour connaître l’ordre utilisé dans une session R, les instructions suivantes sont utiles :</p>
<pre class="r"><code>caracteres_speciaux &lt;- 
  c(&quot;!&quot;, &quot;\&quot;&quot;, &quot;#&quot;, &quot;$&quot;, &quot;%&quot;, &quot;&amp;&quot;, &quot;&#39;&quot;, &quot;(&quot;, &quot;)&quot;, &quot;*&quot;, &quot;+&quot;, &quot;,&quot;, &quot;-&quot;, &quot;.&quot;, &quot;/&quot;, &quot;:&quot;, &quot;;&quot;, 
    &quot;&lt;&quot;, &quot;=&quot;,&quot;&gt;&quot;, &quot;?&quot;, &quot;@&quot;, &quot;[&quot;, &quot;\\&quot;, &quot;]&quot;, &quot;^&quot;, &quot;_&quot;, &quot;{&quot;, &quot;|&quot;, &quot;}&quot;, &quot;~&quot;)
lettres_accentuees &lt;- c(&quot;à&quot;, &quot;â&quot;, &quot;é&quot;, &quot;è&quot;, &quot;ê&quot;, &quot;ë&quot;, &quot;ï&quot;, &quot;î&quot;, &quot;ô&quot;, &quot;ù&quot;, &quot;ü&quot;, &quot;û&quot;, &quot;ç&quot;)
catacteres_ordonnes &lt;- sort(c(caracteres_speciaux, 0:9, letters, LETTERS, 
                              lettres_accentuees, toupper(lettres_accentuees))) 
paste(catacteres_ordonnes, collapse = &quot;&quot;)</code></pre>
<p>J’ai obtenu le résultat suivant, qui sera peut-être différent sur votre ordinateur si vous n’avez pas les mêmes paramètres régionaux que moi.</p>
<pre><code>&quot;&#39;-!\&quot;#$%&amp;()*,./:;?@[\\]^_{|}~+&lt;=&gt;0123456789aAàÀâÂbBcCçÇdDeEéÉèÈêÊëËfFgGhHiIîÎïÏjJkKlLmM
nNoOôÔpPqQrRsStTuUùÙûÛüÜvVwWxXyYzZ&quot;</code></pre>
<p>Ainsi, dans ma session R :</p>
<ul>
<li>les caractères spéciaux sont inférieurs aux chiffres et aux lettres,</li>
<li>les chiffres sont inférieurs aux lettres,</li>
<li>les lettres sont classées en ordre aphabétique et
<ul>
<li>les lettres minuscules sont inférieures aux lettres majuscules,</li>
<li>les lettres non accentuées sont inférieures aux lettres accentuées.</li>
</ul></li>
</ul>
<p>Pour des chaînes à plus d’un caractère, la comparaison s’effectue caractère par caractère (premiers caractères comparés entre eux, puis deuxièmes en cas d’égalité, puis troisièmes en cas d’égalités aux deux premières positions, etc.).</p>
<pre class="r"><code>&quot;arborescence&quot; &lt; &quot;arbre&quot; </code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Aussi, l’absence de caractères vaut moins que la présence.</p>
<pre class="r"><code>&quot;a&quot; &lt; &quot;aa&quot;</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p> </p>
<p><strong>Remarque</strong> : Afin de correctement ordonner des nombres, il faut s’assurer de les stocker sous un format numérique.</p>
<pre class="r"><code>2 &lt; 10</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>S’ils sont stockés sous forme de chaînes de caractères, les résultats obtenus ne seront pas toujours ceux attendus.</p>
<pre class="r"><code>&quot;2&quot; &lt; &quot;10&quot;</code></pre>
<pre><code>## [1] FALSE</code></pre>
</div>
</div>
<div id="operateurs-logiques" class="section level3">
<h3>Opérateurs logiques</h3>
<p>Les opérateurs logiques prennent en entrée un ou deux vecteurs de logiques et retournent un vecteur de logiques. Il s’agit des opérateurs suivants.</p>
<ul>
<li><code>!</code> : négation,</li>
<li><code>|</code> et <code>||</code> : ou,</li>
<li><code>&amp;</code> et <code>&amp;&amp;</code> : et.</li>
</ul>
<p>De plus, le « ou » exclusif est implémenté par la fonction <code>xor</code>.</p>
<p>L’opérateur <code>!</code> n’a qu’un seul argument, alors que les autres opérateurs logiques en ont deux. Il effectue une négation. Il transforme les <code>TRUE</code> en <code>FALSE</code> et les <code>FALSE</code> en <code>TRUE</code>.</p>
<pre class="r"><code>! c(TRUE, FALSE)</code></pre>
<pre><code>## [1] FALSE  TRUE</code></pre>
<p>Les opérateurs <code>|</code> et <code>&amp;</code> appliquent de façon vectorielle les tables de vérité<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> des opérateurs logiques « ou » et « et » respectivement.</p>
<p>Rappel : <strong>table de vérité de « ou »</strong></p>
<pre class="r"><code>v1 &lt;- rep(c(FALSE, TRUE), each = 2)
v2 &lt;- rep(c(FALSE, TRUE), 2)
cbind(v1, v2, &quot;v1 | v2&quot; = v1 | v2)</code></pre>
<pre><code>##         v1    v2 v1 | v2
## [1,] FALSE FALSE   FALSE
## [2,] FALSE  TRUE    TRUE
## [3,]  TRUE FALSE    TRUE
## [4,]  TRUE  TRUE    TRUE</code></pre>
<p>Ainsi, l’opération « a ou b » retourne faux uniquement si a et b sont faux.</p>
<p>Rappel : <strong>table de vérité de « et »</strong></p>
<pre class="r"><code>cbind(v1, v2, &quot;v1 &amp; v2&quot; = v1 &amp; v2)</code></pre>
<pre><code>##         v1    v2 v1 &amp; v2
## [1,] FALSE FALSE   FALSE
## [2,] FALSE  TRUE   FALSE
## [3,]  TRUE FALSE   FALSE
## [4,]  TRUE  TRUE    TRUE</code></pre>
<p>Ainsi, l’opération « a et b » retourne vrai uniquement si a et b sont vrais.</p>
<p>Les opérateurs <code>||</code> et <code>&amp;&amp;</code> appliquent ces mêmes tables de vérité, mais ils ne travaillent pas de façon vectorielle. Ils retournent toujours un seul <code>TRUE</code> ou un seul <code>FALSE</code>. Si, par inadvertance, <code>||</code> ou <code>&amp;&amp;</code> reçoit en entrée des vecteurs, il effectuera une opération seulement sur les premiers éléments de ces vecteurs, comme dans cet exemple.</p>
<pre class="r"><code>c(TRUE, FALSE, TRUE) &amp;&amp; c(TRUE, FALSE, FALSE)</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
</div>
<div id="fonctions-mathematiques-agissant-de-facon-vectorielle" class="section level2">
<h2>Fonctions mathématiques agissant de façon vectorielle</h2>
<p>R offre aussi plusieurs fonctions de calculs mathématiques, travaillant de façon vectorielle, dont les suivantes :</p>
<ul>
<li>racine carrée : <code>sqrt</code>;</li>
<li>logarithmes et exponentiels : <code>exp</code>, <code>log</code> (= logarithme naturel), <code>log10</code>, <code>log2</code>;</li>
<li>fonctions trigonométriques : <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>acos</code>, <code>asin</code>, <code>atan</code>, <code>atan2</code>;</li>
<li>fonctions relatives aux signes : <code>abs</code>, <code>sign</code>;</li>
<li>fonctions d’arrondissement : <code>ceiling</code>, <code>floor</code>, <code>round</code>, <code>trunc</code>, <code>signif</code>;</li>
<li>fonctions reliées aux fonctions mathématiques bêta et gamma: <code>beta</code>, <code>gamma</code>, <code>factorial</code>, <code>choose</code>, etc.</li>
</ul>
<p>Ces fonctions font un calcul pour tous les éléments de l’objet fourni en entrée et retournent un résultat de même dimension que l’objet en entrée. Voici quelques exemples.</p>
<pre class="r"><code>x &lt;- -5:4
x</code></pre>
<pre><code>##  [1] -5 -4 -3 -2 -1  0  1  2  3  4</code></pre>
<pre class="r"><code>exp(x)</code></pre>
<pre><code>##  [1]  0.006737947  0.018315639  0.049787068  0.135335283  0.367879441
##  [6]  1.000000000  2.718281828  7.389056099 20.085536923 54.598150033</code></pre>
<pre class="r"><code>xMat &lt;- matrix(x, nrow = 2)
xMat</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]   -5   -3   -1    1    3
## [2,]   -4   -2    0    2    4</code></pre>
<pre class="r"><code>sign(xMat)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]   -1   -1   -1    1    1
## [2,]   -1   -1    0    1    1</code></pre>
</div>
<div id="fonctions-mathematiques-combinant-des-elements" class="section level2">
<h2>Fonctions mathématiques combinant des éléments</h2>
<p>Certaines fonctions mathématiques en R effectuent des calculs faisant intervenir plus d’un élément de l’objet donné en entrée, plutôt que d’effectuer un calcul distinct pour chacun des éléments. C’est le cas des fonctions suivantes :</p>
<ul>
<li>somme ou produit de tous les éléments (retourne une seule valeur) : <code>sum</code>, <code>prod</code>;</li>
<li>somme ou produit cumulatif des éléments (retourne un vecteur de même longueur que le vecteur en entrée) : <code>cummsum</code>, <code>cumprod</code>;</li>
<li>différences entre des éléments : <code>diff</code>.</li>
</ul>
<p>Voici quelques exemples.</p>
<pre class="r"><code>mat &lt;- matrix(c(2,5,3,4,6,5,4,3,1,2,9,8), nrow = 3, ncol = 4)
mat</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    2    4    4    2
## [2,]    5    6    3    9
## [3,]    3    5    1    8</code></pre>
<pre class="r"><code>prod(mat)</code></pre>
<pre><code>## [1] 6220800</code></pre>
<pre class="r"><code>cumsum(mat)</code></pre>
<pre><code>##  [1]  2  7 10 14 20 25 29 32 33 35 44 52</code></pre>
<div id="fonction-diff" class="section level4">
<h4>Fonction <code>diff</code></h4>
<p>Pour une matrice, <code>diff</code> calcule les différences terme à terme des éléments composant les lignes. Par défaut, il compare une ligne à la ligne en dessous.</p>

<pre class="r"><code>diff(mat)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    3    2   -1    7
## [2,]   -2   -1   -2   -1</code></pre>
<p>La commande suivante retourne donc le même résultat que la précédente.</p>
<pre class="r"><code>mat[-1, ] - mat[-nrow(mat), ]</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    3    2   -1    7
## [2,]   -2   -1   -2   -1</code></pre>
<p>Pour un vecteur, la fonction <code>diff</code> retourne les différences entre un terme et le terme précédent.</p>
<pre class="r"><code>diff(c(2,5,3,4))</code></pre>
<pre><code>## [1]  3 -2  1</code></pre>
<p>La fonction <code>diff</code> peut calculer des différences entre des termes séparés par plus d’une position grâce à l’argument <code>lag</code>.</p>
<pre class="r"><code>diff(c(2,5,3,4), lag = 2)</code></pre>
<pre><code>## [1]  1 -1</code></pre>
</div>
</div>
<div id="fonctions-doperations-sur-des-ensembles" class="section level2">
<h2>Fonctions d’opérations sur des ensembles</h2>
<p>Les fonctions R d’opération sur des ensembles sont les suivantes :</p>
<ul>
<li><code>union</code> : union,</li>
<li><code>intersect</code> : intersection,</li>
<li><code>setdiff</code> : différence,</li>
<li><code>setequal</code> : test d’égalité,</li>
<li><code>is.element</code> : test d’inclusion.</li>
</ul>
<p>Voici quelques exemples utilisant les deux ensembles suivants</p>
<pre class="r"><code>x &lt;- c(&quot;M&quot;, &quot;S&quot;, &quot;A&quot;, &quot;F&quot;, &quot;M&quot;)
y &lt;- c(&quot;M&quot;, &quot;A&quot;, &quot;H&quot;, &quot;B&quot;)</code></pre>
<p>Union de tous les éléments des ensembles <code>x</code> et <code>y</code>, en retirant les doublons :</p>
<pre class="r"><code>union(x, y)</code></pre>
<pre><code>## [1] &quot;M&quot; &quot;S&quot; &quot;A&quot; &quot;F&quot; &quot;H&quot; &quot;B&quot;</code></pre>
<p>Identification des éléments communs dans <code>x</code> et <code>y</code>, en retirant les doublons :</p>
<pre class="r"><code>intersect(x, y)</code></pre>
<pre><code>## [1] &quot;M&quot; &quot;A&quot;</code></pre>
<p>Identification des éléments de <code>x</code> ne se retrouvant pas dans <code>y</code>, en retirant les doublons :</p>
<pre class="r"><code>setdiff(x, y)</code></pre>
<pre><code>## [1] &quot;S&quot; &quot;F&quot;</code></pre>

<p>Test sur l’égalité entre les ensembles <code>x</code> et <code>y</code> :</p>
<pre class="r"><code>setequal(x,y)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>Test sur la présence de <code>&quot;A&quot;</code> et <code>&quot;B&quot;</code> dans l’ensemble <code>x</code> :</p>
<pre class="r"><code>is.element(el = c(&quot;A&quot;, &quot;B&quot;), set = x)</code></pre>
<pre><code>## [1]  TRUE FALSE</code></pre>
</div>
<div id="mots-cles-mathematiques" class="section level2">
<h2>Mots-clés mathématiques</h2>
<p>Le nombre <span class="math inline">\(\pi\)</span> est représenté en R par le mot-clé <code>pi</code>.</p>
<pre class="r"><code>pi</code></pre>
<pre><code>## [1] 3.141593</code></pre>
<p><code>Inf</code> est le symbole en R pour l’infini <span class="math inline">\(\infty\)</span>.</p>
<pre class="r"><code>-5/0</code></pre>
<pre><code>## [1] -Inf</code></pre>
<p><code>NaN</code> est un mot-clé signifiant <em>Not A Number</em>. Ce mot-clé est retourné par R lorsqu’un utilisateur lui demande d’effectuer une opération mathématique impossible.</p>
<pre class="r"><code>log(-1)</code></pre>
<pre><code>## Warning in log(-1): NaNs produced</code></pre>
<pre><code>## [1] NaN</code></pre>
<p><strong>Rappel</strong> : Attention de ne pas confondre le mot-clé <code>NaN</code> avec le mot-clé <code>NA</code> qui signifie plutôt <em>Not Available</em> et qui sert à représenter les données manquantes.</p>
<hr />
</div>
</div>
<div id="fonctions-pour-le-calcul-de-statistiques-descriptives" class="section level1">
<h1>Fonctions pour le calcul de statistiques descriptives</h1>
<div id="fonctions-retournant-une-seule-statistique" class="section level2">
<h2>Fonctions retournant une seule statistique</h2>
<p>Certaines fonctions de calcul de statistiques descriptives prennent en entrée un objet atomique (vecteur, matrice ou array) contenant uniquement des éléments numériques et retournent en sortie une seule valeur, soit une statistique.</p>
<ul>
<li>minimum et maximum : <code>min</code>, <code>max</code>;</li>
<li>mesures de tendance centrale : <code>mean</code>, <code>median</code>;</li>
<li>mesures de variabilité : <code>sd</code> (écart-type).</li>
</ul>
<p>Utilisons le jeu de données <code>cars</code> du package <code>datasets</code> pour faire quelques exemples.</p>
<pre class="r"><code>str(cars)</code></pre>
<pre><code>## &#39;data.frame&#39;:    50 obs. of  2 variables:
##  $ speed: num  4 4 7 7 8 9 10 10 10 11 ...
##  $ dist : num  2 10 4 22 16 10 18 26 34 17 ...</code></pre>
<pre class="r"><code>mean(cars$speed)</code></pre>
<pre><code>## [1] 15.4</code></pre>
<p>Si l’objet en entrée a plus d’une dimension, la sortie est tout de même de longueur 1. Donc tous les éléments contenus dans l’objet sont mis en commun pour faire le calcul.</p>
<pre class="r"><code>sd(as.matrix(cars))</code></pre>
<pre><code>## [1] 23.12142</code></pre>
<div id="fonctions-which.max-et-which.min" class="section level4">
<h4>Fonctions <code>which.max</code> et <code>which.min</code></h4>
<p>Les fonctions <code>min</code> et <code>max</code> retournent respectivement la valeur la plus petite et la valeur la plus grande parmi les éléments d’un objet.</p>
<pre class="r"><code>max(cars$dist)</code></pre>
<pre><code>## [1] 120</code></pre>
<p>Les fonctions <code>which.max</code> et <code>which.min</code> retournent pour leur part la position dans l’objet du maximum ou du minimum.</p>
<pre class="r"><code>which.max(cars$dist)</code></pre>
<pre><code>## [1] 49</code></pre>
<p>Ainsi, nous pourrions par exemple afficher la ligne de <code>cars</code> contenant la plus grande observation pour la variable <code>dist</code> comme suit.</p>
<pre class="r"><code>cars[which.max(cars$dist), ]</code></pre>
<pre><code>##    speed dist
## 49    24  120</code></pre>
</div>
<div id="traitement-des-observations-manquantes-et-argument-na.rm" class="section level3">
<h3>Traitement des observations manquantes et argument <code>na.rm</code></h3>
<p>Les fonctions <code>min</code>, <code>max</code>, <code>mean</code>, <code>median</code> et <code>sd</code>, ainsi que quelques autres fonctions vues dans ces notes, ont un argument en commun nommé <code>na.rm</code>. Cet argument spécifie le comportement de la fonction en présence de données manquantes (<code>NA</code>). Par défaut, <code>na.rm</code> prend la valeur <code>FALSE</code> pour ces fonctions. Cette valeur signifie que les données manquantes ne doivent pas être retirées avant d’effectuer le calcul. Cependant, en présence de données manquantes, ces fonctions ne sont pas en mesure de calculer des statistiques. Par exemple, supposons que nous voulions calculer la médiane des données dans le vecteur suivant.</p>
<pre class="r"><code>x &lt;- c(3, 6, NA, 8, 11, 15, 23)</code></pre>
<p>Si nous ne retirons pas la donnée manquante, nous obtenons le résultat suivant.</p>
<pre class="r"><code>median(x)</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Ce résultat s’explique par le fait que la valeur de la médiane dépend de toutes les observations, incluant l’observation manquante, qui est inconnue. La valeur de la médiane est donc elle aussi inconnue.</p>
<p>Pour calculer plutôt la médiane des observations non manquantes, il faut donner la valeur <code>TRUE</code> à l’argument <code>na.rm</code> comme suit.</p>
<pre class="r"><code>median(x, na.rm = TRUE)</code></pre>
<pre><code>## [1] 9.5</code></pre>
<p>Notons que la fonction <code>na.omit</code> permet de retirer les observations manquantes d’un objet R. Si l’objet est un vecteur, les éléments contenant <code>NA</code> sont retirés.</p>

<pre class="r"><code>na.omit(x)</code></pre>
<pre><code>## [1]  3  6  8 11 15 23
## attr(,&quot;na.action&quot;)
## [1] 3
## attr(,&quot;class&quot;)
## [1] &quot;omit&quot;</code></pre>
<p>La fonction <code>na.omit</code> ajoute un attribut à l’objet pour identifier les observations retirées.</p>
<p>Remarquons que les deux commandes suivantes retournent le même résultat.</p>
<pre class="r"><code>median(x, na.rm = TRUE)</code></pre>
<pre><code>## [1] 9.5</code></pre>
<pre class="r"><code>median(na.omit(x))</code></pre>
<pre><code>## [1] 9.5</code></pre>
<p>Si la fonction <code>na.omit</code> reçoit en entrée une matrice ou un data frame, elle retire toutes les lignes contenant au moins un <code>NA</code>.</p>
<pre class="r"><code>exJeu &lt;- data.frame(x, y = c(2, NA, 8, 9, 6, NA, 2))
exJeu</code></pre>
<pre><code>##    x  y
## 1  3  2
## 2  6 NA
## 3 NA  8
## 4  8  9
## 5 11  6
## 6 15 NA
## 7 23  2</code></pre>
<pre class="r"><code>na.omit(exJeu)</code></pre>
<pre><code>##    x y
## 1  3 2
## 4  8 9
## 5 11 6
## 7 23 2</code></pre>
</div>
</div>
<div id="fonctions-pouvant-retourner-plusieurs-statistiques" class="section level2">
<h2>Fonctions pouvant retourner plusieurs statistiques</h2>
<p>D’autres fonctions peuvent retourner plus d’une statistique.</p>
<ul>
<li>mesures de localisation : <code>range</code>, <code>quantile</code>;</li>
<li>résumé comprenant plusieurs mesures : <code>summary</code>;</li>
<li>variance, covariance et corrélations : <code>var</code>, <code>cov</code>, <code>cor</code>.</li>
</ul>
<div id="fonctions-range-et-quantile" class="section level4">
<h4>Fonctions <code>range</code> et <code>quantile</code></h4>
<p>La fonction <code>range</code> retourne à la fois le minimum est le maximum.</p>
<pre class="r"><code>range(cars$speed)</code></pre>
<pre><code>## [1]  4 25</code></pre>
<p>La fonction <code>quantile</code> calcule des quantiles empiriques. Par défaut, elle retourne le minimum, le maximum et les quartiles.</p>
<pre class="r"><code>quantile(cars$speed)</code></pre>
<pre><code>##   0%  25%  50%  75% 100% 
##    4   12   15   19   25</code></pre>
<p>L’argument <code>probs</code> permet de demander n’importe quels quantiles.</p>
<pre class="r"><code>quantile(cars$speed, probs = c(0.1,0.9))</code></pre>
<pre><code>##  10%  90% 
##  8.9 23.1</code></pre>
<p><strong>Remarque</strong> : Il existe plusieurs façons de calculer des quantiles. La fonction <code>quantile</code> implémente 9 algorithmes de calcul de quantiles (voir <a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/quantile.html"><code>help(quantile)</code></a>).</p>
</div>
<div id="fonction-summary" class="section level4">
<h4>Fonction <code>summary</code></h4>
<p>La fonction <code>summary</code> retourne les statistiques suivantes selon l’entrée qu’elle reçoit :</p>
<ul>
<li>vecteur numérique : minimum, premier quartile, médiane, moyenne, troisième quartile, maximum;</li>
<li>facteur : fréquences des modalités (comme la fonction <code>table</code> vue plus loin);</li>
<li>matrice ou data frame : la fonction <code>summary</code> est appliquée séparément à chacune des colonnes.</li>
</ul>
<p>Voici quelques exemples.</p>
<p>Vecteur numérique en entrée :</p>
<pre class="r"><code>summary(cars$speed)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##     4.0    12.0    15.0    15.4    19.0    25.0</code></pre>
<p>Facteur en entrée :</p>
<pre class="r"><code>summary(Puromycin$state)</code></pre>
<pre><code>##   treated untreated 
##        12        11</code></pre>
<p>Data frame en entrée :</p>
<pre class="r"><code>summary(cars)</code></pre>
<pre><code>##      speed           dist       
##  Min.   : 4.0   Min.   :  2.00  
##  1st Qu.:12.0   1st Qu.: 26.00  
##  Median :15.0   Median : 36.00  
##  Mean   :15.4   Mean   : 42.98  
##  3rd Qu.:19.0   3rd Qu.: 56.00  
##  Max.   :25.0   Max.   :120.00</code></pre>
</div>
<div id="fonctions-var-cov-et-cor" class="section level4">
<h4>Fonctions <code>var</code>, <code>cov</code> et <code>cor</code></h4>
<p>La fonction <code>var</code> peut prendre en entrée un vecteur ou un objet à deux dimensions. Si elle reçoit en entrée un vecteur, elle calcule la variance empirique de toutes les valeurs.</p>
<pre class="r"><code>var(cars$speed)</code></pre>
<pre><code>## [1] 27.95918</code></pre>
<p>Cependant, si elle reçoit en entrée une matrice ou un data frame de valeurs numériques, elle considère que chaque colonne contient les observations d’une variable aléatoire. Elle va calculer une matrice de variance-covariance.</p>
<pre class="r"><code>var(cars)</code></pre>
<pre><code>##           speed     dist
## speed  27.95918 109.9469
## dist  109.94694 664.0608</code></pre>
<p>La fonction <code>cov</code> fait exactement le même calcul par défaut.</p>
<pre class="r"><code>cov(cars)</code></pre>
<pre><code>##           speed     dist
## speed  27.95918 109.9469
## dist  109.94694 664.0608</code></pre>
<p>Elle peut cependant calculer des covariances de Kendall ou de Spearman (toutes deux des statistiques non paramétriques basées sur les rangs des observations) au lieu de la covariance classique de Pearson. La fonction <code>cor</code> calcule des corrélations plutôt que des covariances.</p>
<pre class="r"><code>cor(cars, method = &quot;spearman&quot;)</code></pre>
<pre><code>##           speed      dist
## speed 1.0000000 0.8303568
## dist  0.8303568 1.0000000</code></pre>
</div>
</div>
<div id="fonctions-retournant-un-vecteur-de-statistiques" class="section level2">
<h2>Fonctions retournant un vecteur de statistiques</h2>
<p>Certaines fonctions retournent autant de statistiques qu’il y a d’éléments dans l’objet donné en entrée.</p>
<ul>
<li>minimum et maximum : <code>cummin</code>, <code>cummax</code>, <code>pmin</code>, <code>pmax</code>;</li>
<li>rangs : <code>rank</code>.</li>
</ul>
<div id="fonctions-cummin-et-cummax" class="section level4">
<h4>Fonctions <code>cummin</code> et <code>cummax</code></h4>
<p>Les fonctions <code>cummin</code> et <code>cummax</code> calculent le minimum et le maximum cumulatif.</p>
<pre class="r"><code>x &lt;- c(-2, 4, -3, 4, 7, -6, 0)</code></pre>
<pre class="r"><code>cummin(x)</code></pre>
<pre><code>## [1] -2 -2 -3 -3 -3 -6 -6</code></pre>
<p>La valeur en position <code>i</code> est la valeur minimale dans le sous-vecteur <code>x[1:i]</code>.</p>
</div>
<div id="fonctions-pmin-et-pmax" class="section level4">
<h4>Fonctions <code>pmin</code> et <code>pmax</code></h4>
<p>Les fonctions <code>pmin</code> et <code>pmax</code> calculent le minimum et le maximum élément par élément, entre des vecteurs.</p>
<pre class="r"><code>pmax(x, 1:7)</code></pre>
<pre><code>## [1] 1 4 3 4 7 6 7</code></pre>
<p>Elle est utile pour tronquer des valeurs. Par exemple, l’instruction suivante permet de tronquer à zéro les valeurs dans le vecteur <code>x</code>.</p>
<pre class="r"><code>pmax(x, 0)</code></pre>
<pre><code>## [1] 0 4 0 4 7 0 0</code></pre>
</div>
<div id="fonction-rank" class="section level4">
<h4>Fonction <code>rank</code></h4>
<p>Certains tests statistiques non paramétriques utilisent des statistiques basées sur les rangs des observations. Voici comment obtenir ces rangs :</p>
<pre class="r"><code>rank(x)</code></pre>
<pre><code>## [1] 3.0 5.5 2.0 5.5 7.0 1.0 4.0</code></pre>
<p>Par défaut, en cas d’égalité, le rang moyen est utilisé. Pour changer cette option, il faut modifier la valeur de l’argument <code>ties.method</code>.</p>
<pre class="r"><code>rank(x, ties.method = &quot;min&quot;)</code></pre>
<pre><code>## [1] 3 5 2 5 7 1 4</code></pre>
</div>
</div>
<div id="fonctions-de-calcul-de-frequences" class="section level2">
<h2>Fonctions de calcul de fréquences</h2>
<p>Les fonctions <code>table</code>, <code>xtabs</code> et <code>ftable</code> permettent de calculer des fréquences.</p>
<p>Voici un petit jeu de données pour illustrer l’utilisation de ces fonctions. Il contient des observations concernant 7 individus fictifs : leur sexe, la couleur de leurs yeux et la couleur de leurs cheveux.</p>
<pre class="r"><code>sondage &lt;- data.frame(yeux = c(&quot;brun&quot;, &quot;brun&quot;, &quot;bleu&quot;, &quot;brun&quot;, &quot;vert&quot;, &quot;brun&quot;, &quot;bleu&quot;),
                      cheveux = c(&quot;brun&quot;, &quot;noir&quot;, &quot;blond&quot;, &quot;brun&quot;, &quot;brun&quot;, &quot;blond&quot;, &quot;brun&quot;),
                      sexe = c(&quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;))
sondage</code></pre>
<pre><code>##   yeux cheveux sexe
## 1 brun    brun    F
## 2 brun    noir    M
## 3 bleu   blond    F
## 4 brun    brun    F
## 5 vert    brun    M
## 6 brun   blond    F
## 7 bleu    brun    M</code></pre>
<div id="fonctions-table" class="section level4">
<h4>Fonctions <code>table</code></h4>
<p>La fonction <code>table</code> permet de compter le nombre d’occurrences de chacune des modalités d’une variable catégorique dans des observations.</p>
<pre class="r"><code>table(sondage$yeux)</code></pre>
<pre><code>## 
## bleu brun vert 
##    2    4    1</code></pre>
<p>Elle produit un tableau de fréquences à une variable si elle reçoit les observations d’une seule variable. Elle peut aussi produire des tableaux de fréquences croisées à deux variables ou plus.</p>
<pre class="r"><code>table(sondage$yeux, sondage$cheveux)</code></pre>
<pre><code>##       
##        blond brun noir
##   bleu     1    1    0
##   brun     1    2    1
##   vert     0    1    0</code></pre>

<pre class="r"><code>table(sondage)</code></pre>
<pre><code>## , , sexe = F
## 
##       cheveux
## yeux   blond brun noir
##   bleu     1    0    0
##   brun     1    2    0
##   vert     0    0    0
## 
## , , sexe = M
## 
##       cheveux
## yeux   blond brun noir
##   bleu     0    1    0
##   brun     0    0    1
##   vert     0    1    0</code></pre>
</div>
<div id="fonctions-xtabs" class="section level4">
<h4>Fonctions <code>xtabs</code></h4>
<p>La fonction <code>xtabs</code> fait le même calcul, mais prend en entrée une formule.</p>
<pre class="r"><code>xtabs(~ yeux + cheveux, data = sondage)</code></pre>
<pre><code>##       cheveux
## yeux   blond brun noir
##   bleu     1    1    0
##   brun     1    2    1
##   vert     0    1    0</code></pre>
</div>
<div id="fonctions-ftable" class="section level4">
<h4>Fonctions <code>ftable</code></h4>
<p>Finalement, la fonction <code>ftable</code> retourne le résultat sous la forme d’une table « plate » (en anglais <em>flat</em>, d’où le <code>f</code> dans le nom de la fonction) plutôt que d’un array dans le cas d’un croisement de 3 variables ou plus.</p>
<pre class="r"><code>ftable(sondage)</code></pre>
<pre><code>##              sexe F M
## yeux cheveux         
## bleu blond        1 0
##      brun         0 1
##      noir         0 0
## brun blond        1 0
##      brun         2 0
##      noir         0 1
## vert blond        0 0
##      brun         0 1
##      noir         0 0</code></pre>
</div>
<div id="autres-fonctions-relatives-au-calcul-de-frequences" class="section level4">
<h4>Autres fonctions relatives au calcul de fréquences</h4>
<p>Les fonctions <code>margin.table</code>, <code>addmargins</code> et <code>prop.table</code> permettent de calculer des fréquences marginales ou relatives à partir d’un tableau de fréquences.</p>

<p>Voici quelques exemples avec le tableau de fréquences suivant.</p>
<pre class="r"><code>freq &lt;- table(sondage$yeux, sondage$cheveux)
freq</code></pre>
<pre><code>##       
##        blond brun noir
##   bleu     1    1    0
##   brun     1    2    1
##   vert     0    1    0</code></pre>
<p>Fréquences marginales en colonnes :</p>
<pre class="r"><code>margin.table(freq, margin = 2)</code></pre>
<pre><code>## 
## blond  brun  noir 
##     2     4     1</code></pre>
<p>Fréquences marginales ajoutées au tableau :</p>
<pre class="r"><code>addmargins(freq)</code></pre>
<pre><code>##       
##        blond brun noir Sum
##   bleu     1    1    0   2
##   brun     1    2    1   4
##   vert     0    1    0   1
##   Sum      2    4    1   7</code></pre>
<p>Fréquences relatives :</p>
<pre class="r"><code>prop.table(freq)</code></pre>
<pre><code>##       
##            blond      brun      noir
##   bleu 0.1428571 0.1428571 0.0000000
##   brun 0.1428571 0.2857143 0.1428571
##   vert 0.0000000 0.1428571 0.0000000</code></pre>
</div>
<div id="transformation-du-format-dun-objet-de-classe-table" class="section level4">
<h4>Transformation du format d’un objet de classe <code>&quot;table&quot;</code></h4>
<p>Les fonctions <code>table</code> et <code>xtabs</code> attribuent à l’objet qu’ils retournent en sortie la classe <code>&quot;table&quot;</code>.</p>
<pre class="r"><code>attributes(freq)</code></pre>
<pre><code>## $dim
## [1] 3 3
## 
## $dimnames
## $dimnames[[1]]
## [1] &quot;bleu&quot; &quot;brun&quot; &quot;vert&quot;
## 
## $dimnames[[2]]
## [1] &quot;blond&quot; &quot;brun&quot;  &quot;noir&quot; 
## 
## 
## $class
## [1] &quot;table&quot;</code></pre>
<pre class="r"><code>str(freq)</code></pre>
<pre><code>##  &#39;table&#39; int [1:3, 1:3] 1 1 0 1 2 1 0 1 0
##  - attr(*, &quot;dimnames&quot;)=List of 2
##   ..$ : chr [1:3] &quot;bleu&quot; &quot;brun&quot; &quot;vert&quot;
##   ..$ : chr [1:3] &quot;blond&quot; &quot;brun&quot; &quot;noir&quot;</code></pre>
<p>Il est parfois utile de transformer un objet de classe <code>&quot;table&quot;</code> en un array (matrice si la table croise deux variables) ou un data frame. Pour la transformation en array, il suffit de retirer l’attribut <code>class</code> avec la fonction <code>unclass</code>.</p>
<pre class="r"><code>unclass(freq)</code></pre>
<pre><code>##       
##        blond brun noir
##   bleu     1    1    0
##   brun     1    2    1
##   vert     0    1    0</code></pre>
<pre class="r"><code>str(unclass(freq))</code></pre>
<pre><code>##  int [1:3, 1:3] 1 1 0 1 2 1 0 1 0
##  - attr(*, &quot;dimnames&quot;)=List of 2
##   ..$ : chr [1:3] &quot;bleu&quot; &quot;brun&quot; &quot;vert&quot;
##   ..$ : chr [1:3] &quot;blond&quot; &quot;brun&quot; &quot;noir&quot;</code></pre>
<p>La transformation en data frame transforme la table en format « plat ».</p>
<pre class="r"><code>as.data.frame(freq)</code></pre>
<pre><code>##   Var1  Var2 Freq
## 1 bleu blond    1
## 2 brun blond    1
## 3 vert blond    0
## 4 bleu  brun    1
## 5 brun  brun    2
## 6 vert  brun    1
## 7 bleu  noir    0
## 8 brun  noir    1
## 9 vert  noir    0</code></pre>
<pre class="r"><code>str(as.data.frame(freq))</code></pre>
<pre><code>## &#39;data.frame&#39;:    9 obs. of  3 variables:
##  $ Var1: Factor w/ 3 levels &quot;bleu&quot;,&quot;brun&quot;,..: 1 2 3 1 2 3 1 2 3
##  $ Var2: Factor w/ 3 levels &quot;blond&quot;,&quot;brun&quot;,..: 1 1 1 2 2 2 3 3 3
##  $ Freq: int  1 1 0 1 2 1 0 1 0</code></pre>
</div>
</div>
<div id="fonctions-pour-le-traitement-des-observations-dupliquees" class="section level2">
<h2>Fonctions pour le traitement des observations dupliquées</h2>
<p>Il est parfois utile de gérer les observations dupliquées dans un jeu de données. En R, les fonctions suivantes sont utiles avec des observations dupliquées :</p>
<ul>
<li>pour tester la présence d’observations dupliquées : <code>duplicated</code>,</li>
<li>pour retirer les observations dupliquées : <code>unique</code>.</li>
</ul>
<p>Une observation est ici définie par l’ensemble des valeurs observées de toutes les variables pour un individu (ou une unité) de la population statistique à l’étude. Donc une observation dupliquée est une ligne répétée (donc deux lignes ou plus complètement identiques) dans une matrice ou un data frame. Dans le cas d’une seule variable, stockée dans un vecteur, une observation dupliquée est une valeur présente plus d’une fois dans le vecteur.</p>
<p>Pour illustrer l’emploi des fonctions <code>duplicated</code> et <code>unique</code>, réutilisons le jeu de données <code>sondage</code>. Ce jeu de données contient une observation dupliquée.</p>
<pre class="r"><code>sondage</code></pre>
<pre><code>##   yeux cheveux sexe
## 1 brun    brun    F
## 2 brun    noir    M
## 3 bleu   blond    F
## 4 brun    brun    F
## 5 vert    brun    M
## 6 brun   blond    F
## 7 bleu    brun    M</code></pre>
<p>En effet, les lignes 1 et 4 sont identiques. La fonction <code>duplicated</code> identifie la 4e observation comme une duplication d’une autre observation.</p>
<pre class="r"><code>duplicated(sondage)</code></pre>
<pre><code>## [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE</code></pre>
<p>L’observation peut être retirée avec la fonction <code>unique</code> comme suit.</p>
<pre class="r"><code>unique(sondage)</code></pre>
<pre><code>##   yeux cheveux sexe
## 1 brun    brun    F
## 2 brun    noir    M
## 3 bleu   blond    F
## 5 vert    brun    M
## 6 brun   blond    F
## 7 bleu    brun    M</code></pre>
<p>Si elles reçoivent un vecteur en entrée, les fonctions <code>duplicated</code> et <code>unique</code> réagissent comme suit.</p>
<pre class="r"><code>duplicated(c(1, 3, 2, 1, 2, 1))</code></pre>
<pre><code>## [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>unique(c(1, 3, 2, 1, 2, 1))</code></pre>
<pre><code>## [1] 1 3 2</code></pre>
<hr />
</div>
</div>
<div id="fonctions-de-la-famille-des-apply" class="section level1">
<h1>Fonctions de la famille des <code>apply</code></h1>
<p>R propose plusieurs fonctions, dites « de la famille des <code>apply</code> », qui ont pour but d’appliquer itérativement une autre fonction sur des sous-sections d’un objet. Les grandes étapes de traitement de ces fonctions sont les suivantes :</p>
<ul>
<li>séparer un objet en sous-objets;</li>
<li>répéter la même action pour tous les sous-objets : appeler une fonction en lui donnant comme premier argument le sous-objet;</li>
<li>combiner les résultats obtenus.</li>
</ul>
<p>Ces fonctions cachent en fait une boucle, mais avec une syntaxe allégée.</p>
<p>Les fonctions de la famille des <code>apply</code> sont utiles pour :</p>
<ul>
<li>les calculs sur les marges d’une matrice ou d’un array,</li>
<li>appliquer le même traitement à tous les éléments d’une liste,</li>
<li>le calcul de statistiques descriptives selon les niveaux de facteurs,</li>
<li>les calculs en parallèle (nous y reviendrons plus tard),</li>
<li>etc.</li>
</ul>
<p>Nous verrons ici les fonctions : <code>apply</code>, <code>lapply</code>, <code>sapply</code>, <code>mapply</code>, <code>tapply</code>, <code>by</code> et <code>aggregate</code>.</p>
<div id="fonction-apply" class="section level2">
<h2>Fonction <code>apply</code></h2>
<p>La fonction <code>apply</code> applique une fonction sur toutes les lignes ou toutes les colonnes d’un array (souvent une matrice).</p>
<p>Voici un exemple.</p>
<pre class="r"><code>mat &lt;- matrix(1:12, nrow = 3, ncol = 4, byrow = TRUE)
mat[2,3] &lt;- NA
mat</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    5    6   NA    8
## [3,]    9   10   11   12</code></pre>
<p>Calcul sur chaque ligne :</p>
<pre class="r"><code>apply(mat, MARGIN = 1, FUN = mean)</code></pre>
<pre><code>## [1]  2.5   NA 10.5</code></pre>
<p>Calcul sur chaque colonne :</p>
<pre class="r"><code>apply(mat, MARGIN = 2, FUN = mean)</code></pre>
<pre><code>## [1]  5  6 NA  8</code></pre>
<p>Pour ajouter un argument à envoyer à la fonction <code>FUN</code>, il suffit de l’ajouter à la liste des arguments fournis, préférablement en le nommant. C’est l’argument <code>...</code> qui permet ce transfert d’arguments entre une fonction principale et une fonction présente dans le corps de la fonction principale.</p>
<pre class="r"><code>apply(mat, 2, mean, na.rm = TRUE)</code></pre>
<pre><code>## [1] 5 6 7 8</code></pre>
<p>La fonction retourne une liste si <code>FUN</code> retourne plus d’une valeur.</p>
<pre class="r"><code>apply(mat, 1, summary)</code></pre>
<pre><code>## [[1]]
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    1.00    1.75    2.50    2.50    3.25    4.00 
## 
## [[2]]
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA&#39;s 
##   5.000   5.500   6.000   6.333   7.000   8.000       1 
## 
## [[3]]
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    9.00    9.75   10.50   10.50   11.25   12.00</code></pre>
<p>Elle peut aussi prendre en entrée un array à plus de deux dimensions.</p>
<pre class="r"><code>arr &lt;- array(1:12, dim = c(2, 3, 2))
arr</code></pre>
<pre><code>## , , 1
## 
##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6
## 
## , , 2
## 
##      [,1] [,2] [,3]
## [1,]    7    9   11
## [2,]    8   10   12</code></pre>
<pre class="r"><code>apply(arr, MARGIN = c(1, 2), FUN = sum)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    8   12   16
## [2,]   10   14   18</code></pre>
<p>Si elle reçoit en entrée un data frame, elle le transformera en matrice avant d’effectuer les calculs.</p>
<div id="fonctions-raccourcies-rowsums-colsums-rowmeans-et-colmeans" class="section level3">
<h3>Fonctions raccourcies : <code>rowSums</code>, <code>colSums</code>, <code>rowMeans</code> et <code>colMeans</code></h3>
<p>Pour le calcul de sommes et de moyennes, il existe des fonctions raccourcies un peu plus rapides qu’un appel à la fonction <code>apply</code> : <code>rowSums</code>, <code>colSums</code>, <code>rowMeans</code>, <code>colMeans</code>. Par exemple :</p>
<pre class="r"><code>rowMeans(mat, na.rm = TRUE)</code></pre>
<pre><code>## [1]  2.500000  6.333333 10.500000</code></pre>
<p>est équivalent à <code>apply(mat, 1, mean, na.rm = TRUE)</code> et</p>
<pre class="r"><code>colSums(mat, na.rm = TRUE)</code></pre>
<pre><code>## [1] 15 18 14 24</code></pre>
<p>est équivalent à <code>apply(mat, 2, sum, na.rm = TRUE)</code>.</p>
<p>Ces fonctions spécialisées ont été optimisées en termes de temps d’exécution.</p>
</div>
</div>
<div id="fonctions-lapply-sapply-et-mapply" class="section level2">
<h2>Fonctions <code>lapply</code>, <code>sapply</code> et <code>mapply</code></h2>
<p>Les fonctions <code>lapply</code>, <code>sapply</code> et <code>mapply</code> prennent en entrée un vecteur ou une liste (qui peut aussi être un data frame). Elles appliquent une fonction sur chaque élément du vecteur ou de la liste (ou chaque colonne du data frame).</p>
<p>Voici une liste qui sera utilisée pour illustrer l’emploi de ces fonctions. Cette liste contient les mots formant trois courtes phrases (ponctuation omise).</p>
<pre class="r"><code>phrases &lt;- list(
  phrase1 = c(&quot;regarde&quot;, &quot;la&quot;, &quot;belle&quot;, &quot;neige&quot;),
  phrase2 = c(&quot;allons&quot;, &quot;skier&quot;),
  phrase3 = c(&quot;non&quot;, &quot;il&quot;, &quot;fait&quot;, &quot;trop&quot;, &quot;froid&quot;)
)</code></pre>
<div id="fonction-sapply" class="section level4">
<h4>Fonction <code>sapply</code> :</h4>
<p>Supposons que nous voulons isoler le dernier mot de chaque phrase dans la liste <code>phrases</code>. L’action que nous souhaitons réaliser revient à extraire le dernier élément d’un vecteur. Elle doit être réalisée pour tous les vecteurs qui sont des éléments de la liste <code>phrases</code>.</p>
<p>Nous pourrions réaliser cette tâche avec la commande suivante.</p>
<pre class="r"><code>dernier_mot &lt;- sapply(phrases, FUN = tail, n = 1)
dernier_mot</code></pre>
<pre><code>## phrase1 phrase2 phrase3 
## &quot;neige&quot; &quot;skier&quot; &quot;froid&quot;</code></pre>
<p>Décortiquons maintenant cette commande. L’instruction <code>sapply(phrases, FUN = tail, n = 1)</code> permet d’appliquer la fonction <code>tail</code> à chaque élément de la liste <code>phrases</code>, qui sont tous des vecteurs. L’argument <code>n = 1</code> est passé à la fonction <code>tail</code>. Ainsi, seul le dernier élément de chaque vecteur est extrait. C’est comme si nous avions soumis la commande</p>
<pre class="r"><code>tail(phrases[[1]], n = 1)</code></pre>
<pre><code>## [1] &quot;neige&quot;</code></pre>
<p>séparément pour tous les éléments (fait pour l’élément 1 seulement dans la commande ci-dessus), puis que nous avions rassemblé les résultats.</p>
</div>
<div id="utilisation-dun-operateur-comme-valeur-de-largument-fun" class="section level4">
<h4>Utilisation d’un opérateur comme valeur de l’argument <code>FUN</code> :</h4>
<p>Si nous cherchions plutôt à isoler le deuxième mot de chaque phrase dans la liste <code>phrases</code>, nous pourrions réaliser cette extraction avec la commande suivante.</p>
<pre class="r"><code>sapply(phrases, FUN = &#39;[&#39;, 2)</code></pre>
<pre><code>## phrase1 phrase2 phrase3 
##    &quot;la&quot; &quot;skier&quot;    &quot;il&quot;</code></pre>
<p>Dans cet exemple, la fonction à appliquer est en fait l’opérateur d’extraction du crochet simple. Rappelons que les opérateurs sont en fait des fonctions. Donc, pour un vecteur quelconque, disons</p>
<pre class="r"><code>x &lt;- phrases[[1]]</code></pre>
<p>les commandes suivantes sont équivalentes.</p>
<pre class="r"><code>x[2]</code></pre>
<pre><code>## [1] &quot;la&quot;</code></pre>
<pre class="r"><code>&#39;[&#39;(x, 2)</code></pre>
<pre><code>## [1] &quot;la&quot;</code></pre>
<p>Ainsi, l’objet duquel nous voulons extraire est le premier argument à fournir à l’opérateur <code>[</code>. L’identifiant de l’élément à extraire (ici un entier représentant une position) est le deuxième argument à fournir à l’opérateur <code>[</code>. Si l’objet avait plus d’une dimension, il suffirait d’ajouter des arguments.</p>
<p>Lorsque l’argument <code>FUN</code> d’une fonction de la famille des <code>apply</code> est un opérateur, il faut toujours l’encadrer de guillemets (simples ou doubles).</p>
</div>
<div id="fonction-lapply" class="section level4">
<h4>Fonction <code>lapply</code> :</h4>
<p>La fonction <code>lapply</code> fait exactement le même calcul que la fonction <code>sapply</code>, mais retourne le résultat sous la forme d’une liste plutôt que sous une forme simplifiée.</p>

<pre class="r"><code>reslapply &lt;- lapply(phrases, FUN = tail, n = 1)
reslapply</code></pre>
<pre><code>## $phrase1
## [1] &quot;neige&quot;
## 
## $phrase2
## [1] &quot;skier&quot;
## 
## $phrase3
## [1] &quot;froid&quot;</code></pre>
</div>
<div id="fonction-mapply" class="section level4">
<h4>Fonction <code>mapply</code> :</h4>
<p>Il aurait aussi été possible de solutionner le problème de l’extraction des derniers mots des phrases dans <code>phrases</code> en utilisant la fonction <code>mapply</code>. La différence entre cette fonction et les fonctions <code>sapply</code> et <code>lapply</code> est qu’elle peut fournir à la fonction <code>FUN</code> plusieurs (ou de multiples, d’où le <code>m</code> dans <code>mapply</code>) arguments qui sont des vecteurs ou des listes.</p>
<p>Par exemple, nous pourrions extraire les derniers mots en appliquant l’opérateur <code>[</code> à chaque élément de la liste <code>phrases</code>, mais en spécifiant comme argument pour l’opérateur d’extraction la position du dernier élément. Cette position diffère un peu d’un élément à l’autre. Elle est égale à la longueur de l’élément.</p>
<p>Nous pourrions donc, dans un premier temps, calculer la longueur de chaque élément de <code>phrases</code> comme suit :</p>
<pre class="r"><code>longueurs_phrases &lt;- sapply(phrases, length)
longueurs_phrases</code></pre>
<pre><code>## phrase1 phrase2 phrase3 
##       4       2       5</code></pre>
<p>Ayant en main un vecteur contenant les longueurs, le vecteur <code>longueurs_phrases</code>, nous pouvons utiliser <code>mapply</code> pour extraire les derniers éléments des vecteurs dans <code>phrases</code>. L’appel à la fonction <code>mapply</code> est le suivant :</p>
<pre class="r"><code>mapply(FUN = &quot;[&quot;, phrases, longueurs_phrases)</code></pre>
<pre><code>## phrase1 phrase2 phrase3 
## &quot;neige&quot; &quot;skier&quot; &quot;froid&quot;</code></pre>
<p>La boucle cachée derrière cet appel à la fonction <code>mapply</code> est la suivante : pour <code>i</code> allant de 1 à 3, soit le nombre total d’éléments dans la liste <code>phrases</code>, l’extraction suivante est effectuée.</p>
<pre class="r"><code>&quot;[&quot;(phrases[[i]], longueurs_phrases[[i]])</code></pre>
</div>
</div>
<div id="fonctions-tapply-by-et-aggregate" class="section level2">
<h2>Fonctions <code>tapply</code>, <code>by</code> et <code>aggregate</code></h2>
<p>Ces fonctions appliquent encore la même fonction à plusieurs sous-objets. Ce qui les distingue des autres fonctions de la famille des <code>apply</code> est la formation des sous-objets selon les niveaux de facteurs.</p>
<p>Nous allons utiliser le jeu de données <code>Puromycin</code> du data frame <code>datasets</code> pour illustrer l’utilisation de ces fonctions.</p>

<pre class="r"><code>str(Puromycin)</code></pre>
<pre><code>## &#39;data.frame&#39;:    23 obs. of  3 variables:
##  $ conc : num  0.02 0.02 0.06 0.06 0.11 0.11 0.22 0.22 0.56 0.56 ...
##  $ rate : num  76 47 97 107 123 139 159 152 191 201 ...
##  $ state: Factor w/ 2 levels &quot;treated&quot;,&quot;untreated&quot;: 1 1 1 1 1 1 1 1 1 1 ...
##  - attr(*, &quot;reference&quot;)= chr &quot;A1.3, p. 269&quot;</code></pre>
<div id="fonction-tapply" class="section level4">
<h4>Fonction <code>tapply</code> :</h4>
<p>Par exemple, nous pourrions calculer la moyenne de la variable <code>rate</code> selon les niveaux du facteur <code>state</code> comme suit.</p>
<pre class="r"><code>tapply(Puromycin$rate, INDEX = Puromycin$state, FUN = mean)</code></pre>
<pre><code>##   treated untreated 
##  141.5833  110.7273</code></pre>
<p>L’argument <code>INDEX</code> pourrait être une liste de plusieurs facteurs.</p>
<pre class="r"><code>tapply(Puromycin$rate, INDEX = Puromycin[, c(&quot;conc&quot;, &quot;state&quot;)], FUN = mean)</code></pre>
<pre><code>##       state
## conc   treated untreated
##   0.02    61.5      59.0
##   0.06   102.0      85.0
##   0.11   131.0     106.5
##   0.22   155.5     127.5
##   0.56   196.0     151.0
##   1.1    203.5     160.0</code></pre>
<p>Dans l’exemple ci-dessous, nous avons fourni à <code>INDEX</code> un data frame, mais rappelons-nous que les data frames sont des cas particulier de listes. De plus, un élément de ce data frame n’est pas un facteur. Il s’agit de la variable <code>conc</code>. Cela n’a pas posé problème parce que <code>lapply</code> est arrivé à transformer l’élément en facteur.</p>
</div>
<div id="fonction-by" class="section level4">
<h4>Fonction <code>by</code> :</h4>
<p>La fonction <code>by</code> prend comme objet en entrée un data frame et permet d’effectuer un calcul sur des sous-objets qui sont aussi des data frames. Par exemple, nous pourrions calculer la matrice de corrélations entre les observations des variables <code>conc</code> et <code>rate</code> selon les niveaux du facteur <code>state</code> comme suit.</p>
<pre class="r"><code>by(Puromycin[, c(&quot;conc&quot;, &quot;rate&quot;)], INDICES = Puromycin$state, FUN = cor)</code></pre>
<pre><code>## Puromycin$state: treated
##           conc      rate
## conc 1.0000000 0.8310362
## rate 0.8310362 1.0000000
## -------------------------------------------------------- 
## Puromycin$state: untreated
##           conc      rate
## conc 1.0000000 0.8207311
## rate 0.8207311 1.0000000</code></pre>
</div>
<div id="fonction-aggregate" class="section level4">
<h4>Fonction <code>aggregate</code> :</h4>
<p>Finalement, la fonction <code>aggregate</code> prend aussi en entrée un data frame, mais elle applique la fonction séparément pour chaque colonne du data frame.</p>
<pre class="r"><code>aggregate(Puromycin[, c(&quot;conc&quot;, &quot;rate&quot;)], by = list(Puromycin$state), FUN = mean)</code></pre>
<pre><code>##     Group.1      conc     rate
## 1   treated 0.3450000 141.5833
## 2 untreated 0.2763636 110.7273</code></pre>
<p>L’argument <code>by</code> doit obligatoirement être une liste. Nommer les éléments de la liste modifie le nom des colonnes dans la sortie.</p>
<pre class="r"><code>aggregate(Puromycin[, c(&quot;conc&quot;, &quot;rate&quot;)], by = list(state = Puromycin$state), FUN = mean)</code></pre>
<pre><code>##       state      conc     rate
## 1   treated 0.3450000 141.5833
## 2 untreated 0.2763636 110.7273</code></pre>
<p>La fonction <code>aggregate</code> accepte aussi des formules en entrée, comme dans les exemples ci-dessous.</p>
<pre class="r"><code>aggregate(cbind(conc, rate) ~ state, data = Puromycin, FUN = mean)</code></pre>
<pre><code>##       state      conc     rate
## 1   treated 0.3450000 141.5833
## 2 untreated 0.2763636 110.7273</code></pre>
<pre class="r"><code>aggregate(rate ~ conc + state, data = Puromycin, FUN = median)</code></pre>
<pre><code>##    conc     state  rate
## 1  0.02   treated  61.5
## 2  0.06   treated 102.0
## 3  0.11   treated 131.0
## 4  0.22   treated 155.5
## 5  0.56   treated 196.0
## 6  1.10   treated 203.5
## 7  0.02 untreated  59.0
## 8  0.06 untreated  85.0
## 9  0.11 untreated 106.5
## 10 0.22 untreated 127.5
## 11 0.56 untreated 151.0
## 12 1.10 untreated 160.0</code></pre>
</div>
<div id="comparaison-entre-les-fonctions-tapply-by-et-aggregate-et-la-fonction-ave" class="section level4">
<h4>Comparaison entre les fonctions <code>tapply</code>, <code>by</code> et <code>aggregate</code> et la fonction <code>ave</code> :</h4>
<p>Tout comme les fonctions <code>tapply</code>, <code>by</code> et <code>aggregate</code>, la fonction <code>ave</code> permet de calculer une statistique selon des combinaisons de niveaux de facteurs. Cependant, plutôt que de retourner une valeur par combinaison distincte, elle retourne un objet de même dimension que le premier argument qu’elle reçoit en entrée. Dans cet objet, chaque valeur est remplacée par la valeur de la statistique calculée sur toutes les valeurs associées à la même combinaison de facteurs que la valeur en question. L’exemple suivant devrait aider à clarifier cette phrase.</p>
<pre class="r"><code>Puromycin$median_rate &lt;- ave(Puromycin$rate, Puromycin$state, Puromycin$conc, FUN = median)
Puromycin</code></pre>
<pre><code>##    conc rate     state median_rate
## 1  0.02   76   treated        61.5
## 2  0.02   47   treated        61.5
## 3  0.06   97   treated       102.0
## 4  0.06  107   treated       102.0
## 5  0.11  123   treated       131.0
## 6  0.11  139   treated       131.0
## 7  0.22  159   treated       155.5
## 8  0.22  152   treated       155.5
## 9  0.56  191   treated       196.0
## 10 0.56  201   treated       196.0
## 11 1.10  207   treated       203.5
## 12 1.10  200   treated       203.5
## 13 0.02   67 untreated        59.0
## 14 0.02   51 untreated        59.0
## 15 0.06   84 untreated        85.0
## 16 0.06   86 untreated        85.0
## 17 0.11   98 untreated       106.5
## 18 0.11  115 untreated       106.5
## 19 0.22  131 untreated       127.5
## 20 0.22  124 untreated       127.5
## 21 0.56  144 untreated       151.0
## 22 0.56  158 untreated       151.0
## 23 1.10  160 untreated       160.0</code></pre>
</div>
</div>
<div id="choix-de-la-fonction-de-la-famille-des-apply-a-utiliser" class="section level2">
<h2>Choix de la fonction de la famille des <code>apply</code> à utiliser</h2>
<p>Les fonctions de la famille des <code>apply</code> servent à appliquer un même calcul sur différentes parties (sous-objets) d’une structure de données R (objet principal).</p>
<p>La structure de données peut être brisée en sous-objets de différentes façons. Par exemple, s’il s’agit d’une matrice, elle peut être séparée en lignes ou en colonnes. S’il s’agit d’une liste, elle peut être séparée en éléments. Il est aussi possible de briser un vecteur ou un data frame en blocs d’observations référant à différents niveaux de facteurs. Dans ces notes, les fonctions de la famille des <code>apply</code> ont été séparées en 3 catégories selon la façon de former les sous-objets.</p>
<p>Le format de la sortie retournée varie aussi d’une fonction à l’autre.</p>
<p>Quand vient le temps de choisir une fonction de la famille des <code>apply</code> à utiliser, il faut donc se demander :</p>
<ul>
<li>Quel est le type de l’objet sur lequel appliquer les calculs?</li>
<li>Comment les sous-objets doivent-ils être formés?</li>
<li>Quel format de sortie est le plus approprié?</li>
</ul>
<p>Le tableau suivant permet de facilement comparer les fonctions de la famille des <code>apply</code> présentées en fournissant les réponses aux questions précédentes.</p>
<table>
<colgroup>
<col width="13%" />
<col width="30%" />
<col width="33%" />
<col width="22%" />
</colgroup>
<thead>
<tr class="header">
<th>Fonction</th>
<th>Objet typique en entrée</th>
<th>Formation des sous-objets</th>
<th>Format de la sortie</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>apply</code></td>
<td>array (matrice)</td>
<td>selon une ou des dimensions</td>
<td>vecteur, array, liste</td>
</tr>
<tr class="even">
<td>—————</td>
<td>————————————</td>
<td>—————————————</td>
<td>————————–</td>
</tr>
<tr class="odd">
<td><code>lapply</code></td>
<td>vecteur, liste (data frame)</td>
<td>éléments de l’objet en entrée</td>
<td>liste</td>
</tr>
<tr class="even">
<td><code>sapply</code></td>
<td>vecteur, liste (data frame)</td>
<td>éléments de l’objet en entrée</td>
<td>simplifié par défaut</td>
</tr>
<tr class="odd">
<td><code>mapply</code></td>
<td>vecteurs, listes (data frames)</td>
<td>éléments des objets en entrée</td>
<td>simplifié par défaut</td>
</tr>
<tr class="even">
<td>—————</td>
<td>————————————</td>
<td>—————————————</td>
<td>————————–</td>
</tr>
<tr class="odd">
<td><code>tapply</code></td>
<td>vecteur</td>
<td>selon les niveaux de facteurs</td>
<td>array ou liste</td>
</tr>
<tr class="even">
<td><code>by</code></td>
<td>data frame</td>
<td>selon les niveaux de facteurs</td>
<td>array ou liste</td>
</tr>
<tr class="odd">
<td><code>aggregate</code></td>
<td>data frame</td>
<td>selon les niveaux de facteurs</td>
<td>data frame</td>
</tr>
<tr class="even">
<td> </td>
<td></td>
<td>et par colonne du data frame</td>
<td></td>
</tr>
</tbody>
</table>
<hr />
</div>
</div>
<div id="ecriture-de-conditions-logiques" class="section level1">
<h1>Écriture de conditions logiques</h1>
<p>Lors d’une analyse de données, il est fréquent de devoir extraire les observations respectant une certaine condition logique. Cette action est parfois appelée « filtrer » les observations. Pour ce faire, il faut savoir écrire des conditions logiques en R. L’écriture de conditions logiques sera aussi utile pour composer des structures conditionnelles, ce qui sera couvert plus tard.</p>
<p>Les opérateurs de comparaison <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code> et <code>&lt;=</code> sont utiles pour écrire des conditions logiques. Par exemple, reprenons le vecteur de lancés d’un dé créé dans le cours sur les <a href="https://stt4230.rbind.io/manipulation_donnees/structures_r/#fonction-c">structures de données en R</a>.</p>
<pre class="r"><code>de &lt;- c(2, 3, 4, 1, 2, 3, 5, 6, 5, 4)</code></pre>
<p>La condition logique suivante permet d’identifier les valeurs supérieures à 4 dans ce vecteur.</p>
<pre class="r"><code>de &gt; 4</code></pre>
<pre><code>##  [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE</code></pre>
<p>En fournissant le vecteur logique obtenu en argument à un opérateur ou une fonction d’extraction appliquée sur <code>de</code>, les valeurs supérieures à 4 dans ce vecteur sont retournées.</p>
<pre class="r"><code>de[de &gt; 4] </code></pre>
<pre><code>## [1] 5 6 5</code></pre>
<p>La fonction <code>which</code> permet quant à elle de savoir quelles sont les positions dans un vecteur des éléments respectant une condition logique.</p>
<pre class="r"><code>which(de &gt; 4)</code></pre>
<pre><code>## [1] 7 8 9</code></pre>
<p>Des vecteurs logiques peuvent être combinés avec <code>|</code> (ou) ou <code>&amp;</code> (et). Par exemple, la commande suivante identifie les éléments de <code>de</code> égaux à 1, 4 ou 6.</p>
<pre class="r"><code>de == 1 | de == 4 | de == 6</code></pre>
<pre><code>##  [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE</code></pre>
<p>L’opérateur <code>%in%</code> est cependant plus convivial pour créer ce vecteur logique. Il compare les éléments d’un vecteur (placé avant l’opérateur) aux éléments d’un ensemble présenté sous la forme d’un vecteur (placé après). Il retourne <code>TRUE</code> pour un élément égal à n’importe lequel des éléments de l’ensemble, <code>FALSE</code> sinon.</p>
<pre class="r"><code>de %in% c(1,4,6)</code></pre>
<pre><code>##  [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE</code></pre>
<p>Combiné à un opérateur de négation <code>!</code>, l’opérateur <code>%in%</code> permet de tester si les valeurs dans un vecteur sont différentes des valeurs d’un ensemble.</p>
<pre class="r"><code>! de %in% c(1,4,6)</code></pre>
<pre><code>##  [1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE</code></pre>
<p>Notons que tester si un ou des éléments sont égaux à <code>NA</code>, <code>NaN</code> ou <code>Inf</code> (constante pour l’infini), ne se fait pas directement avec l’opérateur <code>==</code> comme suit.</p>
<pre class="r"><code>c(1, 2, NA, 4, 5) == NA</code></pre>
<pre><code>## [1] NA NA NA NA NA</code></pre>
<p>Il faut plutôt utiliser la fonction <code>is.na</code>, <code>is.nan</code> ou <code>is.infinite</code>.</p>

<pre class="r"><code>is.na(c(1, 2, NA, 4, 5))</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE FALSE FALSE</code></pre>
<div id="operateurs-et-fonctions-retournant-toujours-un-logique-de-longueur-1" class="section level2">
<h2>Opérateurs et fonctions retournant toujours un logique de longueur 1</h2>
<p>Lors de l’écriture d’une condition logique, il faut parfois s’assurer de retourner un vecteur logique de longueur 1. C’est le cas lors de l’écriture d’une condition logique dans une structure de contrôle conditionnelle <code>if...else</code> (que nous verrons plus loin). La condition dans un <code>if</code> doit être obligatoirement de longueur 1. Les opérateurs <code>||</code> et <code>&amp;&amp;</code> sont conçus pour écrire de telles conditions logiques. Avec <code>||</code> et <code>&amp;&amp;</code>, il est certain que le résultat est de longueur 1.</p>
<pre class="r"><code>de == 1 || de == 4 || de == 6</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>Comme il a déjà été mentionné, seuls les premiers éléments des vecteurs impliqués sont comparés avec <code>||</code> ou <code>&amp;&amp;</code>.</p>
<p>De plus, la fonction <code>all</code> indique si tous les éléments d’un vecteur logique sont <code>TRUE</code>.</p>
<pre class="r"><code>v1</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE  TRUE</code></pre>
<pre class="r"><code>all(v1)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>La fonction <code>any</code> indique si au moins un élément d’un vecteur logique est <code>TRUE</code>.</p>
<pre class="r"><code>any(v1)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Finalement, les fonctions <code>is.numeric</code>, <code>is.character</code>, <code>is.logical</code>, <code>is.vector</code>, <code>is.matrix</code>, <code>is.data.frame</code>, <code>is.factor</code>, <code>is.null</code>, <code>is.function</code>, etc., testent une condition et retournent toujours un logique de longueur unitaire.</p>
<hr />
</div>
</div>
<div id="comparaison-de-deux-objets-r" class="section level1">
<h1>Comparaison de deux objets R</h1>
<p>Les opérateurs de comparaison permettent de comparer les éléments d’objets R. Mais comment comparer des objets entiers? Cela dépend de ce qui doit être comparé.</p>
<ul>
<li>Pour comparer tous les éléments, mais pas les attributs : <code>all(x == y)</code>
<ul>
<li>retourne <code>TRUE</code> si tous les éléments sont égaux,</li>
<li><code>FALSE</code> sinon,</li>
<li><code>NA</code> si un des deux objets comparés contient au moins une valeur manquante et que l’argument <code>na.rm</code> de la fonction <code>all</code> prend la valeur <code>FALSE</code>.</li>
</ul></li>
<li>Pour comparer les objets dans leur totalité (éléments, attributs, type de l’objet et de ses éléments) : <code>identical(x, y)</code>
<ul>
<li>retourne <code>TRUE</code> si les deux objets comparés sont totalement identiques,</li>
<li><code>FALSE</code> sinon.</li>
</ul></li>
<li>Pour comparer tous les éléments et les attributs, en acceptant des différences dans les valeurs numériques selon une certaine tolérance : <code>all.equal(x, y)</code>
<ul>
<li>retourne <code>TRUE</code> en cas d’égalité respectant la tolérance,</li>
<li>sinon retourne des informations sur les différences.</li>
</ul></li>
</ul>
<p>Voici quelques exemples.</p>
<div id="elements-identiques-mais-attributs-differents" class="section level4">
<h4>Éléments identiques, mais attributs différents</h4>
<pre class="r"><code>x &lt;- 1:5
y &lt;- 1:5
names(x) &lt;- letters[1:5]
str(x)</code></pre>
<pre><code>##  Named int [1:5] 1 2 3 4 5
##  - attr(*, &quot;names&quot;)= chr [1:5] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ...</code></pre>
<pre class="r"><code>str(y)</code></pre>
<pre><code>##  int [1:5] 1 2 3 4 5</code></pre>
<pre class="r"><code>all(x == y)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>identical(x, y)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>all.equal(x, y)</code></pre>
<pre><code>## [1] &quot;names for target but not for current&quot;</code></pre>
</div>
<div id="elements-equivalents-mais-de-types-differents-attributs-identiques" class="section level4">
<h4>Éléments équivalents, mais de types différents, attributs identiques</h4>
<pre class="r"><code>x &lt;- as.double(x)
str(x)</code></pre>
<pre><code>##  num [1:5] 1 2 3 4 5</code></pre>
<pre class="r"><code>str(y)</code></pre>
<pre><code>##  int [1:5] 1 2 3 4 5</code></pre>
<pre class="r"><code>all(x == y)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>identical(x, y)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>all.equal(x, y)</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="elements-numeriques-pas-tout-a-fait-identiques-attributs-et-types-identiques" class="section level4">
<h4>Éléments numériques pas tout à fait identiques, attributs et types identiques</h4>
<pre class="r"><code>y &lt;- 1:5 + 1e-10
str(x)</code></pre>
<pre><code>##  num [1:5] 1 2 3 4 5</code></pre>
<pre class="r"><code>str(y)</code></pre>
<pre><code>##  num [1:5] 1 2 3 4 5</code></pre>
<p>Bien que les valeurs numériques dans <code>x</code> et <code>y</code> ne soient pas tout à fait identiques, elles semblent identiques à l’affichage de <code>x</code> et <code>y</code>.</p>
<pre class="r"><code>all(x == y)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>identical(x, y)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>all.equal(x, y)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Rappel : Il est possible de contrôler le nombre de chiffres affichés dans un nombre avec l’option <code>digits</code> de la session R.</p>
<pre class="r"><code>optionsDefaut &lt;- options()
optionsDefaut$digits # valeur par défaut</code></pre>
<pre><code>## [1] 7</code></pre>
<pre class="r"><code>options(digits = 11)
x</code></pre>
<pre><code>## [1] 1 2 3 4 5</code></pre>
<pre class="r"><code>y</code></pre>
<pre><code>## [1] 1.0000000001 2.0000000001 3.0000000001 4.0000000001 5.0000000001</code></pre>
<p>L’option <code>digits</code> est remise à sa valeur par défaut comme suit.</p>
<pre class="r"><code>options(digits = optionsDefaut$digits)</code></pre>
<hr />

</div>
</div>
<div id="synthese" class="section level1">
<h1>Synthèse</h1>
<div id="fonctions-et-operateurs-de-base-pour-le-calcul-mathematique-ou-de-statistiques-descriptives" class="section level4">
<h4>Fonctions et opérateurs de base pour le calcul mathématique ou de statistiques descriptives</h4>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-129"></span>
<img src="fig/SyntheseFctOpMathStat.png" alt="Vue d'ensemble de plusieurs fonctions et opérateurs mathématiques et statistiques en R" width="95%" />
<p class="caption">
Figure 1: Vue d’ensemble de plusieurs fonctions et opérateurs mathématiques et statistiques en R
</p>
</div>
<div id="calculs-mathematiques" class="section level5">
<h5>Calculs mathématiques :</h5>
<ul>
<li>fonctionnement vectoriel et règle de recyclage : calculs terme à terme entre deux objets atomiques;</li>
<li>mots-clés mathématiques : <code>pi</code>, <code>Inf</code>, <code>NaN</code>;</li>
<li>opérations sur des ensembles : <code>union</code>, <code>intersect</code>, <code>setdiff</code>, <code>setequal</code>, <code>is.element</code>.</li>
</ul>
</div>
<div id="calcul-de-statistiques-descriptives" class="section level5">
<h5>Calcul de statistiques descriptives :</h5>
<ul>
<li>argument <code>na.rm</code> : spécifie le comportement de la fonction en présence de valeurs manquantes;</li>
<li>traitement des observations dupliquées : <code>duplicated</code>, <code>unique</code>.</li>
</ul>
</div>
</div>
<div id="fonctions-r-de-la-famille-des-apply" class="section level4">
<h4>Fonctions R de la famille des <code>apply</code></h4>
<p>Principe de base derrière ces fonctions (qui cachent des boucles) :</p>
<ul>
<li>séparer un objet en sous-objets;</li>
<li>appeler une fonction en lui donnant comme premier argument tous les sous-objets, un à la fois;</li>
<li>combiner les résultats obtenus.</li>
</ul>

<p>Résumé du fonctionnement des fonctions présentées :</p>
<table>
<colgroup>
<col width="13%" />
<col width="30%" />
<col width="33%" />
<col width="22%" />
</colgroup>
<thead>
<tr class="header">
<th>Fonction</th>
<th>Objet typique en entrée</th>
<th>Formation des sous-objets</th>
<th>Format de la sortie</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>apply</code></td>
<td>array (matrice)</td>
<td>selon une ou des dimensions</td>
<td>vecteur, array, liste</td>
</tr>
<tr class="even">
<td>—————</td>
<td>————————————</td>
<td>—————————————</td>
<td>————————–</td>
</tr>
<tr class="odd">
<td><code>lapply</code></td>
<td>vecteur, liste (data frame)</td>
<td>éléments de l’objet en entrée</td>
<td>liste</td>
</tr>
<tr class="even">
<td><code>sapply</code></td>
<td>vecteur, liste (data frame)</td>
<td>éléments de l’objet en entrée</td>
<td>simplifié par défaut</td>
</tr>
<tr class="odd">
<td><code>mapply</code></td>
<td>vecteurs, listes (data frames)</td>
<td>éléments des objets en entrée</td>
<td>simplifié par défaut</td>
</tr>
<tr class="even">
<td>—————</td>
<td>————————————</td>
<td>—————————————</td>
<td>————————–</td>
</tr>
<tr class="odd">
<td><code>tapply</code></td>
<td>vecteur</td>
<td>selon les niveaux de facteurs</td>
<td>array ou liste</td>
</tr>
<tr class="even">
<td><code>by</code></td>
<td>data frame</td>
<td>selon les niveaux de facteurs</td>
<td>array ou liste</td>
</tr>
<tr class="odd">
<td><code>aggregate</code></td>
<td>data frame</td>
<td>selon les niveaux de facteurs</td>
<td>data frame</td>
</tr>
<tr class="even">
<td> </td>
<td></td>
<td>et par colonne du data frame</td>
<td></td>
</tr>
</tbody>
</table>
<p>Description des arguments à donner en entrée à ces fonctions :</p>
<ul>
<li><p>1<sup>e</sup> argument (sauf pour <code>mapply</code>) : objet à séparer et sur lequel appliquer la fonction;</p></li>
<li><p>argument suivant : information pour spécifier comment séparer l’objet en sous-objets (sauf pour les fonctions prenant en entrée une liste, soit pour <code>lapply</code>, <code>sapply</code> et <code>mapply</code>, car dans ce cas les sous-objets sont les éléments de la liste);</p></li>
<li><p>argument suivant (celui nommé <code>FUN</code>) : la fonction à appliquer (les sous-objets lui seront fournis comme premier argument);</p></li>
<li><p><code>...</code> : il est possible de passer des arguments supplémentaires à la fonction à appliquer (<code>FUN</code>) simplement en les donnant en argument à la fonction de la famille des <code>apply</code> grâce aux <code>...</code> (rappel : il s’agit de la deuxième utilité de l’argument <code>...</code> mentionnée dans les notes sur les <a href="https://stt4230.rbind.io/introduction/base_r/#largument-...-et-ses-deux-utilites.">concepts de base en R</a>).</p></li>
</ul>
<p>Note : La fonction <code>aggregate</code> accepte aussi une formule en entrée.</p>
</div>
<div id="ecriture-de-conditions-logiques-1" class="section level4">
<h4>Écriture de conditions logiques</h4>
<p>Fonctions opérant de façon vectorielle :</p>
<ul>
<li>Opérateurs de comparaison : <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code> , <code>&lt;</code>, <code>&lt;=</code>.</li>
<li>Opérateur de comparaison à un ensemble de valeurs : <code>%in%</code>.</li>
<li>Fonctions de comparaison pour caractères spéciaux : <code>is.na</code>, <code>is.nan</code>, <code>is.infinite</code>.</li>
<li>Opérateurs logiques : <code>!</code> (négation), <code>|</code> (ou), <code>&amp;</code> (et).</li>
</ul>
<p>Fonctions retournant toujours un logique de longueur 1 :</p>
<ul>
<li>Opérateurs logiques (qui utilisent seulement le premier élément des vecteurs) : <code>||</code> (ou), <code>&amp;&amp;</code> (et).</li>
<li>Fonctions qui condensent un vecteur logique en une seule valeur logique : <code>all</code>, <code>any</code>.</li>
<li>Fonctions de vérification de type :<br />
<code>is.</code>(<code>numeric</code>/<code>character</code>/<code>logical</code>/<code>vector</code>/<code>matrix</code>/<code>array</code>/<code>list</code>/<code>data.frame</code>/<code>factor</code>/<code>null</code>/…)<br />
(il en existe beaucoup!).</li>
</ul>
</div>
<div id="comparaison-de-deux-objets-r-1" class="section level4">
<h4>Comparaison de deux objets R</h4>
<ul>
<li>Pour comparer uniquement les valeurs, pas les attributs : <code>all(x == y)</code>.</li>
<li>Pour comparer les objets dans leur totalité (valeurs, attributs, type de l’objet ou des éléments) : <code>identical(x, y)</code>.</li>
<li>Pour comparer les valeurs et les attributs, en acceptant des différences dans les valeurs numériques selon une certaine tolérance : <code>all.equal(x, y)</code>.</li>
</ul>
<hr />
</div>
</div>
<div id="references" class="section level1">
<h1>Références</h1>
<ul>
<li>Cotton, R. (2013). Learning R: A Step-by-Step Function Guide to Data Analysis, O’Reilly Media.</li>
<li>Teetor, P. (2011). R Cookbook. O’Reilly Media. <a href="http://www.cookbook-r.com/" class="uri">http://www.cookbook-r.com/</a></li>
<li>Muenchen, R. A. (2011). R for SAS and SPSS Users. Second edition. Springer.</li>
<li>Zumel, N. et Mount, J. (2014). Practical Data Science with R. Manning Publications Co.</li>
<li>Zuur, A. F., Ieno, E. N. et Meesters, E. H.W.G. (2009). A Beginner’s Guide to R. Springer.</li>
</ul>
<div id="pour-mieux-comprendre-les-fonctions-de-la-famille-des-apply" class="section level4">
<h4>Pour mieux comprendre les fonctions de la famille des <code>apply</code></h4>
<ul>
<li><a href="https://www.datacamp.com/community/tutorials/r-tutorial-apply-family" class="uri">https://www.datacamp.com/community/tutorials/r-tutorial-apply-family</a></li>
</ul>
</div>
<div id="pour-aller-plus-loin" class="section level4">
<h4>Pour aller plus loin</h4>
<p>Le package <a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a> offre des fonctions permettant de réaliser quelques-unes des manipulations de données vues dans ce cours ainsi que le cours précédent, par exemple :</p>
<ul>
<li>alternatives à <code>[</code> ou <code>subset</code> :
<ul>
<li>sélectionner des lignes avec <code>filter</code>;</li>
<li>sélectionner des colonnes avec <code>select</code>;</li>
</ul></li>
<li>alternative à <code>aggregate</code>:
<ul>
<li>créer des jeux de données agrégés avec <code>group_by</code> et <code>summarise</code>;</li>
</ul></li>
<li>etc.</li>
</ul>
<p>Ce package est très populaire. Les <a href="https://stt4230.rbind.io/tutoriels_etudiants/hiver_2016/">tutoriels rédigés par des étudiants du cours en 2016</a>, dans le cadre d’un travail pratique, illustrent l’utilisation de diverses fonctions de ce package.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://fr.wikipedia.org/wiki/Table_de_v%C3%A9rit%C3%A9">https://fr.wikipedia.org/wiki/Table_de_v%C3%A9rit%C3%A9</a><a href="#fnref1">↩</a></p></li>
</ol>
</div>
